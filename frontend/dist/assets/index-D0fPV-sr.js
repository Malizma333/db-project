var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) =>
  member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (
  __accessCheck(obj, member, "read from private field"),
  getter ? getter.call(obj) : member.get(obj)
);
var __privateAdd = (obj, member, value) =>
  member.has(obj)
    ? __typeError("Cannot add the same private member more than once")
    : member instanceof WeakSet
      ? member.add(obj)
      : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (
  __accessCheck(obj, member, "write to private field"),
  setter ? setter.call(obj, value) : member.set(obj, value),
  value
);
var __privateMethod = (obj, member, method) => (
  __accessCheck(obj, member, "access private method"), method
);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  },
});
var _a,
  _focused,
  _cleanup,
  _setup,
  _b,
  _online,
  _cleanup2,
  _setup2,
  _c,
  _gcTimeout,
  _d,
  _initialState,
  _revertState,
  _cache,
  _client,
  _retryer,
  _defaultOptions,
  _abortSignalConsumed,
  _Query_instances,
  dispatch_fn,
  _e,
  _queries,
  _f,
  _observers,
  _mutationCache,
  _retryer2,
  _Mutation_instances,
  dispatch_fn2,
  _g,
  _mutations,
  _scopes,
  _mutationId,
  _h,
  _queryCache,
  _mutationCache2,
  _defaultOptions2,
  _queryDefaults,
  _mutationDefaults,
  _mountCount,
  _unsubscribeFocus,
  _unsubscribeOnline,
  _i,
  _client2,
  _currentQuery,
  _currentQueryInitialState,
  _currentResult,
  _currentResultState,
  _currentResultOptions,
  _currentThenable,
  _selectError,
  _selectFn,
  _selectResult,
  _lastQueryWithDefinedData,
  _staleTimeoutId,
  _refetchIntervalId,
  _currentRefetchInterval,
  _trackedProps,
  _QueryObserver_instances,
  executeFetch_fn,
  updateStaleTimeout_fn,
  computeRefetchInterval_fn,
  updateRefetchInterval_fn,
  updateTimers_fn,
  clearStaleTimeout_fn,
  clearRefetchInterval_fn,
  updateQuery_fn,
  notify_fn,
  _j;
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var n$a,
  l$5,
  u$6,
  i$9,
  r$a,
  o$e,
  e$d,
  f$6,
  c$5,
  s$4,
  a$4,
  h$5,
  p$3 = {},
  v$2 = [],
  y$3 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,
  d$3 = Array.isArray;
function w$2(n3, l2) {
  for (var u2 in l2) n3[u2] = l2[u2];
  return n3;
}
function _$2(n3) {
  n3 && n3.parentNode && n3.parentNode.removeChild(n3);
}
function g$3(l2, u2, t2) {
  var i3,
    r3,
    o2,
    e3 = {};
  for (o2 in u2)
    "key" == o2
      ? (i3 = u2[o2])
      : "ref" == o2
        ? (r3 = u2[o2])
        : (e3[o2] = u2[o2]);
  if (
    (arguments.length > 2 &&
      (e3.children = arguments.length > 3 ? n$a.call(arguments, 2) : t2),
    "function" == typeof l2 && null != l2.defaultProps)
  )
    for (o2 in l2.defaultProps)
      void 0 === e3[o2] && (e3[o2] = l2.defaultProps[o2]);
  return m$3(l2, e3, i3, r3, null);
}
function m$3(n3, t2, i3, r3, o2) {
  var e3 = {
    type: n3,
    props: t2,
    key: i3,
    ref: r3,
    __k: null,
    __: null,
    __b: 0,
    __e: null,
    __c: null,
    constructor: void 0,
    __v: null == o2 ? ++u$6 : o2,
    __i: -1,
    __u: 0,
  };
  return null == o2 && null != l$5.vnode && l$5.vnode(e3), e3;
}
function b$2() {
  return { current: null };
}
function k$3(n3) {
  return n3.children;
}
function x$3(n3, l2) {
  (this.props = n3), (this.context = l2);
}
function C$3(n3, l2) {
  if (null == l2) return n3.__ ? C$3(n3.__, n3.__i + 1) : null;
  for (var u2; l2 < n3.__k.length; l2++)
    if (null != (u2 = n3.__k[l2]) && null != u2.__e) return u2.__e;
  return "function" == typeof n3.type ? C$3(n3) : null;
}
function S$2(n3) {
  var l2, u2;
  if (null != (n3 = n3.__) && null != n3.__c) {
    for (n3.__e = n3.__c.base = null, l2 = 0; l2 < n3.__k.length; l2++)
      if (null != (u2 = n3.__k[l2]) && null != u2.__e) {
        n3.__e = n3.__c.base = u2.__e;
        break;
      }
    return S$2(n3);
  }
}
function M$2(n3) {
  ((!n3.__d && (n3.__d = true) && i$9.push(n3) && !P$3.__r++) ||
    r$a !== l$5.debounceRendering) &&
    ((r$a = l$5.debounceRendering) || o$e)(P$3);
}
function P$3() {
  var n3, u2, t2, r3, o2, f2, c2, s2;
  for (i$9.sort(e$d); (n3 = i$9.shift()); )
    n3.__d &&
      ((u2 = i$9.length),
      (r3 = void 0),
      (f2 = (o2 = (t2 = n3).__v).__e),
      (c2 = []),
      (s2 = []),
      t2.__P &&
        (((r3 = w$2({}, o2)).__v = o2.__v + 1),
        l$5.vnode && l$5.vnode(r3),
        j$3(
          t2.__P,
          r3,
          o2,
          t2.__n,
          t2.__P.namespaceURI,
          32 & o2.__u ? [f2] : null,
          c2,
          null == f2 ? C$3(o2) : f2,
          !!(32 & o2.__u),
          s2,
        ),
        (r3.__v = o2.__v),
        (r3.__.__k[r3.__i] = r3),
        z$3(c2, r3, s2),
        r3.__e != f2 && S$2(r3)),
      i$9.length > u2 && i$9.sort(e$d));
  P$3.__r = 0;
}
function $$2(n3, l2, u2, t2, i3, r3, o2, e3, f2, c2, s2) {
  var a2,
    h2,
    y2,
    d2,
    w2,
    _2,
    g2 = (t2 && t2.__k) || v$2,
    m2 = l2.length;
  for (f2 = I$2(u2, l2, g2, f2, m2), a2 = 0; a2 < m2; a2++)
    null != (y2 = u2.__k[a2]) &&
      ((h2 = -1 === y2.__i ? p$3 : g2[y2.__i] || p$3),
      (y2.__i = a2),
      (_2 = j$3(n3, y2, h2, i3, r3, o2, e3, f2, c2, s2)),
      (d2 = y2.__e),
      y2.ref &&
        h2.ref != y2.ref &&
        (h2.ref && V$2(h2.ref, null, y2), s2.push(y2.ref, y2.__c || d2, y2)),
      null == w2 && null != d2 && (w2 = d2),
      4 & y2.__u || h2.__k === y2.__k
        ? (f2 = A$3(y2, f2, n3))
        : "function" == typeof y2.type && void 0 !== _2
          ? (f2 = _2)
          : d2 && (f2 = d2.nextSibling),
      (y2.__u &= -7));
  return (u2.__e = w2), f2;
}
function I$2(n3, l2, u2, t2, i3) {
  var r3,
    o2,
    e3,
    f2,
    c2,
    s2 = u2.length,
    a2 = s2,
    h2 = 0;
  for (n3.__k = new Array(i3), r3 = 0; r3 < i3; r3++)
    null != (o2 = l2[r3]) && "boolean" != typeof o2 && "function" != typeof o2
      ? ((f2 = r3 + h2),
        ((o2 = n3.__k[r3] =
          "string" == typeof o2 ||
          "number" == typeof o2 ||
          "bigint" == typeof o2 ||
          o2.constructor == String
            ? m$3(null, o2, null, null, null)
            : d$3(o2)
              ? m$3(k$3, { children: o2 }, null, null, null)
              : void 0 === o2.constructor && o2.__b > 0
                ? m$3(o2.type, o2.props, o2.key, o2.ref ? o2.ref : null, o2.__v)
                : o2).__ = n3),
        (o2.__b = n3.__b + 1),
        (e3 = null),
        -1 !== (c2 = o2.__i = L$2(o2, u2, f2, a2)) &&
          (a2--, (e3 = u2[c2]) && (e3.__u |= 2)),
        null == e3 || null === e3.__v
          ? (-1 == c2 && h2--, "function" != typeof o2.type && (o2.__u |= 4))
          : c2 != f2 &&
            (c2 == f2 - 1
              ? h2--
              : c2 == f2 + 1
                ? h2++
                : (c2 > f2 ? h2-- : h2++, (o2.__u |= 4))))
      : (n3.__k[r3] = null);
  if (a2)
    for (r3 = 0; r3 < s2; r3++)
      null != (e3 = u2[r3]) &&
        0 == (2 & e3.__u) &&
        (e3.__e == t2 && (t2 = C$3(e3)), q$2(e3, e3));
  return t2;
}
function A$3(n3, l2, u2) {
  var t2, i3;
  if ("function" == typeof n3.type) {
    for (t2 = n3.__k, i3 = 0; t2 && i3 < t2.length; i3++)
      t2[i3] && ((t2[i3].__ = n3), (l2 = A$3(t2[i3], l2, u2)));
    return l2;
  }
  n3.__e != l2 &&
    (l2 && n3.type && !u2.contains(l2) && (l2 = C$3(n3)),
    u2.insertBefore(n3.__e, l2 || null),
    (l2 = n3.__e));
  do {
    l2 = l2 && l2.nextSibling;
  } while (null != l2 && 8 == l2.nodeType);
  return l2;
}
function H$3(n3, l2) {
  return (
    (l2 = l2 || []),
    null == n3 ||
      "boolean" == typeof n3 ||
      (d$3(n3)
        ? n3.some(function (n4) {
            H$3(n4, l2);
          })
        : l2.push(n3)),
    l2
  );
}
function L$2(n3, l2, u2, t2) {
  var i3,
    r3,
    o2 = n3.key,
    e3 = n3.type,
    f2 = l2[u2];
  if (
    null === f2 ||
    (f2 && o2 == f2.key && e3 === f2.type && 0 == (2 & f2.__u))
  )
    return u2;
  if (t2 > (null != f2 && 0 == (2 & f2.__u) ? 1 : 0))
    for (i3 = u2 - 1, r3 = u2 + 1; i3 >= 0 || r3 < l2.length; ) {
      if (i3 >= 0) {
        if (
          (f2 = l2[i3]) &&
          0 == (2 & f2.__u) &&
          o2 == f2.key &&
          e3 === f2.type
        )
          return i3;
        i3--;
      }
      if (r3 < l2.length) {
        if (
          (f2 = l2[r3]) &&
          0 == (2 & f2.__u) &&
          o2 == f2.key &&
          e3 === f2.type
        )
          return r3;
        r3++;
      }
    }
  return -1;
}
function T$3(n3, l2, u2) {
  "-" == l2[0]
    ? n3.setProperty(l2, null == u2 ? "" : u2)
    : (n3[l2] =
        null == u2
          ? ""
          : "number" != typeof u2 || y$3.test(l2)
            ? u2
            : u2 + "px");
}
function F$2(n3, l2, u2, t2, i3) {
  var r3;
  n: if ("style" == l2)
    if ("string" == typeof u2) n3.style.cssText = u2;
    else {
      if (("string" == typeof t2 && (n3.style.cssText = t2 = ""), t2))
        for (l2 in t2) (u2 && l2 in u2) || T$3(n3.style, l2, "");
      if (u2)
        for (l2 in u2) (t2 && u2[l2] === t2[l2]) || T$3(n3.style, l2, u2[l2]);
    }
  else if ("o" == l2[0] && "n" == l2[1])
    (r3 = l2 != (l2 = l2.replace(f$6, "$1"))),
      (l2 =
        l2.toLowerCase() in n3 || "onFocusOut" == l2 || "onFocusIn" == l2
          ? l2.toLowerCase().slice(2)
          : l2.slice(2)),
      n3.l || (n3.l = {}),
      (n3.l[l2 + r3] = u2),
      u2
        ? t2
          ? (u2.u = t2.u)
          : ((u2.u = c$5), n3.addEventListener(l2, r3 ? a$4 : s$4, r3))
        : n3.removeEventListener(l2, r3 ? a$4 : s$4, r3);
  else {
    if ("http://www.w3.org/2000/svg" == i3)
      l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if (
      "width" != l2 &&
      "height" != l2 &&
      "href" != l2 &&
      "list" != l2 &&
      "form" != l2 &&
      "tabIndex" != l2 &&
      "download" != l2 &&
      "rowSpan" != l2 &&
      "colSpan" != l2 &&
      "role" != l2 &&
      "popover" != l2 &&
      l2 in n3
    )
      try {
        n3[l2] = null == u2 ? "" : u2;
        break n;
      } catch (n4) {}
    "function" == typeof u2 ||
      (null == u2 || (false === u2 && "-" != l2[4])
        ? n3.removeAttribute(l2)
        : n3.setAttribute(l2, "popover" == l2 && 1 == u2 ? "" : u2));
  }
}
function O$1(n3) {
  return function (u2) {
    if (this.l) {
      var t2 = this.l[u2.type + n3];
      if (null == u2.t) u2.t = c$5++;
      else if (u2.t < t2.u) return;
      return t2(l$5.event ? l$5.event(u2) : u2);
    }
  };
}
function j$3(n3, u2, t2, i3, r3, o2, e3, f2, c2, s2) {
  var a2,
    h2,
    p2,
    v2,
    y2,
    g2,
    m2,
    b3,
    C2,
    S2,
    M3,
    P2,
    I3,
    A2,
    H3,
    L3,
    T2,
    F2 = u2.type;
  if (void 0 !== u2.constructor) return null;
  128 & t2.__u && ((c2 = !!(32 & t2.__u)), (o2 = [(f2 = u2.__e = t2.__e)])),
    (a2 = l$5.__b) && a2(u2);
  n: if ("function" == typeof F2)
    try {
      if (
        ((b3 = u2.props),
        (C2 = "prototype" in F2 && F2.prototype.render),
        (S2 = (a2 = F2.contextType) && i3[a2.__c]),
        (M3 = a2 ? (S2 ? S2.props.value : a2.__) : i3),
        t2.__c
          ? (m2 = (h2 = u2.__c = t2.__c).__ = h2.__E)
          : (C2
              ? (u2.__c = h2 = new F2(b3, M3))
              : ((u2.__c = h2 = new x$3(b3, M3)),
                (h2.constructor = F2),
                (h2.render = B$3)),
            S2 && S2.sub(h2),
            (h2.props = b3),
            h2.state || (h2.state = {}),
            (h2.context = M3),
            (h2.__n = i3),
            (p2 = h2.__d = true),
            (h2.__h = []),
            (h2._sb = [])),
        C2 && null == h2.__s && (h2.__s = h2.state),
        C2 &&
          null != F2.getDerivedStateFromProps &&
          (h2.__s == h2.state && (h2.__s = w$2({}, h2.__s)),
          w$2(h2.__s, F2.getDerivedStateFromProps(b3, h2.__s))),
        (v2 = h2.props),
        (y2 = h2.state),
        (h2.__v = u2),
        p2)
      )
        C2 &&
          null == F2.getDerivedStateFromProps &&
          null != h2.componentWillMount &&
          h2.componentWillMount(),
          C2 &&
            null != h2.componentDidMount &&
            h2.__h.push(h2.componentDidMount);
      else {
        if (
          (C2 &&
            null == F2.getDerivedStateFromProps &&
            b3 !== v2 &&
            null != h2.componentWillReceiveProps &&
            h2.componentWillReceiveProps(b3, M3),
          !h2.__e &&
            ((null != h2.shouldComponentUpdate &&
              false === h2.shouldComponentUpdate(b3, h2.__s, M3)) ||
              u2.__v == t2.__v))
        ) {
          for (
            u2.__v != t2.__v &&
              ((h2.props = b3), (h2.state = h2.__s), (h2.__d = false)),
              u2.__e = t2.__e,
              u2.__k = t2.__k,
              u2.__k.some(function (n4) {
                n4 && (n4.__ = u2);
              }),
              P2 = 0;
            P2 < h2._sb.length;
            P2++
          )
            h2.__h.push(h2._sb[P2]);
          (h2._sb = []), h2.__h.length && e3.push(h2);
          break n;
        }
        null != h2.componentWillUpdate &&
          h2.componentWillUpdate(b3, h2.__s, M3),
          C2 &&
            null != h2.componentDidUpdate &&
            h2.__h.push(function () {
              h2.componentDidUpdate(v2, y2, g2);
            });
      }
      if (
        ((h2.context = M3),
        (h2.props = b3),
        (h2.__P = n3),
        (h2.__e = false),
        (I3 = l$5.__r),
        (A2 = 0),
        C2)
      ) {
        for (
          h2.state = h2.__s,
            h2.__d = false,
            I3 && I3(u2),
            a2 = h2.render(h2.props, h2.state, h2.context),
            H3 = 0;
          H3 < h2._sb.length;
          H3++
        )
          h2.__h.push(h2._sb[H3]);
        h2._sb = [];
      } else
        do {
          (h2.__d = false),
            I3 && I3(u2),
            (a2 = h2.render(h2.props, h2.state, h2.context)),
            (h2.state = h2.__s);
        } while (h2.__d && ++A2 < 25);
      (h2.state = h2.__s),
        null != h2.getChildContext &&
          (i3 = w$2(w$2({}, i3), h2.getChildContext())),
        C2 &&
          !p2 &&
          null != h2.getSnapshotBeforeUpdate &&
          (g2 = h2.getSnapshotBeforeUpdate(v2, y2)),
        (f2 = $$2(
          n3,
          d$3(
            (L3 =
              null != a2 && a2.type === k$3 && null == a2.key
                ? a2.props.children
                : a2),
          )
            ? L3
            : [L3],
          u2,
          t2,
          i3,
          r3,
          o2,
          e3,
          f2,
          c2,
          s2,
        )),
        (h2.base = u2.__e),
        (u2.__u &= -161),
        h2.__h.length && e3.push(h2),
        m2 && (h2.__E = h2.__ = null);
    } catch (n4) {
      if (((u2.__v = null), c2 || null != o2))
        if (n4.then) {
          for (
            u2.__u |= c2 ? 160 : 128;
            f2 && 8 == f2.nodeType && f2.nextSibling;

          )
            f2 = f2.nextSibling;
          (o2[o2.indexOf(f2)] = null), (u2.__e = f2);
        } else for (T2 = o2.length; T2--; ) _$2(o2[T2]);
      else (u2.__e = t2.__e), (u2.__k = t2.__k);
      l$5.__e(n4, u2, t2);
    }
  else
    null == o2 && u2.__v == t2.__v
      ? ((u2.__k = t2.__k), (u2.__e = t2.__e))
      : (f2 = u2.__e = N$2(t2.__e, u2, t2, i3, r3, o2, e3, c2, s2));
  return (a2 = l$5.diffed) && a2(u2), 128 & u2.__u ? void 0 : f2;
}
function z$3(n3, u2, t2) {
  for (var i3 = 0; i3 < t2.length; i3++) V$2(t2[i3], t2[++i3], t2[++i3]);
  l$5.__c && l$5.__c(u2, n3),
    n3.some(function (u3) {
      try {
        (n3 = u3.__h),
          (u3.__h = []),
          n3.some(function (n4) {
            n4.call(u3);
          });
      } catch (n4) {
        l$5.__e(n4, u3.__v);
      }
    });
}
function N$2(u2, t2, i3, r3, o2, e3, f2, c2, s2) {
  var a2,
    h2,
    v2,
    y2,
    w2,
    g2,
    m2,
    b3 = i3.props,
    k3 = t2.props,
    x2 = t2.type;
  if (
    ("svg" == x2
      ? (o2 = "http://www.w3.org/2000/svg")
      : "math" == x2
        ? (o2 = "http://www.w3.org/1998/Math/MathML")
        : o2 || (o2 = "http://www.w3.org/1999/xhtml"),
    null != e3)
  ) {
    for (a2 = 0; a2 < e3.length; a2++)
      if (
        (w2 = e3[a2]) &&
        "setAttribute" in w2 == !!x2 &&
        (x2 ? w2.localName == x2 : 3 == w2.nodeType)
      ) {
        (u2 = w2), (e3[a2] = null);
        break;
      }
  }
  if (null == u2) {
    if (null == x2) return document.createTextNode(k3);
    (u2 = document.createElementNS(o2, x2, k3.is && k3)),
      c2 && (l$5.__m && l$5.__m(t2, e3), (c2 = false)),
      (e3 = null);
  }
  if (null === x2) b3 === k3 || (c2 && u2.data === k3) || (u2.data = k3);
  else {
    if (
      ((e3 = e3 && n$a.call(u2.childNodes)),
      (b3 = i3.props || p$3),
      !c2 && null != e3)
    )
      for (b3 = {}, a2 = 0; a2 < u2.attributes.length; a2++)
        b3[(w2 = u2.attributes[a2]).name] = w2.value;
    for (a2 in b3)
      if (((w2 = b3[a2]), "children" == a2));
      else if ("dangerouslySetInnerHTML" == a2) v2 = w2;
      else if (!(a2 in k3)) {
        if (
          ("value" == a2 && "defaultValue" in k3) ||
          ("checked" == a2 && "defaultChecked" in k3)
        )
          continue;
        F$2(u2, a2, null, w2, o2);
      }
    for (a2 in k3)
      (w2 = k3[a2]),
        "children" == a2
          ? (y2 = w2)
          : "dangerouslySetInnerHTML" == a2
            ? (h2 = w2)
            : "value" == a2
              ? (g2 = w2)
              : "checked" == a2
                ? (m2 = w2)
                : (c2 && "function" != typeof w2) ||
                  b3[a2] === w2 ||
                  F$2(u2, a2, w2, b3[a2], o2);
    if (h2)
      c2 ||
        (v2 && (h2.__html === v2.__html || h2.__html === u2.innerHTML)) ||
        (u2.innerHTML = h2.__html),
        (t2.__k = []);
    else if (
      (v2 && (u2.innerHTML = ""),
      $$2(
        u2,
        d$3(y2) ? y2 : [y2],
        t2,
        i3,
        r3,
        "foreignObject" == x2 ? "http://www.w3.org/1999/xhtml" : o2,
        e3,
        f2,
        e3 ? e3[0] : i3.__k && C$3(i3, 0),
        c2,
        s2,
      ),
      null != e3)
    )
      for (a2 = e3.length; a2--; ) _$2(e3[a2]);
    c2 ||
      ((a2 = "value"),
      "progress" == x2 && null == g2
        ? u2.removeAttribute("value")
        : void 0 !== g2 &&
          (g2 !== u2[a2] ||
            ("progress" == x2 && !g2) ||
            ("option" == x2 && g2 !== b3[a2])) &&
          F$2(u2, a2, g2, b3[a2], o2),
      (a2 = "checked"),
      void 0 !== m2 && m2 !== u2[a2] && F$2(u2, a2, m2, b3[a2], o2));
  }
  return u2;
}
function V$2(n3, u2, t2) {
  try {
    if ("function" == typeof n3) {
      var i3 = "function" == typeof n3.__u;
      i3 && n3.__u(), (i3 && null == u2) || (n3.__u = n3(u2));
    } else n3.current = u2;
  } catch (n4) {
    l$5.__e(n4, t2);
  }
}
function q$2(n3, u2, t2) {
  var i3, r3;
  if (
    (l$5.unmount && l$5.unmount(n3),
    (i3 = n3.ref) &&
      ((i3.current && i3.current !== n3.__e) || V$2(i3, null, u2)),
    null != (i3 = n3.__c))
  ) {
    if (i3.componentWillUnmount)
      try {
        i3.componentWillUnmount();
      } catch (n4) {
        l$5.__e(n4, u2);
      }
    i3.base = i3.__P = null;
  }
  if ((i3 = n3.__k))
    for (r3 = 0; r3 < i3.length; r3++)
      i3[r3] && q$2(i3[r3], u2, t2 || "function" != typeof n3.type);
  t2 || _$2(n3.__e), (n3.__c = n3.__ = n3.__e = void 0);
}
function B$3(n3, l2, u2) {
  return this.constructor(n3, u2);
}
function D$2(u2, t2, i3) {
  var r3, o2, e3, f2;
  t2 == document && (t2 = document.documentElement),
    l$5.__ && l$5.__(u2, t2),
    (o2 = (r3 = "function" == typeof i3) ? null : (i3 && i3.__k) || t2.__k),
    (e3 = []),
    (f2 = []),
    j$3(
      t2,
      (u2 = ((!r3 && i3) || t2).__k = g$3(k$3, null, [u2])),
      o2 || p$3,
      p$3,
      t2.namespaceURI,
      !r3 && i3
        ? [i3]
        : o2
          ? null
          : t2.firstChild
            ? n$a.call(t2.childNodes)
            : null,
      e3,
      !r3 && i3 ? i3 : o2 ? o2.__e : t2.firstChild,
      r3,
      f2,
    ),
    z$3(e3, u2, f2);
}
function E$2(n3, l2) {
  D$2(n3, l2, E$2);
}
function G$2(l2, u2, t2) {
  var i3,
    r3,
    o2,
    e3,
    f2 = w$2({}, l2.props);
  for (o2 in (l2.type && l2.type.defaultProps && (e3 = l2.type.defaultProps),
  u2))
    "key" == o2
      ? (i3 = u2[o2])
      : "ref" == o2
        ? (r3 = u2[o2])
        : (f2[o2] = void 0 === u2[o2] && void 0 !== e3 ? e3[o2] : u2[o2]);
  return (
    arguments.length > 2 &&
      (f2.children = arguments.length > 3 ? n$a.call(arguments, 2) : t2),
    m$3(l2.type, f2, i3 || l2.key, r3 || l2.ref, null)
  );
}
function J$1(n3, l2) {
  var u2 = {
    __c: (l2 = "__cC" + h$5++),
    __: n3,
    Consumer: function (n4, l3) {
      return n4.children(l3);
    },
    Provider: function (n4) {
      var u3, t2;
      return (
        this.getChildContext ||
          ((u3 = /* @__PURE__ */ new Set()),
          ((t2 = {})[l2] = this),
          (this.getChildContext = function () {
            return t2;
          }),
          (this.componentWillUnmount = function () {
            u3 = null;
          }),
          (this.shouldComponentUpdate = function (n5) {
            this.props.value !== n5.value &&
              u3.forEach(function (n6) {
                (n6.__e = true), M$2(n6);
              });
          }),
          (this.sub = function (n5) {
            u3.add(n5);
            var l3 = n5.componentWillUnmount;
            n5.componentWillUnmount = function () {
              u3 && u3.delete(n5), l3 && l3.call(n5);
            };
          })),
        n4.children
      );
    },
  };
  return (u2.Provider.__ = u2.Consumer.contextType = u2);
}
(n$a = v$2.slice),
  (l$5 = {
    __e: function (n3, l2, u2, t2) {
      for (var i3, r3, o2; (l2 = l2.__); )
        if ((i3 = l2.__c) && !i3.__)
          try {
            if (
              ((r3 = i3.constructor) &&
                null != r3.getDerivedStateFromError &&
                (i3.setState(r3.getDerivedStateFromError(n3)), (o2 = i3.__d)),
              null != i3.componentDidCatch &&
                (i3.componentDidCatch(n3, t2 || {}), (o2 = i3.__d)),
              o2)
            )
              return (i3.__E = i3);
          } catch (l3) {
            n3 = l3;
          }
      throw n3;
    },
  }),
  (u$6 = 0),
  (x$3.prototype.setState = function (n3, l2) {
    var u2;
    (u2 =
      null != this.__s && this.__s !== this.state
        ? this.__s
        : (this.__s = w$2({}, this.state))),
      "function" == typeof n3 && (n3 = n3(w$2({}, u2), this.props)),
      n3 && w$2(u2, n3),
      null != n3 && this.__v && (l2 && this._sb.push(l2), M$2(this));
  }),
  (x$3.prototype.forceUpdate = function (n3) {
    this.__v && ((this.__e = true), n3 && this.__h.push(n3), M$2(this));
  }),
  (x$3.prototype.render = k$3),
  (i$9 = []),
  (o$e =
    "function" == typeof Promise
      ? Promise.prototype.then.bind(Promise.resolve())
      : setTimeout),
  (e$d = function (n3, l2) {
    return n3.__v.__b - l2.__v.__b;
  }),
  (P$3.__r = 0),
  (f$6 = /(PointerCapture)$|Capture$/i),
  (c$5 = 0),
  (s$4 = O$1(false)),
  (a$4 = O$1(true)),
  (h$5 = 0);
var f$5 = 0;
function u$5(e3, t2, n3, o2, i3, u2) {
  t2 || (t2 = {});
  var a2,
    c2,
    p2 = t2;
  if ("ref" in p2)
    for (c2 in ((p2 = {}), t2)) "ref" == c2 ? (a2 = t2[c2]) : (p2[c2] = t2[c2]);
  var l2 = {
    type: e3,
    props: p2,
    key: n3,
    ref: a2,
    __k: null,
    __: null,
    __b: 0,
    __e: null,
    __c: null,
    constructor: void 0,
    __v: --f$5,
    __i: -1,
    __u: 0,
    __source: i3,
    __self: u2,
  };
  if ("function" == typeof e3 && (a2 = e3.defaultProps))
    for (c2 in a2) void 0 === p2[c2] && (p2[c2] = a2[c2]);
  return l$5.vnode && l$5.vnode(l2), l2;
}
var basePath = "";
function setBasePath(path) {
  basePath = path;
}
function getBasePath(subpath = "") {
  if (!basePath) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find((script) =>
      script.hasAttribute("data-shoelace"),
    );
    if (configScript) {
      setBasePath(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find((s2) => {
        return (
          /shoelace(\.min)?\.js($|\?)/.test(s2.src) ||
          /shoelace-autoloader(\.min)?\.js($|\?)/.test(s2.src)
        );
      });
      let path = "";
      if (fallbackScript) {
        path = fallbackScript.getAttribute("src");
      }
      setBasePath(path.split("/").slice(0, -1).join("/"));
    }
  }
  return (
    basePath.replace(/\/$/, "") +
    (subpath ? `/${subpath.replace(/^\//, "")}` : ``)
  );
}
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) =>
  (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) =>
  key in obj
    ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value,
      })
    : (obj[key] = value);
var __spreadValues = (a2, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp.call(b3, prop)) __defNormalProp(a2, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop)) __defNormalProp(a2, prop, b3[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b3) => __defProps(a2, __getOwnPropDescs(b3));
var __decorateClass = (decorators, target, key, kind) => {
  var result =
    kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i3 = decorators.length - 1, decorator; i3 >= 0; i3--)
    if ((decorator = decorators[i3]))
      result =
        (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var __accessCheck2 = (obj, member, msg) =>
  member.has(obj) || __typeError2("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (
  __accessCheck2(obj, member, "read from private field"), member.get(obj)
);
var __privateAdd2 = (obj, member, value) =>
  member.has(obj)
    ? __typeError2("Cannot add the same private member more than once")
    : member instanceof WeakSet
      ? member.add(obj)
      : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (
  __accessCheck2(obj, member, "write to private field"),
  member.set(obj, value),
  value
);
var __await = function (promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")],
    isAwait = false,
    method,
    it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k3) => (it[k3] = (x2) => obj[k3](x2));
  } else {
    obj = obj.call(value);
    method = (k3) =>
      (it[k3] = (v2) => {
        if (isAwait) {
          isAwait = false;
          if (k3 === "throw") throw v2;
          return v2;
        }
        isAwait = true;
        return {
          done: false,
          value: new __await(
            new Promise((resolve) => {
              var x2 = obj[k3](v2);
              if (!(x2 instanceof Object)) __typeError2("Object expected");
              resolve(x2);
            }),
            1,
          ),
        };
      });
  }
  return (
    (it[__knownSymbol("iterator")] = () => it),
    method("next"),
    "throw" in obj
      ? method("throw")
      : (it.throw = (x2) => {
          throw x2;
        }),
    "return" in obj && method("return"),
    it
  );
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$5 = globalThis,
  e$c =
    t$5.ShadowRoot &&
    (void 0 === t$5.ShadyCSS || t$5.ShadyCSS.nativeShadow) &&
    "adoptedStyleSheets" in Document.prototype &&
    "replace" in CSSStyleSheet.prototype,
  s$3 = Symbol(),
  o$d = /* @__PURE__ */ new WeakMap();
let n$9 = class n {
  constructor(t2, e3, o2) {
    if (((this._$cssResult$ = true), o2 !== s$3))
      throw Error(
        "CSSResult is not constructable. Use `unsafeCSS` or `css` instead.",
      );
    (this.cssText = t2), (this.t = e3);
  }
  get styleSheet() {
    let t2 = this.o;
    const s2 = this.t;
    if (e$c && void 0 === t2) {
      const e3 = void 0 !== s2 && 1 === s2.length;
      e3 && (t2 = o$d.get(s2)),
        void 0 === t2 &&
          ((this.o = t2 = new CSSStyleSheet()).replaceSync(this.cssText),
          e3 && o$d.set(s2, t2));
    }
    return t2;
  }
  toString() {
    return this.cssText;
  }
};
const r$9 = (t2) => new n$9("string" == typeof t2 ? t2 : t2 + "", void 0, s$3),
  i$8 = (t2, ...e3) => {
    const o2 =
      1 === t2.length
        ? t2[0]
        : e3.reduce(
            (e4, s2, o3) =>
              e4 +
              ((t3) => {
                if (true === t3._$cssResult$) return t3.cssText;
                if ("number" == typeof t3) return t3;
                throw Error(
                  "Value passed to 'css' function must be a 'css' function result: " +
                    t3 +
                    ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.",
                );
              })(s2) +
              t2[o3 + 1],
            t2[0],
          );
    return new n$9(o2, t2, s$3);
  },
  S$1 = (s2, o2) => {
    if (e$c)
      s2.adoptedStyleSheets = o2.map((t2) =>
        t2 instanceof CSSStyleSheet ? t2 : t2.styleSheet,
      );
    else
      for (const e3 of o2) {
        const o3 = document.createElement("style"),
          n3 = t$5.litNonce;
        void 0 !== n3 && o3.setAttribute("nonce", n3),
          (o3.textContent = e3.cssText),
          s2.appendChild(o3);
      }
  },
  c$4 = e$c
    ? (t2) => t2
    : (t2) =>
        t2 instanceof CSSStyleSheet
          ? ((t3) => {
              let e3 = "";
              for (const s2 of t3.cssRules) e3 += s2.cssText;
              return r$9(e3);
            })(t2)
          : t2;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const {
    is: i$7,
    defineProperty: e$b,
    getOwnPropertyDescriptor: r$8,
    getOwnPropertyNames: h$4,
    getOwnPropertySymbols: o$c,
    getPrototypeOf: n$8,
  } = Object,
  a$3 = globalThis,
  c$3 = a$3.trustedTypes,
  l$4 = c$3 ? c$3.emptyScript : "",
  p$2 = a$3.reactiveElementPolyfillSupport,
  d$2 = (t2, s2) => t2,
  u$4 = {
    toAttribute(t2, s2) {
      switch (s2) {
        case Boolean:
          t2 = t2 ? l$4 : null;
          break;
        case Object:
        case Array:
          t2 = null == t2 ? t2 : JSON.stringify(t2);
      }
      return t2;
    },
    fromAttribute(t2, s2) {
      let i3 = t2;
      switch (s2) {
        case Boolean:
          i3 = null !== t2;
          break;
        case Number:
          i3 = null === t2 ? null : Number(t2);
          break;
        case Object:
        case Array:
          try {
            i3 = JSON.parse(t2);
          } catch (t3) {
            i3 = null;
          }
      }
      return i3;
    },
  },
  f$4 = (t2, s2) => !i$7(t2, s2),
  y$2 = {
    attribute: true,
    type: String,
    converter: u$4,
    reflect: false,
    hasChanged: f$4,
  };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")),
  a$3.litPropertyMetadata ??
    (a$3.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let b$1 = class b extends HTMLElement {
  static addInitializer(t2) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t2);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t2, s2 = y$2) {
    if (
      (s2.state && (s2.attribute = false),
      this._$Ei(),
      this.elementProperties.set(t2, s2),
      !s2.noAccessor)
    ) {
      const i3 = Symbol(),
        r3 = this.getPropertyDescriptor(t2, i3, s2);
      void 0 !== r3 && e$b(this.prototype, t2, r3);
    }
  }
  static getPropertyDescriptor(t2, s2, i3) {
    const { get: e3, set: h2 } = r$8(this.prototype, t2) ?? {
      get() {
        return this[s2];
      },
      set(t3) {
        this[s2] = t3;
      },
    };
    return {
      get() {
        return e3 == null ? void 0 : e3.call(this);
      },
      set(s3) {
        const r3 = e3 == null ? void 0 : e3.call(this);
        h2.call(this, s3), this.requestUpdate(t2, r3, i3);
      },
      configurable: true,
      enumerable: true,
    };
  }
  static getPropertyOptions(t2) {
    return this.elementProperties.get(t2) ?? y$2;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$2("elementProperties"))) return;
    const t2 = n$8(this);
    t2.finalize(),
      void 0 !== t2.l && (this.l = [...t2.l]),
      (this.elementProperties = new Map(t2.elementProperties));
  }
  static finalize() {
    if (this.hasOwnProperty(d$2("finalized"))) return;
    if (
      ((this.finalized = true),
      this._$Ei(),
      this.hasOwnProperty(d$2("properties")))
    ) {
      const t3 = this.properties,
        s2 = [...h$4(t3), ...o$c(t3)];
      for (const i3 of s2) this.createProperty(i3, t3[i3]);
    }
    const t2 = this[Symbol.metadata];
    if (null !== t2) {
      const s2 = litPropertyMetadata.get(t2);
      if (void 0 !== s2)
        for (const [t3, i3] of s2) this.elementProperties.set(t3, i3);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t3, s2] of this.elementProperties) {
      const i3 = this._$Eu(t3, s2);
      void 0 !== i3 && this._$Eh.set(i3, t3);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s2) {
    const i3 = [];
    if (Array.isArray(s2)) {
      const e3 = new Set(s2.flat(1 / 0).reverse());
      for (const s3 of e3) i3.unshift(c$4(s3));
    } else void 0 !== s2 && i3.push(c$4(s2));
    return i3;
  }
  static _$Eu(t2, s2) {
    const i3 = s2.attribute;
    return false === i3
      ? void 0
      : "string" == typeof i3
        ? i3
        : "string" == typeof t2
          ? t2.toLowerCase()
          : void 0;
  }
  constructor() {
    super(),
      (this._$Ep = void 0),
      (this.isUpdatePending = false),
      (this.hasUpdated = false),
      (this._$Em = null),
      this._$Ev();
  }
  _$Ev() {
    var _a2;
    (this._$ES = new Promise((t2) => (this.enableUpdating = t2))),
      (this._$AL = /* @__PURE__ */ new Map()),
      this._$E_(),
      this.requestUpdate(),
      (_a2 = this.constructor.l) == null
        ? void 0
        : _a2.forEach((t2) => t2(this));
  }
  addController(t2) {
    var _a2;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t2),
      void 0 !== this.renderRoot &&
        this.isConnected &&
        ((_a2 = t2.hostConnected) == null ? void 0 : _a2.call(t2));
  }
  removeController(t2) {
    var _a2;
    (_a2 = this._$EO) == null ? void 0 : _a2.delete(t2);
  }
  _$E_() {
    const t2 = /* @__PURE__ */ new Map(),
      s2 = this.constructor.elementProperties;
    for (const i3 of s2.keys())
      this.hasOwnProperty(i3) && (t2.set(i3, this[i3]), delete this[i3]);
    t2.size > 0 && (this._$Ep = t2);
  }
  createRenderRoot() {
    const t2 =
      this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$1(t2, this.constructor.elementStyles), t2;
  }
  connectedCallback() {
    var _a2;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
      this.enableUpdating(true),
      (_a2 = this._$EO) == null
        ? void 0
        : _a2.forEach((t2) => {
            var _a3;
            return (_a3 = t2.hostConnected) == null ? void 0 : _a3.call(t2);
          });
  }
  enableUpdating(t2) {}
  disconnectedCallback() {
    var _a2;
    (_a2 = this._$EO) == null
      ? void 0
      : _a2.forEach((t2) => {
          var _a3;
          return (_a3 = t2.hostDisconnected) == null ? void 0 : _a3.call(t2);
        });
  }
  attributeChangedCallback(t2, s2, i3) {
    this._$AK(t2, i3);
  }
  _$EC(t2, s2) {
    var _a2;
    const i3 = this.constructor.elementProperties.get(t2),
      e3 = this.constructor._$Eu(t2, i3);
    if (void 0 !== e3 && true === i3.reflect) {
      const r3 = (
        void 0 !== ((_a2 = i3.converter) == null ? void 0 : _a2.toAttribute)
          ? i3.converter
          : u$4
      ).toAttribute(s2, i3.type);
      (this._$Em = t2),
        null == r3 ? this.removeAttribute(e3) : this.setAttribute(e3, r3),
        (this._$Em = null);
    }
  }
  _$AK(t2, s2) {
    var _a2;
    const i3 = this.constructor,
      e3 = i3._$Eh.get(t2);
    if (void 0 !== e3 && this._$Em !== e3) {
      const t3 = i3.getPropertyOptions(e3),
        r3 =
          "function" == typeof t3.converter
            ? { fromAttribute: t3.converter }
            : void 0 !==
                ((_a2 = t3.converter) == null ? void 0 : _a2.fromAttribute)
              ? t3.converter
              : u$4;
      (this._$Em = e3),
        (this[e3] = r3.fromAttribute(s2, t3.type)),
        (this._$Em = null);
    }
  }
  requestUpdate(t2, s2, i3) {
    if (void 0 !== t2) {
      if (
        (i3 ?? (i3 = this.constructor.getPropertyOptions(t2)),
        !(i3.hasChanged ?? f$4)(this[t2], s2))
      )
        return;
      this.P(t2, s2, i3);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t2, s2, i3) {
    this._$AL.has(t2) || this._$AL.set(t2, s2),
      true === i3.reflect &&
        this._$Em !== t2 &&
        (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t2);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t3) {
      Promise.reject(t3);
    }
    const t2 = this.scheduleUpdate();
    return null != t2 && (await t2), !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var _a2;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (
        (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
        this._$Ep)
      ) {
        for (const [t4, s3] of this._$Ep) this[t4] = s3;
        this._$Ep = void 0;
      }
      const t3 = this.constructor.elementProperties;
      if (t3.size > 0)
        for (const [s3, i3] of t3)
          true !== i3.wrapped ||
            this._$AL.has(s3) ||
            void 0 === this[s3] ||
            this.P(s3, this[s3], i3);
    }
    let t2 = false;
    const s2 = this._$AL;
    try {
      (t2 = this.shouldUpdate(s2)),
        t2
          ? (this.willUpdate(s2),
            (_a2 = this._$EO) == null
              ? void 0
              : _a2.forEach((t3) => {
                  var _a3;
                  return (_a3 = t3.hostUpdate) == null ? void 0 : _a3.call(t3);
                }),
            this.update(s2))
          : this._$EU();
    } catch (s3) {
      throw ((t2 = false), this._$EU(), s3);
    }
    t2 && this._$AE(s2);
  }
  willUpdate(t2) {}
  _$AE(t2) {
    var _a2;
    (_a2 = this._$EO) == null
      ? void 0
      : _a2.forEach((t3) => {
          var _a3;
          return (_a3 = t3.hostUpdated) == null ? void 0 : _a3.call(t3);
        }),
      this.hasUpdated || ((this.hasUpdated = true), this.firstUpdated(t2)),
      this.updated(t2);
  }
  _$EU() {
    (this._$AL = /* @__PURE__ */ new Map()), (this.isUpdatePending = false);
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    this._$Ej &&
      (this._$Ej = this._$Ej.forEach((t3) => this._$EC(t3, this[t3]))),
      this._$EU();
  }
  updated(t2) {}
  firstUpdated(t2) {}
};
(b$1.elementStyles = []),
  (b$1.shadowRootOptions = { mode: "open" }),
  (b$1[d$2("elementProperties")] = /* @__PURE__ */ new Map()),
  (b$1[d$2("finalized")] = /* @__PURE__ */ new Map()),
  p$2 == null ? void 0 : p$2({ ReactiveElement: b$1 }),
  (a$3.reactiveElementVersions ?? (a$3.reactiveElementVersions = [])).push(
    "2.0.4",
  );
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$4 = globalThis,
  i$6 = t$4.trustedTypes,
  s$2 = i$6 ? i$6.createPolicy("lit-html", { createHTML: (t2) => t2 }) : void 0,
  e$a = "$lit$",
  h$3 = `lit$${Math.random().toFixed(9).slice(2)}$`,
  o$b = "?" + h$3,
  n$7 = `<${o$b}>`,
  r$7 = document,
  l$3 = () => r$7.createComment(""),
  c$2 = (t2) =>
    null === t2 || ("object" != typeof t2 && "function" != typeof t2),
  a$2 = Array.isArray,
  u$3 = (t2) =>
    a$2(t2) || "function" == typeof (t2 == null ? void 0 : t2[Symbol.iterator]),
  d$1 = "[ 	\n\f\r]",
  f$3 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
  v$1 = /-->/g,
  _$1 = />/g,
  m$2 = RegExp(
    `>|${d$1}(?:([^\\s"'>=/]+)(${d$1}*=${d$1}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
    "g",
  ),
  p$1 = /'/g,
  g$2 = /"/g,
  $$1 = /^(?:script|style|textarea|title)$/i,
  y$1 =
    (t2) =>
    (i3, ...s2) => ({ _$litType$: t2, strings: i3, values: s2 }),
  x$2 = y$1(1),
  T$2 = Symbol.for("lit-noChange"),
  E$1 = Symbol.for("lit-nothing"),
  A$2 = /* @__PURE__ */ new WeakMap(),
  C$2 = r$7.createTreeWalker(r$7, 129);
function P$2(t2, i3) {
  if (!a$2(t2) || !t2.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return void 0 !== s$2 ? s$2.createHTML(i3) : i3;
}
const V$1 = (t2, i3) => {
  const s2 = t2.length - 1,
    o2 = [];
  let r3,
    l2 = 2 === i3 ? "<svg>" : 3 === i3 ? "<math>" : "",
    c2 = f$3;
  for (let i4 = 0; i4 < s2; i4++) {
    const s3 = t2[i4];
    let a2,
      u2,
      d2 = -1,
      y2 = 0;
    for (
      ;
      y2 < s3.length && ((c2.lastIndex = y2), (u2 = c2.exec(s3)), null !== u2);

    )
      (y2 = c2.lastIndex),
        c2 === f$3
          ? "!--" === u2[1]
            ? (c2 = v$1)
            : void 0 !== u2[1]
              ? (c2 = _$1)
              : void 0 !== u2[2]
                ? ($$1.test(u2[2]) && (r3 = RegExp("</" + u2[2], "g")),
                  (c2 = m$2))
                : void 0 !== u2[3] && (c2 = m$2)
          : c2 === m$2
            ? ">" === u2[0]
              ? ((c2 = r3 ?? f$3), (d2 = -1))
              : void 0 === u2[1]
                ? (d2 = -2)
                : ((d2 = c2.lastIndex - u2[2].length),
                  (a2 = u2[1]),
                  (c2 = void 0 === u2[3] ? m$2 : '"' === u2[3] ? g$2 : p$1))
            : c2 === g$2 || c2 === p$1
              ? (c2 = m$2)
              : c2 === v$1 || c2 === _$1
                ? (c2 = f$3)
                : ((c2 = m$2), (r3 = void 0));
    const x2 = c2 === m$2 && t2[i4 + 1].startsWith("/>") ? " " : "";
    l2 +=
      c2 === f$3
        ? s3 + n$7
        : d2 >= 0
          ? (o2.push(a2), s3.slice(0, d2) + e$a + s3.slice(d2) + h$3 + x2)
          : s3 + h$3 + (-2 === d2 ? i4 : x2);
  }
  return [
    P$2(
      t2,
      l2 +
        (t2[s2] || "<?>") +
        (2 === i3 ? "</svg>" : 3 === i3 ? "</math>" : ""),
    ),
    o2,
  ];
};
let N$1 = class N {
  constructor({ strings: t2, _$litType$: s2 }, n3) {
    let r3;
    this.parts = [];
    let c2 = 0,
      a2 = 0;
    const u2 = t2.length - 1,
      d2 = this.parts,
      [f2, v2] = V$1(t2, s2);
    if (
      ((this.el = N.createElement(f2, n3)),
      (C$2.currentNode = this.el.content),
      2 === s2 || 3 === s2)
    ) {
      const t3 = this.el.content.firstChild;
      t3.replaceWith(...t3.childNodes);
    }
    for (; null !== (r3 = C$2.nextNode()) && d2.length < u2; ) {
      if (1 === r3.nodeType) {
        if (r3.hasAttributes())
          for (const t3 of r3.getAttributeNames())
            if (t3.endsWith(e$a)) {
              const i3 = v2[a2++],
                s3 = r3.getAttribute(t3).split(h$3),
                e3 = /([.?@])?(.*)/.exec(i3);
              d2.push({
                type: 1,
                index: c2,
                name: e3[2],
                strings: s3,
                ctor:
                  "." === e3[1]
                    ? H$2
                    : "?" === e3[1]
                      ? I$1
                      : "@" === e3[1]
                        ? L$1
                        : k$2,
              }),
                r3.removeAttribute(t3);
            } else
              t3.startsWith(h$3) &&
                (d2.push({ type: 6, index: c2 }), r3.removeAttribute(t3));
        if ($$1.test(r3.tagName)) {
          const t3 = r3.textContent.split(h$3),
            s3 = t3.length - 1;
          if (s3 > 0) {
            r3.textContent = i$6 ? i$6.emptyScript : "";
            for (let i3 = 0; i3 < s3; i3++)
              r3.append(t3[i3], l$3()),
                C$2.nextNode(),
                d2.push({ type: 2, index: ++c2 });
            r3.append(t3[s3], l$3());
          }
        }
      } else if (8 === r3.nodeType)
        if (r3.data === o$b) d2.push({ type: 2, index: c2 });
        else {
          let t3 = -1;
          for (; -1 !== (t3 = r3.data.indexOf(h$3, t3 + 1)); )
            d2.push({ type: 7, index: c2 }), (t3 += h$3.length - 1);
        }
      c2++;
    }
  }
  static createElement(t2, i3) {
    const s2 = r$7.createElement("template");
    return (s2.innerHTML = t2), s2;
  }
};
function S(t2, i3, s2 = t2, e3) {
  var _a2, _b2;
  if (i3 === T$2) return i3;
  let h2 =
    void 0 !== e3 ? ((_a2 = s2._$Co) == null ? void 0 : _a2[e3]) : s2._$Cl;
  const o2 = c$2(i3) ? void 0 : i3._$litDirective$;
  return (
    (h2 == null ? void 0 : h2.constructor) !== o2 &&
      ((_b2 = h2 == null ? void 0 : h2._$AO) == null
        ? void 0
        : _b2.call(h2, false),
      void 0 === o2 ? (h2 = void 0) : ((h2 = new o2(t2)), h2._$AT(t2, s2, e3)),
      void 0 !== e3 ? ((s2._$Co ?? (s2._$Co = []))[e3] = h2) : (s2._$Cl = h2)),
    void 0 !== h2 && (i3 = S(t2, h2._$AS(t2, i3.values), h2, e3)),
    i3
  );
}
let M$1 = class M {
  constructor(t2, i3) {
    (this._$AV = []), (this._$AN = void 0), (this._$AD = t2), (this._$AM = i3);
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t2) {
    const {
        el: { content: i3 },
        parts: s2,
      } = this._$AD,
      e3 = ((t2 == null ? void 0 : t2.creationScope) ?? r$7).importNode(
        i3,
        true,
      );
    C$2.currentNode = e3;
    let h2 = C$2.nextNode(),
      o2 = 0,
      n3 = 0,
      l2 = s2[0];
    for (; void 0 !== l2; ) {
      if (o2 === l2.index) {
        let i4;
        2 === l2.type
          ? (i4 = new R$1(h2, h2.nextSibling, this, t2))
          : 1 === l2.type
            ? (i4 = new l2.ctor(h2, l2.name, l2.strings, this, t2))
            : 6 === l2.type && (i4 = new z$2(h2, this, t2)),
          this._$AV.push(i4),
          (l2 = s2[++n3]);
      }
      o2 !== (l2 == null ? void 0 : l2.index) && ((h2 = C$2.nextNode()), o2++);
    }
    return (C$2.currentNode = r$7), e3;
  }
  p(t2) {
    let i3 = 0;
    for (const s2 of this._$AV)
      void 0 !== s2 &&
        (void 0 !== s2.strings
          ? (s2._$AI(t2, s2, i3), (i3 += s2.strings.length - 2))
          : s2._$AI(t2[i3])),
        i3++;
  }
};
let R$1 = class R {
  get _$AU() {
    var _a2;
    return ((_a2 = this._$AM) == null ? void 0 : _a2._$AU) ?? this._$Cv;
  }
  constructor(t2, i3, s2, e3) {
    (this.type = 2),
      (this._$AH = E$1),
      (this._$AN = void 0),
      (this._$AA = t2),
      (this._$AB = i3),
      (this._$AM = s2),
      (this.options = e3),
      (this._$Cv = (e3 == null ? void 0 : e3.isConnected) ?? true);
  }
  get parentNode() {
    let t2 = this._$AA.parentNode;
    const i3 = this._$AM;
    return (
      void 0 !== i3 &&
        11 === (t2 == null ? void 0 : t2.nodeType) &&
        (t2 = i3.parentNode),
      t2
    );
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t2, i3 = this) {
    (t2 = S(this, t2, i3)),
      c$2(t2)
        ? t2 === E$1 || null == t2 || "" === t2
          ? (this._$AH !== E$1 && this._$AR(), (this._$AH = E$1))
          : t2 !== this._$AH && t2 !== T$2 && this._(t2)
        : void 0 !== t2._$litType$
          ? this.$(t2)
          : void 0 !== t2.nodeType
            ? this.T(t2)
            : u$3(t2)
              ? this.k(t2)
              : this._(t2);
  }
  O(t2) {
    return this._$AA.parentNode.insertBefore(t2, this._$AB);
  }
  T(t2) {
    this._$AH !== t2 && (this._$AR(), (this._$AH = this.O(t2)));
  }
  _(t2) {
    this._$AH !== E$1 && c$2(this._$AH)
      ? (this._$AA.nextSibling.data = t2)
      : this.T(r$7.createTextNode(t2)),
      (this._$AH = t2);
  }
  $(t2) {
    var _a2;
    const { values: i3, _$litType$: s2 } = t2,
      e3 =
        "number" == typeof s2
          ? this._$AC(t2)
          : (void 0 === s2.el &&
              (s2.el = N$1.createElement(P$2(s2.h, s2.h[0]), this.options)),
            s2);
    if (((_a2 = this._$AH) == null ? void 0 : _a2._$AD) === e3) this._$AH.p(i3);
    else {
      const t3 = new M$1(e3, this),
        s3 = t3.u(this.options);
      t3.p(i3), this.T(s3), (this._$AH = t3);
    }
  }
  _$AC(t2) {
    let i3 = A$2.get(t2.strings);
    return void 0 === i3 && A$2.set(t2.strings, (i3 = new N$1(t2))), i3;
  }
  k(t2) {
    a$2(this._$AH) || ((this._$AH = []), this._$AR());
    const i3 = this._$AH;
    let s2,
      e3 = 0;
    for (const h2 of t2)
      e3 === i3.length
        ? i3.push(
            (s2 = new R(this.O(l$3()), this.O(l$3()), this, this.options)),
          )
        : (s2 = i3[e3]),
        s2._$AI(h2),
        e3++;
    e3 < i3.length &&
      (this._$AR(s2 && s2._$AB.nextSibling, e3), (i3.length = e3));
  }
  _$AR(t2 = this._$AA.nextSibling, i3) {
    var _a2;
    for (
      (_a2 = this._$AP) == null ? void 0 : _a2.call(this, false, true, i3);
      t2 && t2 !== this._$AB;

    ) {
      const i4 = t2.nextSibling;
      t2.remove(), (t2 = i4);
    }
  }
  setConnected(t2) {
    var _a2;
    void 0 === this._$AM &&
      ((this._$Cv = t2),
      (_a2 = this._$AP) == null ? void 0 : _a2.call(this, t2));
  }
};
let k$2 = class k {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t2, i3, s2, e3, h2) {
    (this.type = 1),
      (this._$AH = E$1),
      (this._$AN = void 0),
      (this.element = t2),
      (this.name = i3),
      (this._$AM = e3),
      (this.options = h2),
      s2.length > 2 || "" !== s2[0] || "" !== s2[1]
        ? ((this._$AH = Array(s2.length - 1).fill(new String())),
          (this.strings = s2))
        : (this._$AH = E$1);
  }
  _$AI(t2, i3 = this, s2, e3) {
    const h2 = this.strings;
    let o2 = false;
    if (void 0 === h2)
      (t2 = S(this, t2, i3, 0)),
        (o2 = !c$2(t2) || (t2 !== this._$AH && t2 !== T$2)),
        o2 && (this._$AH = t2);
    else {
      const e4 = t2;
      let n3, r3;
      for (t2 = h2[0], n3 = 0; n3 < h2.length - 1; n3++)
        (r3 = S(this, e4[s2 + n3], i3, n3)),
          r3 === T$2 && (r3 = this._$AH[n3]),
          o2 || (o2 = !c$2(r3) || r3 !== this._$AH[n3]),
          r3 === E$1
            ? (t2 = E$1)
            : t2 !== E$1 && (t2 += (r3 ?? "") + h2[n3 + 1]),
          (this._$AH[n3] = r3);
    }
    o2 && !e3 && this.j(t2);
  }
  j(t2) {
    t2 === E$1
      ? this.element.removeAttribute(this.name)
      : this.element.setAttribute(this.name, t2 ?? "");
  }
};
let H$2 = class H extends k$2 {
  constructor() {
    super(...arguments), (this.type = 3);
  }
  j(t2) {
    this.element[this.name] = t2 === E$1 ? void 0 : t2;
  }
};
let I$1 = class I extends k$2 {
  constructor() {
    super(...arguments), (this.type = 4);
  }
  j(t2) {
    this.element.toggleAttribute(this.name, !!t2 && t2 !== E$1);
  }
};
let L$1 = class L extends k$2 {
  constructor(t2, i3, s2, e3, h2) {
    super(t2, i3, s2, e3, h2), (this.type = 5);
  }
  _$AI(t2, i3 = this) {
    if ((t2 = S(this, t2, i3, 0) ?? E$1) === T$2) return;
    const s2 = this._$AH,
      e3 =
        (t2 === E$1 && s2 !== E$1) ||
        t2.capture !== s2.capture ||
        t2.once !== s2.once ||
        t2.passive !== s2.passive,
      h2 = t2 !== E$1 && (s2 === E$1 || e3);
    e3 && this.element.removeEventListener(this.name, this, s2),
      h2 && this.element.addEventListener(this.name, this, t2),
      (this._$AH = t2);
  }
  handleEvent(t2) {
    var _a2;
    "function" == typeof this._$AH
      ? this._$AH.call(
          ((_a2 = this.options) == null ? void 0 : _a2.host) ?? this.element,
          t2,
        )
      : this._$AH.handleEvent(t2);
  }
};
let z$2 = class z {
  constructor(t2, i3, s2) {
    (this.element = t2),
      (this.type = 6),
      (this._$AN = void 0),
      (this._$AM = i3),
      (this.options = s2);
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2) {
    S(this, t2);
  }
};
const j$2 = t$4.litHtmlPolyfillSupport;
j$2 == null ? void 0 : j$2(N$1, R$1),
  (t$4.litHtmlVersions ?? (t$4.litHtmlVersions = [])).push("3.2.1");
const B$2 = (t2, i3, s2) => {
  const e3 = (s2 == null ? void 0 : s2.renderBefore) ?? i3;
  let h2 = e3._$litPart$;
  if (void 0 === h2) {
    const t3 = (s2 == null ? void 0 : s2.renderBefore) ?? null;
    e3._$litPart$ = h2 = new R$1(
      i3.insertBefore(l$3(), t3),
      t3,
      void 0,
      s2 ?? {},
    );
  }
  return h2._$AI(t2), h2;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let r$6 = class r extends b$1 {
  constructor() {
    super(...arguments),
      (this.renderOptions = { host: this }),
      (this._$Do = void 0);
  }
  createRenderRoot() {
    var _a2;
    const t2 = super.createRenderRoot();
    return (
      (_a2 = this.renderOptions).renderBefore ??
        (_a2.renderBefore = t2.firstChild),
      t2
    );
  }
  update(t2) {
    const s2 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
      super.update(t2),
      (this._$Do = B$2(s2, this.renderRoot, this.renderOptions));
  }
  connectedCallback() {
    var _a2;
    super.connectedCallback(),
      (_a2 = this._$Do) == null ? void 0 : _a2.setConnected(true);
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback(),
      (_a2 = this._$Do) == null ? void 0 : _a2.setConnected(false);
  }
  render() {
    return T$2;
  }
};
(r$6._$litElement$ = true),
  (r$6["finalized"] = true),
  (_a = globalThis.litElementHydrateSupport) == null
    ? void 0
    : _a.call(globalThis, { LitElement: r$6 });
const i$5 = globalThis.litElementPolyfillSupport;
i$5 == null ? void 0 : i$5({ LitElement: r$6 });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push(
  "4.1.1",
);
var visually_hidden_styles_default = i$8`
  :host(:not(:focus-within)) {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    clip: rect(0 0 0 0) !important;
    clip-path: inset(50%) !important;
    border: none !important;
    overflow: hidden !important;
    white-space: nowrap !important;
    padding: 0 !important;
  }
`;
var component_styles_default = i$8`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$a = {
    attribute: true,
    type: String,
    converter: u$4,
    reflect: false,
    hasChanged: f$4,
  },
  r$5 = (t2 = o$a, e3, r3) => {
    const { kind: n3, metadata: i3 } = r3;
    let s2 = globalThis.litPropertyMetadata.get(i3);
    if (
      (void 0 === s2 &&
        globalThis.litPropertyMetadata.set(
          i3,
          (s2 = /* @__PURE__ */ new Map()),
        ),
      s2.set(r3.name, t2),
      "accessor" === n3)
    ) {
      const { name: o2 } = r3;
      return {
        set(r4) {
          const n4 = e3.get.call(this);
          e3.set.call(this, r4), this.requestUpdate(o2, n4, t2);
        },
        init(e4) {
          return void 0 !== e4 && this.P(o2, void 0, t2), e4;
        },
      };
    }
    if ("setter" === n3) {
      const { name: o2 } = r3;
      return function (r4) {
        const n4 = this[o2];
        e3.call(this, r4), this.requestUpdate(o2, n4, t2);
      };
    }
    throw Error("Unsupported decorator location: " + n3);
  };
function n$6(t2) {
  return (e3, o2) =>
    "object" == typeof o2
      ? r$5(t2, e3, o2)
      : ((t3, e4, o3) => {
          const r3 = e4.hasOwnProperty(o3);
          return (
            e4.constructor.createProperty(
              o3,
              r3 ? { ...t3, wrapped: true } : t3,
            ),
            r3 ? Object.getOwnPropertyDescriptor(e4, o3) : void 0
          );
        })(t2, e3, o2);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$4(r3) {
  return n$6({ ...r3, state: true, attribute: false });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function t$3(t2) {
  return (n3, o2) => {
    const c2 = "function" == typeof n3 ? n3 : n3[o2];
    Object.assign(c2, t2);
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$9 = (e3, t2, c2) => (
  (c2.configurable = true),
  (c2.enumerable = true),
  Reflect.decorate &&
    "object" != typeof t2 &&
    Object.defineProperty(e3, t2, c2),
  c2
);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function e$8(e3, r3) {
  return (n3, s2, i3) => {
    const o2 = (t2) => {
      var _a2;
      return (
        ((_a2 = t2.renderRoot) == null ? void 0 : _a2.querySelector(e3)) ?? null
      );
    };
    return e$9(n3, s2, {
      get() {
        return o2(this);
      },
    });
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$3(r3) {
  return (n3, e3) =>
    e$9(n3, e3, {
      async get() {
        var _a2;
        return (
          await this.updateComplete,
          ((_a2 = this.renderRoot) == null ? void 0 : _a2.querySelector(r3)) ??
            null
        );
      },
    });
}
var _hasRecordedInitialProperties;
var ShoelaceElement = class extends r$6 {
  constructor() {
    super();
    __privateAdd2(this, _hasRecordedInitialProperties, false);
    this.initialReflectedProperties = /* @__PURE__ */ new Map();
    Object.entries(this.constructor.dependencies).forEach(
      ([name, component]) => {
        this.constructor.define(name, component);
      },
    );
  }
  emit(name, options) {
    const event = new CustomEvent(
      name,
      __spreadValues(
        {
          bubbles: true,
          cancelable: false,
          composed: true,
          detail: {},
        },
        options,
      ),
    );
    this.dispatchEvent(event);
    return event;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      try {
        customElements.define(name, elementConstructor, options);
      } catch (_err) {
        customElements.define(
          name,
          class extends elementConstructor {},
          options,
        );
      }
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if (
      "version" in currentlyRegisteredConstructor &&
      currentlyRegisteredConstructor.version
    ) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(
      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`,
    );
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (!__privateGet2(this, _hasRecordedInitialProperties)) {
      this.constructor.elementProperties.forEach((obj, prop) => {
        if (obj.reflect && this[prop] != null) {
          this.initialReflectedProperties.set(prop, this[prop]);
        }
      });
      __privateSet2(this, _hasRecordedInitialProperties, true);
    }
    super.attributeChangedCallback(name, oldValue, newValue);
  }
  willUpdate(changedProperties) {
    super.willUpdate(changedProperties);
    this.initialReflectedProperties.forEach((value, prop) => {
      if (changedProperties.has(prop) && this[prop] == null) {
        this[prop] = value;
      }
    });
  }
};
_hasRecordedInitialProperties = /* @__PURE__ */ new WeakMap();
ShoelaceElement.version = "2.20.0";
ShoelaceElement.dependencies = {};
__decorateClass([n$6()], ShoelaceElement.prototype, "dir", 2);
__decorateClass([n$6()], ShoelaceElement.prototype, "lang", 2);
var SlVisuallyHidden = class extends ShoelaceElement {
  render() {
    return x$2` <slot></slot> `;
  }
};
SlVisuallyHidden.styles = [
  component_styles_default,
  visually_hidden_styles_default,
];
var t$2,
  r$2,
  u$2,
  i$4,
  o$9 = 0,
  f$2 = [],
  c$1 = l$5,
  e$7 = c$1.__b,
  a$1 = c$1.__r,
  v = c$1.diffed,
  l$2 = c$1.__c,
  m$1 = c$1.unmount,
  s$1 = c$1.__;
function d(n3, t2) {
  c$1.__h && c$1.__h(r$2, n3, o$9 || t2), (o$9 = 0);
  var u2 = r$2.__H || (r$2.__H = { __: [], __h: [] });
  return n3 >= u2.__.length && u2.__.push({}), u2.__[n3];
}
function h$2(n3) {
  return (o$9 = 1), p(D$1, n3);
}
function p(n3, u2, i3) {
  var o2 = d(t$2++, 2);
  if (
    ((o2.t = n3),
    !o2.__c &&
      ((o2.__ = [
        i3 ? i3(u2) : D$1(void 0, u2),
        function (n4) {
          var t2 = o2.__N ? o2.__N[0] : o2.__[0],
            r3 = o2.t(t2, n4);
          t2 !== r3 && ((o2.__N = [r3, o2.__[1]]), o2.__c.setState({}));
        },
      ]),
      (o2.__c = r$2),
      !r$2.u))
  ) {
    var f2 = function (n4, t2, r3) {
      if (!o2.__c.__H) return true;
      var u3 = o2.__c.__H.__.filter(function (n5) {
        return !!n5.__c;
      });
      if (
        u3.every(function (n5) {
          return !n5.__N;
        })
      )
        return !c2 || c2.call(this, n4, t2, r3);
      var i4 = o2.__c.props !== n4;
      return (
        u3.forEach(function (n5) {
          if (n5.__N) {
            var t3 = n5.__[0];
            (n5.__ = n5.__N), (n5.__N = void 0), t3 !== n5.__[0] && (i4 = true);
          }
        }),
        (c2 && c2.call(this, n4, t2, r3)) || i4
      );
    };
    r$2.u = true;
    var c2 = r$2.shouldComponentUpdate,
      e3 = r$2.componentWillUpdate;
    (r$2.componentWillUpdate = function (n4, t2, r3) {
      if (this.__e) {
        var u3 = c2;
        (c2 = void 0), f2(n4, t2, r3), (c2 = u3);
      }
      e3 && e3.call(this, n4, t2, r3);
    }),
      (r$2.shouldComponentUpdate = f2);
  }
  return o2.__N || o2.__;
}
function y(n3, u2) {
  var i3 = d(t$2++, 3);
  !c$1.__s &&
    C$1(i3.__H, u2) &&
    ((i3.__ = n3), (i3.i = u2), r$2.__H.__h.push(i3));
}
function _(n3, u2) {
  var i3 = d(t$2++, 4);
  !c$1.__s && C$1(i3.__H, u2) && ((i3.__ = n3), (i3.i = u2), r$2.__h.push(i3));
}
function A$1(n3) {
  return (
    (o$9 = 5),
    T$1(function () {
      return { current: n3 };
    }, [])
  );
}
function F$1(n3, t2, r3) {
  (o$9 = 6),
    _(
      function () {
        return "function" == typeof n3
          ? (n3(t2()),
            function () {
              return n3(null);
            })
          : n3
            ? ((n3.current = t2()),
              function () {
                return (n3.current = null);
              })
            : void 0;
      },
      null == r3 ? r3 : r3.concat(n3),
    );
}
function T$1(n3, r3) {
  var u2 = d(t$2++, 7);
  return (
    C$1(u2.__H, r3) && ((u2.__ = n3()), (u2.__H = r3), (u2.__h = n3)), u2.__
  );
}
function q$1(n3, t2) {
  return (
    (o$9 = 8),
    T$1(function () {
      return n3;
    }, t2)
  );
}
function x$1(n3) {
  var u2 = r$2.context[n3.__c],
    i3 = d(t$2++, 9);
  return (
    (i3.c = n3),
    u2
      ? (null == i3.__ && ((i3.__ = true), u2.sub(r$2)), u2.props.value)
      : n3.__
  );
}
function P$1(n3, t2) {
  c$1.useDebugValue && c$1.useDebugValue(t2 ? t2(n3) : n3);
}
function b2(n3) {
  var u2 = d(t$2++, 10),
    i3 = h$2();
  return (
    (u2.__ = n3),
    r$2.componentDidCatch ||
      (r$2.componentDidCatch = function (n4, t2) {
        u2.__ && u2.__(n4, t2), i3[1](n4);
      }),
    [
      i3[0],
      function () {
        i3[1](void 0);
      },
    ]
  );
}
function g$1() {
  var n3 = d(t$2++, 11);
  if (!n3.__) {
    for (var u2 = r$2.__v; null !== u2 && !u2.__m && null !== u2.__; )
      u2 = u2.__;
    var i3 = u2.__m || (u2.__m = [0, 0]);
    n3.__ = "P" + i3[0] + "-" + i3[1]++;
  }
  return n3.__;
}
function j$1() {
  for (var n3; (n3 = f$2.shift()); )
    if (n3.__P && n3.__H)
      try {
        n3.__H.__h.forEach(z$1), n3.__H.__h.forEach(B$1), (n3.__H.__h = []);
      } catch (t2) {
        (n3.__H.__h = []), c$1.__e(t2, n3.__v);
      }
}
(c$1.__b = function (n3) {
  (r$2 = null), e$7 && e$7(n3);
}),
  (c$1.__ = function (n3, t2) {
    n3 && t2.__k && t2.__k.__m && (n3.__m = t2.__k.__m), s$1 && s$1(n3, t2);
  }),
  (c$1.__r = function (n3) {
    a$1 && a$1(n3), (t$2 = 0);
    var i3 = (r$2 = n3.__c).__H;
    i3 &&
      (u$2 === r$2
        ? ((i3.__h = []),
          (r$2.__h = []),
          i3.__.forEach(function (n4) {
            n4.__N && (n4.__ = n4.__N), (n4.i = n4.__N = void 0);
          }))
        : (i3.__h.forEach(z$1), i3.__h.forEach(B$1), (i3.__h = []), (t$2 = 0))),
      (u$2 = r$2);
  }),
  (c$1.diffed = function (n3) {
    v && v(n3);
    var t2 = n3.__c;
    t2 &&
      t2.__H &&
      (t2.__H.__h.length &&
        ((1 !== f$2.push(t2) && i$4 === c$1.requestAnimationFrame) ||
          ((i$4 = c$1.requestAnimationFrame) || w$1)(j$1)),
      t2.__H.__.forEach(function (n4) {
        n4.i && (n4.__H = n4.i), (n4.i = void 0);
      })),
      (u$2 = r$2 = null);
  }),
  (c$1.__c = function (n3, t2) {
    t2.some(function (n4) {
      try {
        n4.__h.forEach(z$1),
          (n4.__h = n4.__h.filter(function (n5) {
            return !n5.__ || B$1(n5);
          }));
      } catch (r3) {
        t2.some(function (n5) {
          n5.__h && (n5.__h = []);
        }),
          (t2 = []),
          c$1.__e(r3, n4.__v);
      }
    }),
      l$2 && l$2(n3, t2);
  }),
  (c$1.unmount = function (n3) {
    m$1 && m$1(n3);
    var t2,
      r3 = n3.__c;
    r3 &&
      r3.__H &&
      (r3.__H.__.forEach(function (n4) {
        try {
          z$1(n4);
        } catch (n5) {
          t2 = n5;
        }
      }),
      (r3.__H = void 0),
      t2 && c$1.__e(t2, r3.__v));
  });
var k$1 = "function" == typeof requestAnimationFrame;
function w$1(n3) {
  var t2,
    r3 = function () {
      clearTimeout(u2), k$1 && cancelAnimationFrame(t2), setTimeout(n3);
    },
    u2 = setTimeout(r3, 100);
  k$1 && (t2 = requestAnimationFrame(r3));
}
function z$1(n3) {
  var t2 = r$2,
    u2 = n3.__c;
  "function" == typeof u2 && ((n3.__c = void 0), u2()), (r$2 = t2);
}
function B$1(n3) {
  var t2 = r$2;
  (n3.__c = n3.__()), (r$2 = t2);
}
function C$1(n3, t2) {
  return (
    !n3 ||
    n3.length !== t2.length ||
    t2.some(function (t3, r3) {
      return t3 !== n3[r3];
    })
  );
}
function D$1(n3, t2) {
  return "function" == typeof t2 ? t2(n3) : t2;
}
function g(n3, t2) {
  for (var e3 in t2) n3[e3] = t2[e3];
  return n3;
}
function E(n3, t2) {
  for (var e3 in n3) if ("__source" !== e3 && !(e3 in t2)) return true;
  for (var r3 in t2) if ("__source" !== r3 && n3[r3] !== t2[r3]) return true;
  return false;
}
function C(n3, t2) {
  var e3 = t2(),
    r3 = h$2({ t: { __: e3, u: t2 } }),
    u2 = r3[0].t,
    o2 = r3[1];
  return (
    _(
      function () {
        (u2.__ = e3), (u2.u = t2), x(u2) && o2({ t: u2 });
      },
      [n3, e3, t2],
    ),
    y(
      function () {
        return (
          x(u2) && o2({ t: u2 }),
          n3(function () {
            x(u2) && o2({ t: u2 });
          })
        );
      },
      [n3],
    ),
    e3
  );
}
function x(n3) {
  var t2,
    e3,
    r3 = n3.u,
    u2 = n3.__;
  try {
    var o2 = r3();
    return !(
      ((t2 = u2) === (e3 = o2) && (0 !== t2 || 1 / t2 == 1 / e3)) ||
      (t2 != t2 && e3 != e3)
    );
  } catch (n4) {
    return true;
  }
}
function R2(n3) {
  n3();
}
function w(n3) {
  return n3;
}
function k2() {
  return [false, R2];
}
var I2 = _;
function N2(n3, t2) {
  (this.props = n3), (this.context = t2);
}
function M2(n3, e3) {
  function r3(n4) {
    var t2 = this.props.ref,
      r4 = t2 == n4.ref;
    return (
      !r4 && t2 && (t2.call ? t2(null) : (t2.current = null)),
      e3 ? !e3(this.props, n4) || !r4 : E(this.props, n4)
    );
  }
  function u2(e4) {
    return (this.shouldComponentUpdate = r3), g$3(n3, e4);
  }
  return (
    (u2.displayName = "Memo(" + (n3.displayName || n3.name) + ")"),
    (u2.prototype.isReactComponent = true),
    (u2.__f = true),
    u2
  );
}
((N2.prototype = new x$3()).isPureReactComponent = true),
  (N2.prototype.shouldComponentUpdate = function (n3, t2) {
    return E(this.props, n3) || E(this.state, t2);
  });
var T = l$5.__b;
l$5.__b = function (n3) {
  n3.type &&
    n3.type.__f &&
    n3.ref &&
    ((n3.props.ref = n3.ref), (n3.ref = null)),
    T && T(n3);
};
var A =
  ("undefined" != typeof Symbol &&
    Symbol.for &&
    Symbol.for("react.forward_ref")) ||
  3911;
function D(n3) {
  function t2(t3) {
    var e3 = g({}, t3);
    return delete e3.ref, n3(e3, t3.ref || null);
  }
  return (
    (t2.$$typeof = A),
    (t2.render = t2),
    (t2.prototype.isReactComponent = t2.__f = true),
    (t2.displayName = "ForwardRef(" + (n3.displayName || n3.name) + ")"),
    t2
  );
}
var L2 = function (n3, t2) {
    return null == n3 ? null : H$3(H$3(n3).map(t2));
  },
  O = {
    map: L2,
    forEach: L2,
    count: function (n3) {
      return n3 ? H$3(n3).length : 0;
    },
    only: function (n3) {
      var t2 = H$3(n3);
      if (1 !== t2.length) throw "Children.only";
      return t2[0];
    },
    toArray: H$3,
  },
  F = l$5.__e;
l$5.__e = function (n3, t2, e3, r3) {
  if (n3.then) {
    for (var u2, o2 = t2; (o2 = o2.__); )
      if ((u2 = o2.__c) && u2.__c)
        return (
          null == t2.__e && ((t2.__e = e3.__e), (t2.__k = e3.__k)),
          u2.__c(n3, t2)
        );
  }
  F(n3, t2, e3, r3);
};
var U = l$5.unmount;
function V(n3, t2, e3) {
  return (
    n3 &&
      (n3.__c &&
        n3.__c.__H &&
        (n3.__c.__H.__.forEach(function (n4) {
          "function" == typeof n4.__c && n4.__c();
        }),
        (n3.__c.__H = null)),
      null != (n3 = g({}, n3)).__c &&
        (n3.__c.__P === e3 && (n3.__c.__P = t2), (n3.__c = null)),
      (n3.__k =
        n3.__k &&
        n3.__k.map(function (n4) {
          return V(n4, t2, e3);
        }))),
    n3
  );
}
function W(n3, t2, e3) {
  return (
    n3 &&
      e3 &&
      ((n3.__v = null),
      (n3.__k =
        n3.__k &&
        n3.__k.map(function (n4) {
          return W(n4, t2, e3);
        })),
      n3.__c &&
        n3.__c.__P === t2 &&
        (n3.__e && e3.appendChild(n3.__e),
        (n3.__c.__e = true),
        (n3.__c.__P = e3))),
    n3
  );
}
function P() {
  (this.__u = 0), (this.o = null), (this.__b = null);
}
function j(n3) {
  var t2 = n3.__.__c;
  return t2 && t2.__a && t2.__a(n3);
}
function z2(n3) {
  var e3, r3, u2;
  function o2(o3) {
    if (
      (e3 ||
        (e3 = n3()).then(
          function (n4) {
            r3 = n4.default || n4;
          },
          function (n4) {
            u2 = n4;
          },
        ),
      u2)
    )
      throw u2;
    if (!r3) throw e3;
    return g$3(r3, o3);
  }
  return (o2.displayName = "Lazy"), (o2.__f = true), o2;
}
function B() {
  (this.i = null), (this.l = null);
}
(l$5.unmount = function (n3) {
  var t2 = n3.__c;
  t2 && t2.__R && t2.__R(), t2 && 32 & n3.__u && (n3.type = null), U && U(n3);
}),
  ((P.prototype = new x$3()).__c = function (n3, t2) {
    var e3 = t2.__c,
      r3 = this;
    null == r3.o && (r3.o = []), r3.o.push(e3);
    var u2 = j(r3.__v),
      o2 = false,
      i3 = function () {
        o2 || ((o2 = true), (e3.__R = null), u2 ? u2(c2) : c2());
      };
    e3.__R = i3;
    var c2 = function () {
      if (!--r3.__u) {
        if (r3.state.__a) {
          var n4 = r3.state.__a;
          r3.__v.__k[0] = W(n4, n4.__c.__P, n4.__c.__O);
        }
        var t3;
        for (r3.setState({ __a: (r3.__b = null) }); (t3 = r3.o.pop()); )
          t3.forceUpdate();
      }
    };
    r3.__u++ || 32 & t2.__u || r3.setState({ __a: (r3.__b = r3.__v.__k[0]) }),
      n3.then(i3, i3);
  }),
  (P.prototype.componentWillUnmount = function () {
    this.o = [];
  }),
  (P.prototype.render = function (n3, e3) {
    if (this.__b) {
      if (this.__v.__k) {
        var r3 = document.createElement("div"),
          o2 = this.__v.__k[0].__c;
        this.__v.__k[0] = V(this.__b, r3, (o2.__O = o2.__P));
      }
      this.__b = null;
    }
    var i3 = e3.__a && g$3(k$3, null, n3.fallback);
    return (
      i3 && (i3.__u &= -33), [g$3(k$3, null, e3.__a ? null : n3.children), i3]
    );
  });
var H$1 = function (n3, t2, e3) {
  if (
    (++e3[1] === e3[0] && n3.l.delete(t2),
    n3.props.revealOrder && ("t" !== n3.props.revealOrder[0] || !n3.l.size))
  )
    for (e3 = n3.i; e3; ) {
      for (; e3.length > 3; ) e3.pop()();
      if (e3[1] < e3[0]) break;
      n3.i = e3 = e3[2];
    }
};
function Z(n3) {
  return (
    (this.getChildContext = function () {
      return n3.context;
    }),
    n3.children
  );
}
function Y(n3) {
  var e3 = this,
    r3 = n3.h;
  (e3.componentWillUnmount = function () {
    D$2(null, e3.v), (e3.v = null), (e3.h = null);
  }),
    e3.h && e3.h !== r3 && e3.componentWillUnmount(),
    e3.v ||
      ((e3.h = r3),
      (e3.v = {
        nodeType: 1,
        parentNode: r3,
        childNodes: [],
        contains: function () {
          return true;
        },
        appendChild: function (n4) {
          this.childNodes.push(n4), e3.h.appendChild(n4);
        },
        insertBefore: function (n4, t2) {
          this.childNodes.push(n4), e3.h.insertBefore(n4, t2);
        },
        removeChild: function (n4) {
          this.childNodes.splice(this.childNodes.indexOf(n4) >>> 1, 1),
            e3.h.removeChild(n4);
        },
      })),
    D$2(g$3(Z, { context: e3.context }, n3.__v), e3.v);
}
function $(n3, e3) {
  var r3 = g$3(Y, { __v: n3, h: e3 });
  return (r3.containerInfo = e3), r3;
}
((B.prototype = new x$3()).__a = function (n3) {
  var t2 = this,
    e3 = j(t2.__v),
    r3 = t2.l.get(n3);
  return (
    r3[0]++,
    function (u2) {
      var o2 = function () {
        t2.props.revealOrder ? (r3.push(u2), H$1(t2, n3, r3)) : u2();
      };
      e3 ? e3(o2) : o2();
    }
  );
}),
  (B.prototype.render = function (n3) {
    (this.i = null), (this.l = /* @__PURE__ */ new Map());
    var t2 = H$3(n3.children);
    n3.revealOrder && "b" === n3.revealOrder[0] && t2.reverse();
    for (var e3 = t2.length; e3--; )
      this.l.set(t2[e3], (this.i = [1, 0, this.i]));
    return n3.children;
  }),
  (B.prototype.componentDidUpdate = B.prototype.componentDidMount =
    function () {
      var n3 = this;
      this.l.forEach(function (t2, e3) {
        H$1(n3, e3, t2);
      });
    });
var q =
    ("undefined" != typeof Symbol &&
      Symbol.for &&
      Symbol.for("react.element")) ||
    60103,
  G$1 =
    /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
  J = /^on(Ani|Tra|Tou|BeforeInp|Compo)/,
  K = /[A-Z0-9]/g,
  Q = "undefined" != typeof document,
  X = function (n3) {
    return (
      "undefined" != typeof Symbol && "symbol" == typeof Symbol()
        ? /fil|che|rad/
        : /fil|che|ra/
    ).test(n3);
  };
function nn(n3, t2, e3) {
  return (
    null == t2.__k && (t2.textContent = ""),
    D$2(n3, t2),
    "function" == typeof e3 && e3(),
    n3 ? n3.__c : null
  );
}
function tn(n3, t2, e3) {
  return E$2(n3, t2), "function" == typeof e3 && e3(), n3 ? n3.__c : null;
}
(x$3.prototype.isReactComponent = {}),
  [
    "componentWillMount",
    "componentWillReceiveProps",
    "componentWillUpdate",
  ].forEach(function (t2) {
    Object.defineProperty(x$3.prototype, t2, {
      configurable: true,
      get: function () {
        return this["UNSAFE_" + t2];
      },
      set: function (n3) {
        Object.defineProperty(this, t2, {
          configurable: true,
          writable: true,
          value: n3,
        });
      },
    });
  });
var en = l$5.event;
function rn() {}
function un() {
  return this.cancelBubble;
}
function on() {
  return this.defaultPrevented;
}
l$5.event = function (n3) {
  return (
    en && (n3 = en(n3)),
    (n3.persist = rn),
    (n3.isPropagationStopped = un),
    (n3.isDefaultPrevented = on),
    (n3.nativeEvent = n3)
  );
};
var cn,
  ln = {
    enumerable: false,
    configurable: true,
    get: function () {
      return this.class;
    },
  },
  fn = l$5.vnode;
l$5.vnode = function (n3) {
  "string" == typeof n3.type &&
    (function (n4) {
      var t2 = n4.props,
        e3 = n4.type,
        u2 = {},
        o2 = -1 === e3.indexOf("-");
      for (var i3 in t2) {
        var c2 = t2[i3];
        if (
          !(
            ("value" === i3 && "defaultValue" in t2 && null == c2) ||
            (Q && "children" === i3 && "noscript" === e3) ||
            "class" === i3 ||
            "className" === i3
          )
        ) {
          var l2 = i3.toLowerCase();
          "defaultValue" === i3 && "value" in t2 && null == t2.value
            ? (i3 = "value")
            : "download" === i3 && true === c2
              ? (c2 = "")
              : "translate" === l2 && "no" === c2
                ? (c2 = false)
                : "o" === l2[0] && "n" === l2[1]
                  ? "ondoubleclick" === l2
                    ? (i3 = "ondblclick")
                    : "onchange" !== l2 ||
                        ("input" !== e3 && "textarea" !== e3) ||
                        X(t2.type)
                      ? "onfocus" === l2
                        ? (i3 = "onfocusin")
                        : "onblur" === l2
                          ? (i3 = "onfocusout")
                          : J.test(i3) && (i3 = l2)
                      : (l2 = i3 = "oninput")
                  : o2 && G$1.test(i3)
                    ? (i3 = i3.replace(K, "-$&").toLowerCase())
                    : null === c2 && (c2 = void 0),
            "oninput" === l2 && u2[(i3 = l2)] && (i3 = "oninputCapture"),
            (u2[i3] = c2);
        }
      }
      "select" == e3 &&
        u2.multiple &&
        Array.isArray(u2.value) &&
        (u2.value = H$3(t2.children).forEach(function (n5) {
          n5.props.selected = -1 != u2.value.indexOf(n5.props.value);
        })),
        "select" == e3 &&
          null != u2.defaultValue &&
          (u2.value = H$3(t2.children).forEach(function (n5) {
            n5.props.selected = u2.multiple
              ? -1 != u2.defaultValue.indexOf(n5.props.value)
              : u2.defaultValue == n5.props.value;
          })),
        t2.class && !t2.className
          ? ((u2.class = t2.class), Object.defineProperty(u2, "className", ln))
          : ((t2.className && !t2.class) || (t2.class && t2.className)) &&
            (u2.class = u2.className = t2.className),
        (n4.props = u2);
    })(n3),
    (n3.$$typeof = q),
    fn && fn(n3);
};
var an = l$5.__r;
l$5.__r = function (n3) {
  an && an(n3), (cn = n3.__c);
};
var sn = l$5.diffed;
l$5.diffed = function (n3) {
  sn && sn(n3);
  var t2 = n3.props,
    e3 = n3.__e;
  null != e3 &&
    "textarea" === n3.type &&
    "value" in t2 &&
    t2.value !== e3.value &&
    (e3.value = null == t2.value ? "" : t2.value),
    (cn = null);
};
var hn = {
    ReactCurrentDispatcher: {
      current: {
        readContext: function (n3) {
          return cn.__n[n3.__c].props.value;
        },
        useCallback: q$1,
        useContext: x$1,
        useDebugValue: P$1,
        useDeferredValue: w,
        useEffect: y,
        useId: g$1,
        useImperativeHandle: F$1,
        useInsertionEffect: I2,
        useLayoutEffect: _,
        useMemo: T$1,
        useReducer: p,
        useRef: A$1,
        useState: h$2,
        useSyncExternalStore: C,
        useTransition: k2,
      },
    },
  },
  vn = "18.3.1";
function dn(n3) {
  return g$3.bind(null, n3);
}
function pn(n3) {
  return !!n3 && n3.$$typeof === q;
}
function mn(n3) {
  return pn(n3) && n3.type === k$3;
}
function yn(n3) {
  return (
    !!n3 &&
    !!n3.displayName &&
    ("string" == typeof n3.displayName || n3.displayName instanceof String) &&
    n3.displayName.startsWith("Memo(")
  );
}
function _n(n3) {
  return pn(n3) ? G$2.apply(null, arguments) : n3;
}
function bn(n3) {
  return !!n3.__k && (D$2(null, n3), true);
}
function Sn(n3) {
  return (n3 && (n3.base || (1 === n3.nodeType && n3))) || null;
}
var gn = function (n3, t2) {
    return n3(t2);
  },
  En = function (n3, t2) {
    return n3(t2);
  },
  Cn = k$3,
  xn = pn,
  Rn = {
    useState: h$2,
    useId: g$1,
    useReducer: p,
    useEffect: y,
    useLayoutEffect: _,
    useInsertionEffect: I2,
    useTransition: k2,
    useDeferredValue: w,
    useSyncExternalStore: C,
    startTransition: R2,
    useRef: A$1,
    useImperativeHandle: F$1,
    useMemo: T$1,
    useCallback: q$1,
    useContext: x$1,
    useDebugValue: P$1,
    version: "18.3.1",
    Children: O,
    render: nn,
    hydrate: tn,
    unmountComponentAtNode: bn,
    createPortal: $,
    createElement: g$3,
    createContext: J$1,
    createFactory: dn,
    cloneElement: _n,
    createRef: b$2,
    Fragment: k$3,
    isValidElement: pn,
    isElement: xn,
    isFragment: mn,
    isMemo: yn,
    findDOMNode: Sn,
    Component: x$3,
    PureComponent: N2,
    memo: M2,
    forwardRef: D,
    flushSync: En,
    unstable_batchedUpdates: gn,
    StrictMode: Cn,
    Suspense: P,
    SuspenseList: B,
    lazy: z2,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: hn,
  };
const React = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      Children: O,
      Component: x$3,
      Fragment: k$3,
      PureComponent: N2,
      StrictMode: Cn,
      Suspense: P,
      SuspenseList: B,
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: hn,
      cloneElement: _n,
      createContext: J$1,
      createElement: g$3,
      createFactory: dn,
      createPortal: $,
      createRef: b$2,
      default: Rn,
      findDOMNode: Sn,
      flushSync: En,
      forwardRef: D,
      hydrate: tn,
      isElement: xn,
      isFragment: mn,
      isMemo: yn,
      isValidElement: pn,
      lazy: z2,
      memo: M2,
      render: nn,
      startTransition: R2,
      unmountComponentAtNode: bn,
      unstable_batchedUpdates: gn,
      useCallback: q$1,
      useContext: x$1,
      useDebugValue: P$1,
      useDeferredValue: w,
      useEffect: y,
      useErrorBoundary: b2,
      useId: g$1,
      useImperativeHandle: F$1,
      useInsertionEffect: I2,
      useLayoutEffect: _,
      useMemo: T$1,
      useReducer: p,
      useRef: A$1,
      useState: h$2,
      useSyncExternalStore: C,
      useTransition: k2,
      version: vn,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$6 = /* @__PURE__ */ new Set([
    "children",
    "localName",
    "ref",
    "style",
    "className",
  ]),
  n$5 = /* @__PURE__ */ new WeakMap(),
  t$1 = (e3, t2, o2, l2, a2) => {
    const s2 = a2 == null ? void 0 : a2[t2];
    void 0 === s2
      ? ((e3[t2] = o2),
        null == o2 && t2 in HTMLElement.prototype && e3.removeAttribute(t2))
      : o2 !== l2 &&
        ((e4, t3, o3) => {
          let l3 = n$5.get(e4);
          void 0 === l3 && n$5.set(e4, (l3 = /* @__PURE__ */ new Map()));
          let a3 = l3.get(t3);
          void 0 !== o3
            ? void 0 === a3
              ? (l3.set(t3, (a3 = { handleEvent: o3 })),
                e4.addEventListener(t3, a3))
              : (a3.handleEvent = o3)
            : void 0 !== a3 && (l3.delete(t3), e4.removeEventListener(t3, a3));
        })(e3, s2, o2);
  },
  o$8 = ({
    react: n3,
    tagName: o2,
    elementClass: l2,
    events: a2,
    displayName: s2,
  }) => {
    const c2 = new Set(Object.keys(a2 ?? {})),
      r3 = n3.forwardRef((s3, r4) => {
        const i3 = n3.useRef(/* @__PURE__ */ new Map()),
          d2 = n3.useRef(null),
          f2 = {},
          u2 = {};
        for (const [n4, t2] of Object.entries(s3))
          e$6.has(n4)
            ? (f2["className" === n4 ? "class" : n4] = t2)
            : c2.has(n4) || n4 in l2.prototype
              ? (u2[n4] = t2)
              : (f2[n4] = t2);
        return (
          n3.useLayoutEffect(() => {
            if (null === d2.current) return;
            const e3 = /* @__PURE__ */ new Map();
            for (const n4 in u2)
              t$1(d2.current, n4, s3[n4], i3.current.get(n4), a2),
                i3.current.delete(n4),
                e3.set(n4, s3[n4]);
            for (const [e4, n4] of i3.current)
              t$1(d2.current, e4, void 0, n4, a2);
            i3.current = e3;
          }),
          n3.useLayoutEffect(() => {
            var _a2;
            (_a2 = d2.current) == null
              ? void 0
              : _a2.removeAttribute("defer-hydration");
          }, []),
          (f2.suppressHydrationWarning = true),
          n3.createElement(o2, {
            ...f2,
            ref: n3.useCallback(
              (e3) => {
                (d2.current = e3),
                  "function" == typeof r4
                    ? r4(e3)
                    : null !== r4 && (r4.current = e3);
              },
              [r4],
            ),
          })
        );
      });
    return (r3.displayName = s2 ?? l2.name), r3;
  };
var tagName$V = "sl-visually-hidden";
SlVisuallyHidden.define("sl-visually-hidden");
o$8({
  tagName: tagName$V,
  elementClass: SlVisuallyHidden,
  react: React,
  events: {},
  displayName: "SlVisuallyHidden",
});
var switch_styles_default = i$8`
  :host {
    display: inline-block;
  }

  :host([size='small']) {
    --height: var(--sl-toggle-size-small);
    --thumb-size: calc(var(--sl-toggle-size-small) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-small);
  }

  :host([size='medium']) {
    --height: var(--sl-toggle-size-medium);
    --thumb-size: calc(var(--sl-toggle-size-medium) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-medium);
  }

  :host([size='large']) {
    --height: var(--sl-toggle-size-large);
    --thumb-size: calc(var(--sl-toggle-size-large) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-large);
  }

  .switch {
    position: relative;
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-input-font-family);
    font-size: inherit;
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .switch__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--width);
    height: var(--height);
    background-color: var(--sl-color-neutral-400);
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    border-radius: var(--height);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color;
  }

  .switch__control .switch__thumb {
    width: var(--thumb-size);
    height: var(--thumb-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: 50%;
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    translate: calc((var(--width) - var(--height)) / -2);
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) box-shadow;
  }

  .switch__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-400);
  }

  /* Focus */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked */
  .switch--checked .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch--checked .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    translate: calc((var(--width) - var(--height)) / 2);
  }

  /* Checked + hover */
  .switch.switch--checked:not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
  }

  /* Checked + focus */
  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .switch--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .switch__label {
    display: inline-block;
    line-height: var(--height);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .switch__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  @media (forced-colors: active) {
    .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb,
    .switch--checked .switch__control .switch__thumb {
      background-color: ButtonText;
    }
  }
`;
var defaultValue =
  (propertyName = "value") =>
  (proto, key) => {
    const ctor = proto.constructor;
    const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
    ctor.prototype.attributeChangedCallback = function (name, old, value) {
      var _a2;
      const options = ctor.getPropertyOptions(propertyName);
      const attributeName =
        typeof options.attribute === "string"
          ? options.attribute
          : propertyName;
      if (name === attributeName) {
        const converter = options.converter || u$4;
        const fromAttribute =
          typeof converter === "function"
            ? converter
            : (_a2 = converter == null ? void 0 : converter.fromAttribute) !=
                null
              ? _a2
              : u$4.fromAttribute;
        const newValue = fromAttribute(value, options.type);
        if (this[propertyName] !== newValue) {
          this[key] = newValue;
        }
      }
      attributeChangedCallback.call(this, name, old, value);
    };
  };
var form_control_styles_default = i$8`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;
var formCollections = /* @__PURE__ */ new WeakMap();
var reportValidityOverloads = /* @__PURE__ */ new WeakMap();
var checkValidityOverloads = /* @__PURE__ */ new WeakMap();
var userInteractedControls = /* @__PURE__ */ new WeakSet();
var interactions = /* @__PURE__ */ new WeakMap();
var FormControlController = class {
  constructor(host, options) {
    this.handleFormData = (event) => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (
        this.host.isConnected &&
        !disabled &&
        !isButton &&
        typeof name === "string" &&
        name.length > 0 &&
        typeof value !== "undefined"
      ) {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            event.formData.append(name, val.toString());
          });
        } else {
          event.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = (event) => {
      var _a2;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a2 = formCollections.get(this.form)) == null
          ? void 0
          : _a2.forEach((control) => {
              this.setUserInteracted(control, true);
            });
      }
      if (
        this.form &&
        !this.form.noValidate &&
        !disabled &&
        !reportValidity(this.host)
      ) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions.set(this.host, []);
    };
    this.handleInteraction = (event) => {
      const emittedEvents = interactions.get(this.host);
      if (!emittedEvents.includes(event.type)) {
        emittedEvents.push(event.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.checkValidity === "function") {
            if (!element.checkValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues(
      {
        form: (input) => {
          const formId = input.form;
          if (formId) {
            const root = input.getRootNode();
            const form = root.querySelector(`#${formId}`);
            if (form) {
              return form;
            }
          }
          return input.closest("form");
        },
        name: (input) => input.name,
        value: (input) => input.value,
        defaultValue: (input) => input.defaultValue,
        disabled: (input) => {
          var _a2;
          return (_a2 = input.disabled) != null ? _a2 : false;
        },
        reportValidity: (input) =>
          typeof input.reportValidity === "function"
            ? input.reportValidity()
            : true,
        checkValidity: (input) =>
          typeof input.checkValidity === "function"
            ? input.checkValidity()
            : true,
        setValue: (input, value) => (input.value = value),
        assumeInteractionOn: ["sl-input"],
      },
      options,
    );
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions.set(this.host, []);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.addEventListener(event, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions.delete(this.host);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.removeEventListener(event, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections.has(this.form)) {
        formCollections.get(this.form).add(this.host);
      } else {
        formCollections.set(this.form, /* @__PURE__ */ new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads.has(this.form)) {
        reportValidityOverloads.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
      if (!checkValidityOverloads.has(this.form)) {
        checkValidityOverloads.set(this.form, this.form.checkValidity);
        this.form.checkValidity = () => this.checkFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    if (!this.form) return;
    const formCollection = formCollections.get(this.form);
    if (!formCollection) {
      return;
    }
    formCollection.delete(this.host);
    if (formCollection.size <= 0) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads.get(this.form);
        reportValidityOverloads.delete(this.form);
      }
      if (checkValidityOverloads.has(this.form)) {
        this.form.checkValidity = checkValidityOverloads.get(this.form);
        checkValidityOverloads.delete(this.form);
      }
      this.form = void 0;
    }
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls.add(el);
    } else {
      userInteractedControls.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        [
          "formaction",
          "formenctype",
          "formmethod",
          "formnovalidate",
          "formtarget",
        ].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a2;
    return (_a2 = this.form) != null ? _a2 : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid);
    host.toggleAttribute("data-valid", isValid);
    host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {},
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null
        ? void 0
        : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false,
});
var valueMissingValidityState = Object.freeze(
  __spreadProps(__spreadValues({}, validValidityState), {
    valid: false,
    valueMissing: true,
  }),
);
var customErrorValidityState = Object.freeze(
  __spreadProps(__spreadValues({}, validValidityState), {
    valid: false,
    customError: true,
  }),
);
var HasSlotController = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = (event) => {
      const slot = event.target;
      if (
        (this.slotNames.includes("[default]") && !slot.name) ||
        (slot.name && this.slotNames.includes(slot.name))
      ) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName2 = el.tagName.toLowerCase();
        if (tagName2 === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]"
      ? this.hasDefaultSlot()
      : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener(
      "slotchange",
      this.handleSlotChange,
    );
  }
};
function getTextContent(slot) {
  if (!slot) {
    return "";
  }
  const nodes = slot.assignedNodes({ flatten: true });
  let text = "";
  [...nodes].forEach((node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      text += node.textContent;
    }
  });
  return text;
}
function watch(propertyName, options) {
  const resolvedOptions = __spreadValues(
    {
      waitUntilFirstUpdate: false,
    },
    options,
  );
  return (proto, decoratedFnName) => {
    const { update: update2 } = proto;
    const watchedProperties = Array.isArray(propertyName)
      ? propertyName
      : [propertyName];
    proto.update = function (changedProps) {
      watchedProperties.forEach((property) => {
        const key = property;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update2.call(this, changedProps);
    };
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4 },
  e$5 =
    (t2) =>
    (...e3) => ({ _$litDirective$: t2, values: e3 });
let i$3 = class i {
  constructor(t2) {}
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t2, e3, i3) {
    (this._$Ct = t2), (this._$AM = e3), (this._$Ci = i3);
  }
  _$AS(t2, e3) {
    return this.update(t2, e3);
  }
  update(t2, e3) {
    return this.render(...e3);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$4 = e$5(
  class extends i$3 {
    constructor(t$12) {
      var _a2;
      if (
        (super(t$12),
        t$12.type !== t.ATTRIBUTE ||
          "class" !== t$12.name ||
          ((_a2 = t$12.strings) == null ? void 0 : _a2.length) > 2)
      )
        throw Error(
          "`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.",
        );
    }
    render(t2) {
      return (
        " " +
        Object.keys(t2)
          .filter((s2) => t2[s2])
          .join(" ") +
        " "
      );
    }
    update(s2, [i3]) {
      var _a2, _b2;
      if (void 0 === this.st) {
        (this.st = /* @__PURE__ */ new Set()),
          void 0 !== s2.strings &&
            (this.nt = new Set(
              s2.strings
                .join(" ")
                .split(/\s/)
                .filter((t2) => "" !== t2),
            ));
        for (const t2 in i3)
          i3[t2] &&
            !((_a2 = this.nt) == null ? void 0 : _a2.has(t2)) &&
            this.st.add(t2);
        return this.render(i3);
      }
      const r3 = s2.element.classList;
      for (const t2 of this.st) t2 in i3 || (r3.remove(t2), this.st.delete(t2));
      for (const t2 in i3) {
        const s3 = !!i3[t2];
        s3 === this.st.has(t2) ||
          ((_b2 = this.nt) == null ? void 0 : _b2.has(t2)) ||
          (s3
            ? (r3.add(t2), this.st.add(t2))
            : (r3.remove(t2), this.st.delete(t2)));
      }
      return T$2;
    }
  },
);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$7 = (o2) => o2 ?? E$1;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$3 = (o2, t2) => void 0 !== (o2 == null ? void 0 : o2._$litType$),
  f$1 = (o2) => void 0 === o2.strings,
  u$1 = {},
  m = (o2, t2 = u$1) => (o2._$AH = t2);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const l$1 = e$5(
  class extends i$3 {
    constructor(r3) {
      if (
        (super(r3),
        r3.type !== t.PROPERTY &&
          r3.type !== t.ATTRIBUTE &&
          r3.type !== t.BOOLEAN_ATTRIBUTE)
      )
        throw Error(
          "The `live` directive is not allowed on child or event bindings",
        );
      if (!f$1(r3))
        throw Error("`live` bindings can only contain a single expression");
    }
    render(r3) {
      return r3;
    }
    update(i3, [t$12]) {
      if (t$12 === T$2 || t$12 === E$1) return t$12;
      const o2 = i3.element,
        l2 = i3.name;
      if (i3.type === t.PROPERTY) {
        if (t$12 === o2[l2]) return T$2;
      } else if (i3.type === t.BOOLEAN_ATTRIBUTE) {
        if (!!t$12 === o2.hasAttribute(l2)) return T$2;
      } else if (i3.type === t.ATTRIBUTE && o2.getAttribute(l2) === t$12 + "")
        return T$2;
      return m(i3), t$12;
    }
  },
);
var SlSwitch = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      value: (control) => (control.checked ? control.value || "on" : void 0),
      defaultValue: (control) => control.defaultChecked,
      setValue: (control, checked) => (control.checked = checked),
    });
    this.hasSlotController = new HasSlotController(this, "help-text");
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.size = "medium";
    this.disabled = false;
    this.checked = false;
    this.defaultChecked = false;
    this.form = "";
    this.required = false;
    this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleClick() {
    this.checked = !this.checked;
    this.emit("sl-change");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleKeyDown(event) {
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.checked = false;
      this.emit("sl-change");
      this.emit("sl-input");
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.checked = true;
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleCheckedChange() {
    this.input.checked = this.checked;
    this.formControlController.updateValidity();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(true);
  }
  /** Simulates a click on the switch. */
  click() {
    this.input.click();
  }
  /** Sets focus on the switch. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the switch. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return x$2`
      <div
        class=${e$4({
          "form-control": true,
          "form-control--small": this.size === "small",
          "form-control--medium": this.size === "medium",
          "form-control--large": this.size === "large",
          "form-control--has-help-text": hasHelpText,
        })}
      >
        <label
          part="base"
          class=${e$4({
            switch: true,
            "switch--checked": this.checked,
            "switch--disabled": this.disabled,
            "switch--focused": this.hasFocus,
            "switch--small": this.size === "small",
            "switch--medium": this.size === "medium",
            "switch--large": this.size === "large",
          })}
        >
          <input
            class="switch__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${o$7(this.value)}
            .checked=${l$1(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            role="switch"
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
            @keydown=${this.handleKeyDown}
          />

          <span part="control" class="switch__control">
            <span part="thumb" class="switch__thumb"></span>
          </span>

          <div part="label" class="switch__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${hasHelpText ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSwitch.styles = [
  component_styles_default,
  form_control_styles_default,
  switch_styles_default,
];
__decorateClass(
  [e$8('input[type="checkbox"]')],
  SlSwitch.prototype,
  "input",
  2,
);
__decorateClass([r$4()], SlSwitch.prototype, "hasFocus", 2);
__decorateClass([n$6()], SlSwitch.prototype, "title", 2);
__decorateClass([n$6()], SlSwitch.prototype, "name", 2);
__decorateClass([n$6()], SlSwitch.prototype, "value", 2);
__decorateClass([n$6({ reflect: true })], SlSwitch.prototype, "size", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlSwitch.prototype,
  "disabled",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlSwitch.prototype,
  "checked",
  2,
);
__decorateClass(
  [defaultValue("checked")],
  SlSwitch.prototype,
  "defaultChecked",
  2,
);
__decorateClass([n$6({ reflect: true })], SlSwitch.prototype, "form", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlSwitch.prototype,
  "required",
  2,
);
__decorateClass(
  [n$6({ attribute: "help-text" })],
  SlSwitch.prototype,
  "helpText",
  2,
);
__decorateClass(
  [watch("checked", { waitUntilFirstUpdate: true })],
  SlSwitch.prototype,
  "handleCheckedChange",
  1,
);
__decorateClass(
  [watch("disabled", { waitUntilFirstUpdate: true })],
  SlSwitch.prototype,
  "handleDisabledChange",
  1,
);
var tagName$U = "sl-switch";
SlSwitch.define("sl-switch");
o$8({
  tagName: tagName$U,
  elementClass: SlSwitch,
  react: React,
  events: {
    onSlBlur: "sl-blur",
    onSlChange: "sl-change",
    onSlInput: "sl-input",
    onSlFocus: "sl-focus",
    onSlInvalid: "sl-invalid",
  },
  displayName: "SlSwitch",
});
var tab_group_styles_default = i$8`
  :host {
    --indicator-color: var(--sl-color-primary-600);
    --track-color: var(--sl-color-neutral-200);
    --track-width: 2px;

    display: block;
  }

  .tab-group {
    display: flex;
    border-radius: 0;
  }

  .tab-group__tabs {
    display: flex;
    position: relative;
  }

  .tab-group__indicator {
    position: absolute;
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) width ease;
  }

  .tab-group--has-scroll-controls .tab-group__nav-container {
    position: relative;
    padding: 0 var(--sl-spacing-x-large);
  }

  .tab-group--has-scroll-controls .tab-group__scroll-button--start--hidden,
  .tab-group--has-scroll-controls .tab-group__scroll-button--end--hidden {
    visibility: hidden;
  }

  .tab-group__body {
    display: block;
    overflow: auto;
  }

  .tab-group__scroll-button {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    bottom: 0;
    width: var(--sl-spacing-x-large);
  }

  .tab-group__scroll-button--start {
    left: 0;
  }

  .tab-group__scroll-button--end {
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--start {
    left: auto;
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--end {
    left: 0;
    right: auto;
  }

  /*
   * Top
   */

  .tab-group--top {
    flex-direction: column;
  }

  .tab-group--top .tab-group__nav-container {
    order: 1;
  }

  .tab-group--top .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--top .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--top .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-bottom: solid var(--track-width) var(--track-color);
  }

  .tab-group--top .tab-group__indicator {
    bottom: calc(-1 * var(--track-width));
    border-bottom: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--top .tab-group__body {
    order: 2;
  }

  .tab-group--top ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Bottom
   */

  .tab-group--bottom {
    flex-direction: column;
  }

  .tab-group--bottom .tab-group__nav-container {
    order: 2;
  }

  .tab-group--bottom .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--bottom .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--bottom .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-top: solid var(--track-width) var(--track-color);
  }

  .tab-group--bottom .tab-group__indicator {
    top: calc(-1 * var(--track-width));
    border-top: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--bottom .tab-group__body {
    order: 1;
  }

  .tab-group--bottom ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Start
   */

  .tab-group--start {
    flex-direction: row;
  }

  .tab-group--start .tab-group__nav-container {
    order: 1;
  }

  .tab-group--start .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-inline-end: solid var(--track-width) var(--track-color);
  }

  .tab-group--start .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    border-right: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--start.tab-group--rtl .tab-group__indicator {
    right: auto;
    left: calc(-1 * var(--track-width));
  }

  .tab-group--start .tab-group__body {
    flex: 1 1 auto;
    order: 2;
  }

  .tab-group--start ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }

  /*
   * End
   */

  .tab-group--end {
    flex-direction: row;
  }

  .tab-group--end .tab-group__nav-container {
    order: 2;
  }

  .tab-group--end .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-left: solid var(--track-width) var(--track-color);
  }

  .tab-group--end .tab-group__indicator {
    left: calc(-1 * var(--track-width));
    border-inline-start: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--end.tab-group--rtl .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    left: auto;
  }

  .tab-group--end .tab-group__body {
    flex: 1 1 auto;
    order: 1;
  }

  .tab-group--end ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }
`;
var resize_observer_styles_default = i$8`
  :host {
    display: contents;
  }
`;
var SlResizeObserver = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.observedElements = [];
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver((entries) => {
      this.emit("sl-resize", { detail: { entries } });
    });
    if (!this.disabled) {
      this.startObserver();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stopObserver();
  }
  handleSlotChange() {
    if (!this.disabled) {
      this.startObserver();
    }
  }
  startObserver() {
    const slot = this.shadowRoot.querySelector("slot");
    if (slot !== null) {
      const elements = slot.assignedElements({ flatten: true });
      this.observedElements.forEach((el) => this.resizeObserver.unobserve(el));
      this.observedElements = [];
      elements.forEach((el) => {
        this.resizeObserver.observe(el);
        this.observedElements.push(el);
      });
    }
  }
  stopObserver() {
    this.resizeObserver.disconnect();
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.stopObserver();
    } else {
      this.startObserver();
    }
  }
  render() {
    return x$2` <slot @slotchange=${this.handleSlotChange}></slot> `;
  }
};
SlResizeObserver.styles = [
  component_styles_default,
  resize_observer_styles_default,
];
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlResizeObserver.prototype,
  "disabled",
  2,
);
__decorateClass(
  [watch("disabled", { waitUntilFirstUpdate: true })],
  SlResizeObserver.prototype,
  "handleDisabledChange",
  1,
);
function getOffset(element, parent) {
  return {
    top: Math.round(
      element.getBoundingClientRect().top - parent.getBoundingClientRect().top,
    ),
    left: Math.round(
      element.getBoundingClientRect().left -
        parent.getBoundingClientRect().left,
    ),
  };
}
var locks = /* @__PURE__ */ new Set();
function getScrollbarWidth() {
  const documentWidth = document.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
function getExistingBodyPadding() {
  const padding = Number(
    getComputedStyle(document.body).paddingRight.replace(/px/, ""),
  );
  if (isNaN(padding) || !padding) {
    return 0;
  }
  return padding;
}
function lockBodyScrolling(lockingEl) {
  locks.add(lockingEl);
  if (!document.documentElement.classList.contains("sl-scroll-lock")) {
    const scrollbarWidth = getScrollbarWidth() + getExistingBodyPadding();
    let scrollbarGutterProperty = getComputedStyle(
      document.documentElement,
    ).scrollbarGutter;
    if (!scrollbarGutterProperty || scrollbarGutterProperty === "auto") {
      scrollbarGutterProperty = "stable";
    }
    if (scrollbarWidth < 2) {
      scrollbarGutterProperty = "";
    }
    document.documentElement.style.setProperty(
      "--sl-scroll-lock-gutter",
      scrollbarGutterProperty,
    );
    document.documentElement.classList.add("sl-scroll-lock");
    document.documentElement.style.setProperty(
      "--sl-scroll-lock-size",
      `${scrollbarWidth}px`,
    );
  }
}
function unlockBodyScrolling(lockingEl) {
  locks.delete(lockingEl);
  if (locks.size === 0) {
    document.documentElement.classList.remove("sl-scroll-lock");
    document.documentElement.style.removeProperty("--sl-scroll-lock-size");
  }
}
function scrollIntoView(
  element,
  container,
  direction = "vertical",
  behavior = "smooth",
) {
  const offset2 = getOffset(element, container);
  const offsetTop = offset2.top + container.scrollTop;
  const offsetLeft = offset2.left + container.scrollLeft;
  const minX = container.scrollLeft;
  const maxX = container.scrollLeft + container.offsetWidth;
  const minY = container.scrollTop;
  const maxY = container.scrollTop + container.offsetHeight;
  if (direction === "horizontal" || direction === "both") {
    if (offsetLeft < minX) {
      container.scrollTo({ left: offsetLeft, behavior });
    } else if (offsetLeft + element.clientWidth > maxX) {
      container.scrollTo({
        left: offsetLeft - container.offsetWidth + element.clientWidth,
        behavior,
      });
    }
  }
  if (direction === "vertical" || direction === "both") {
    if (offsetTop < minY) {
      container.scrollTo({ top: offsetTop, behavior });
    } else if (offsetTop + element.clientHeight > maxY) {
      container.scrollTo({
        top: offsetTop - container.offsetHeight + element.clientHeight,
        behavior,
      });
    }
  }
}
var icon_button_styles_default = i$8`
  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;
var library = {
  name: "default",
  resolver: (name) => getBasePath(`assets/icons/${name}.svg`),
};
var library_default_default = library;
var icons = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `,
};
var systemLibrary = {
  name: "system",
  resolver: (name) => {
    if (name in icons) {
      return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
    }
    return "";
  },
};
var library_system_default = systemLibrary;
var registry = [library_default_default, library_system_default];
var watchedIcons = [];
function watchIcon(icon) {
  watchedIcons.push(icon);
}
function unwatchIcon(icon) {
  watchedIcons = watchedIcons.filter((el) => el !== icon);
}
function getIconLibrary(name) {
  return registry.find((lib) => lib.name === name);
}
var icon_styles_default = i$8`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;
var CACHEABLE_ERROR = Symbol();
var RETRYABLE_ERROR = Symbol();
var parser;
var iconCache = /* @__PURE__ */ new Map();
var SlIcon = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(url, library2) {
    var _a2;
    let fileData;
    if (library2 == null ? void 0 : library2.spriteSheet) {
      this.svg = x$2`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
      return this.svg;
    }
    try {
      fileData = await fetch(url, { mode: "cors" });
      if (!fileData.ok)
        return fileData.status === 410 ? CACHEABLE_ERROR : RETRYABLE_ERROR;
    } catch (e3) {
      return RETRYABLE_ERROR;
    }
    try {
      const div = document.createElement("div");
      div.innerHTML = await fileData.text();
      const svg = div.firstElementChild;
      if (
        ((_a2 = svg == null ? void 0 : svg.tagName) == null
          ? void 0
          : _a2.toLowerCase()) !== "svg"
      )
        return CACHEABLE_ERROR;
      if (!parser) parser = new DOMParser();
      const doc = parser.parseFromString(svg.outerHTML, "text/html");
      const svgEl = doc.body.querySelector("svg");
      if (!svgEl) return CACHEABLE_ERROR;
      svgEl.part.add("svg");
      return document.adoptNode(svgEl);
    } catch (e3) {
      return CACHEABLE_ERROR;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon(this);
  }
  getIconSource() {
    const library2 = getIconLibrary(this.library);
    if (this.name && library2) {
      return {
        url: library2.resolver(this.name),
        fromLibrary: true,
      };
    }
    return {
      url: this.src,
      fromLibrary: false,
    };
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  async setIcon() {
    var _a2;
    const { url, fromLibrary } = this.getIconSource();
    const library2 = fromLibrary ? getIconLibrary(this.library) : void 0;
    if (!url) {
      this.svg = null;
      return;
    }
    let iconResolver = iconCache.get(url);
    if (!iconResolver) {
      iconResolver = this.resolveIcon(url, library2);
      iconCache.set(url, iconResolver);
    }
    if (!this.initialRender) {
      return;
    }
    const svg = await iconResolver;
    if (svg === RETRYABLE_ERROR) {
      iconCache.delete(url);
    }
    if (url !== this.getIconSource().url) {
      return;
    }
    if (e$3(svg)) {
      this.svg = svg;
      if (library2) {
        await this.updateComplete;
        const shadowSVG = this.shadowRoot.querySelector("[part='svg']");
        if (typeof library2.mutator === "function" && shadowSVG) {
          library2.mutator(shadowSVG);
        }
      }
      return;
    }
    switch (svg) {
      case RETRYABLE_ERROR:
      case CACHEABLE_ERROR:
        this.svg = null;
        this.emit("sl-error");
        break;
      default:
        this.svg = svg.cloneNode(true);
        (_a2 = library2 == null ? void 0 : library2.mutator) == null
          ? void 0
          : _a2.call(library2, this.svg);
        this.emit("sl-load");
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon.styles = [component_styles_default, icon_styles_default];
__decorateClass([r$4()], SlIcon.prototype, "svg", 2);
__decorateClass([n$6({ reflect: true })], SlIcon.prototype, "name", 2);
__decorateClass([n$6()], SlIcon.prototype, "src", 2);
__decorateClass([n$6()], SlIcon.prototype, "label", 2);
__decorateClass([n$6({ reflect: true })], SlIcon.prototype, "library", 2);
__decorateClass([watch("label")], SlIcon.prototype, "handleLabelChange", 1);
__decorateClass(
  [watch(["name", "src", "library"])],
  SlIcon.prototype,
  "setIcon",
  1,
);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const a = Symbol.for(""),
  o$6 = (t2) => {
    if ((t2 == null ? void 0 : t2.r) === a)
      return t2 == null ? void 0 : t2._$litStatic$;
  },
  i$2 = (t2, ...r3) => ({
    _$litStatic$: r3.reduce(
      (r4, e3, a2) =>
        r4 +
        ((t3) => {
          if (void 0 !== t3._$litStatic$) return t3._$litStatic$;
          throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t3}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
        })(e3) +
        t2[a2 + 1],
      t2[0],
    ),
    r: a,
  }),
  l = /* @__PURE__ */ new Map(),
  n$4 =
    (t2) =>
    (r3, ...e3) => {
      const a2 = e3.length;
      let s2, i3;
      const n3 = [],
        u2 = [];
      let c2,
        $2 = 0,
        f2 = false;
      for (; $2 < a2; ) {
        for (
          c2 = r3[$2];
          $2 < a2 && void 0 !== ((i3 = e3[$2]), (s2 = o$6(i3)));

        )
          (c2 += s2 + r3[++$2]), (f2 = true);
        $2 !== a2 && u2.push(i3), n3.push(c2), $2++;
      }
      if (($2 === a2 && n3.push(r3[a2]), f2)) {
        const t3 = n3.join("$$lit$$");
        void 0 === (r3 = l.get(t3)) && ((n3.raw = n3), l.set(t3, (r3 = n3))),
          (e3 = u2);
      }
      return t2(r3, ...e3);
    },
  u = n$4(x$2);
var SlIconButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasFocus = false;
    this.label = "";
    this.disabled = false;
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const isLink = this.href ? true : false;
    const tag = isLink ? i$2`a` : i$2`button`;
    return u`
      <${tag}
        part="base"
        class=${e$4({
          "icon-button": true,
          "icon-button--disabled": !isLink && this.disabled,
          "icon-button--focused": this.hasFocus,
        })}
        ?disabled=${o$7(isLink ? void 0 : this.disabled)}
        type=${o$7(isLink ? void 0 : "button")}
        href=${o$7(isLink ? this.href : void 0)}
        target=${o$7(isLink ? this.target : void 0)}
        download=${o$7(isLink ? this.download : void 0)}
        rel=${o$7(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${o$7(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${o$7(this.name)}
          library=${o$7(this.library)}
          src=${o$7(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${tag}>
    `;
  }
};
SlIconButton.styles = [component_styles_default, icon_button_styles_default];
SlIconButton.dependencies = { "sl-icon": SlIcon };
__decorateClass([e$8(".icon-button")], SlIconButton.prototype, "button", 2);
__decorateClass([r$4()], SlIconButton.prototype, "hasFocus", 2);
__decorateClass([n$6()], SlIconButton.prototype, "name", 2);
__decorateClass([n$6()], SlIconButton.prototype, "library", 2);
__decorateClass([n$6()], SlIconButton.prototype, "src", 2);
__decorateClass([n$6()], SlIconButton.prototype, "href", 2);
__decorateClass([n$6()], SlIconButton.prototype, "target", 2);
__decorateClass([n$6()], SlIconButton.prototype, "download", 2);
__decorateClass([n$6()], SlIconButton.prototype, "label", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlIconButton.prototype,
  "disabled",
  2,
);
const connectedElements = /* @__PURE__ */ new Set();
const translations = /* @__PURE__ */ new Map();
let fallback;
let documentDirection = "ltr";
let documentLanguage = "en";
const isClient =
  typeof MutationObserver !== "undefined" &&
  typeof document !== "undefined" &&
  typeof document.documentElement !== "undefined";
if (isClient) {
  const documentElementObserver = new MutationObserver(update);
  documentDirection = document.documentElement.dir || "ltr";
  documentLanguage = document.documentElement.lang || navigator.language;
  documentElementObserver.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["dir", "lang"],
  });
}
function registerTranslation(...translation2) {
  translation2.map((t2) => {
    const code = t2.$code.toLowerCase();
    if (translations.has(code)) {
      translations.set(
        code,
        Object.assign(Object.assign({}, translations.get(code)), t2),
      );
    } else {
      translations.set(code, t2);
    }
    if (!fallback) {
      fallback = t2;
    }
  });
  update();
}
function update() {
  if (isClient) {
    documentDirection = document.documentElement.dir || "ltr";
    documentLanguage = document.documentElement.lang || navigator.language;
  }
  [...connectedElements.keys()].map((el) => {
    if (typeof el.requestUpdate === "function") {
      el.requestUpdate();
    }
  });
}
let LocalizeController$1 = class LocalizeController {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements.add(this.host);
  }
  hostDisconnected() {
    connectedElements.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage}`.toLowerCase();
  }
  getTranslationData(lang) {
    var _a2, _b2;
    const locale = new Intl.Locale(lang.replace(/_/g, "-"));
    const language =
      locale === null || locale === void 0
        ? void 0
        : locale.language.toLowerCase();
    const region =
      (_b2 =
        (_a2 =
          locale === null || locale === void 0 ? void 0 : locale.region) ===
          null || _a2 === void 0
          ? void 0
          : _a2.toLowerCase()) !== null && _b2 !== void 0
        ? _b2
        : "";
    const primary = translations.get(`${language}-${region}`);
    const secondary = translations.get(language);
    return { locale, language, region, primary, secondary };
  }
  exists(key, options) {
    var _a2;
    const { primary, secondary } = this.getTranslationData(
      (_a2 = options.lang) !== null && _a2 !== void 0 ? _a2 : this.lang(),
    );
    options = Object.assign({ includeFallback: false }, options);
    if (
      (primary && primary[key]) ||
      (secondary && secondary[key]) ||
      (options.includeFallback && fallback && fallback[key])
    ) {
      return true;
    }
    return false;
  }
  term(key, ...args) {
    const { primary, secondary } = this.getTranslationData(this.lang());
    let term;
    if (primary && primary[key]) {
      term = primary[key];
    } else if (secondary && secondary[key]) {
      term = secondary[key];
    } else if (fallback && fallback[key]) {
      term = fallback[key];
    } else {
      console.error(`No translation found for: ${String(key)}`);
      return String(key);
    }
    if (typeof term === "function") {
      return term(...args);
    }
    return term;
  }
  date(dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
  }
  number(numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat)
      ? ""
      : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
  }
  relativeTime(value, unit, options) {
    return new Intl.RelativeTimeFormat(this.lang(), options).format(
      value,
      unit,
    );
  }
};
var translation = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (num) => {
    if (num === 0) return "No options selected";
    if (num === 1) return "1 option selected";
    return `${num} options selected`;
  },
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (slide) => `Slide ${slide}`,
  toggleColorFormat: "Toggle color format",
};
registerTranslation(translation);
var en_default = translation;
var LocalizeController2 = class extends LocalizeController$1 {};
registerTranslation(en_default);
var SlTabGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.tabs = [];
    this.focusableTabs = [];
    this.panels = [];
    this.localize = new LocalizeController2(this);
    this.hasScrollControls = false;
    this.shouldHideScrollStartButton = false;
    this.shouldHideScrollEndButton = false;
    this.placement = "top";
    this.activation = "auto";
    this.noScrollControls = false;
    this.fixedScrollControls = false;
    this.scrollOffset = 1;
  }
  connectedCallback() {
    const whenAllDefined = Promise.all([
      customElements.whenDefined("sl-tab"),
      customElements.whenDefined("sl-tab-panel"),
    ]);
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => {
      this.repositionIndicator();
      this.updateScrollControls();
    });
    this.mutationObserver = new MutationObserver((mutations) => {
      if (
        mutations.some(
          (m2) =>
            !["aria-labelledby", "aria-controls"].includes(m2.attributeName),
        )
      ) {
        setTimeout(() => this.setAriaLabels());
      }
      if (mutations.some((m2) => m2.attributeName === "disabled")) {
        this.syncTabsAndPanels();
      } else if (mutations.some((m2) => m2.attributeName === "active")) {
        const tabs = mutations
          .filter(
            (m2) =>
              m2.attributeName === "active" &&
              m2.target.tagName.toLowerCase() === "sl-tab",
          )
          .map((m2) => m2.target);
        const newActiveTab = tabs.find((tab) => tab.active);
        if (newActiveTab) {
          this.setActiveTab(newActiveTab);
        }
      }
    });
    this.updateComplete.then(() => {
      this.syncTabsAndPanels();
      this.mutationObserver.observe(this, {
        attributes: true,
        childList: true,
        subtree: true,
      });
      this.resizeObserver.observe(this.nav);
      whenAllDefined.then(() => {
        const intersectionObserver = new IntersectionObserver(
          (entries, observer) => {
            var _a2;
            if (entries[0].intersectionRatio > 0) {
              this.setAriaLabels();
              this.setActiveTab(
                (_a2 = this.getActiveTab()) != null ? _a2 : this.tabs[0],
                { emitEvents: false },
              );
              observer.unobserve(entries[0].target);
            }
          },
        );
        intersectionObserver.observe(this.tabGroup);
      });
    });
  }
  disconnectedCallback() {
    var _a2, _b2;
    super.disconnectedCallback();
    (_a2 = this.mutationObserver) == null ? void 0 : _a2.disconnect();
    if (this.nav) {
      (_b2 = this.resizeObserver) == null ? void 0 : _b2.unobserve(this.nav);
    }
  }
  getAllTabs() {
    const slot = this.shadowRoot.querySelector('slot[name="nav"]');
    return slot.assignedElements();
  }
  getAllPanels() {
    return [...this.body.assignedElements()].filter(
      (el) => el.tagName.toLowerCase() === "sl-tab-panel",
    );
  }
  getActiveTab() {
    return this.tabs.find((el) => el.active);
  }
  handleClick(event) {
    const target = event.target;
    const tab = target.closest("sl-tab");
    const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
    if (tabGroup !== this) {
      return;
    }
    if (tab !== null) {
      this.setActiveTab(tab, { scrollBehavior: "smooth" });
    }
  }
  handleKeyDown(event) {
    const target = event.target;
    const tab = target.closest("sl-tab");
    const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
    if (tabGroup !== this) {
      return;
    }
    if (["Enter", " "].includes(event.key)) {
      if (tab !== null) {
        this.setActiveTab(tab, { scrollBehavior: "smooth" });
        event.preventDefault();
      }
    }
    if (
      [
        "ArrowLeft",
        "ArrowRight",
        "ArrowUp",
        "ArrowDown",
        "Home",
        "End",
      ].includes(event.key)
    ) {
      const activeEl = this.tabs.find((t2) => t2.matches(":focus"));
      const isRtl = this.localize.dir() === "rtl";
      let nextTab = null;
      if (
        (activeEl == null ? void 0 : activeEl.tagName.toLowerCase()) ===
        "sl-tab"
      ) {
        if (event.key === "Home") {
          nextTab = this.focusableTabs[0];
        } else if (event.key === "End") {
          nextTab = this.focusableTabs[this.focusableTabs.length - 1];
        } else if (
          (["top", "bottom"].includes(this.placement) &&
            event.key === (isRtl ? "ArrowRight" : "ArrowLeft")) ||
          (["start", "end"].includes(this.placement) && event.key === "ArrowUp")
        ) {
          const currentIndex = this.tabs.findIndex((el) => el === activeEl);
          nextTab = this.findNextFocusableTab(currentIndex, "backward");
        } else if (
          (["top", "bottom"].includes(this.placement) &&
            event.key === (isRtl ? "ArrowLeft" : "ArrowRight")) ||
          (["start", "end"].includes(this.placement) &&
            event.key === "ArrowDown")
        ) {
          const currentIndex = this.tabs.findIndex((el) => el === activeEl);
          nextTab = this.findNextFocusableTab(currentIndex, "forward");
        }
        if (!nextTab) {
          return;
        }
        nextTab.tabIndex = 0;
        nextTab.focus({ preventScroll: true });
        if (this.activation === "auto") {
          this.setActiveTab(nextTab, { scrollBehavior: "smooth" });
        } else {
          this.tabs.forEach((tabEl) => {
            tabEl.tabIndex = tabEl === nextTab ? 0 : -1;
          });
        }
        if (["top", "bottom"].includes(this.placement)) {
          scrollIntoView(nextTab, this.nav, "horizontal");
        }
        event.preventDefault();
      }
    }
  }
  handleScrollToStart() {
    this.nav.scroll({
      left:
        this.localize.dir() === "rtl"
          ? this.nav.scrollLeft + this.nav.clientWidth
          : this.nav.scrollLeft - this.nav.clientWidth,
      behavior: "smooth",
    });
  }
  handleScrollToEnd() {
    this.nav.scroll({
      left:
        this.localize.dir() === "rtl"
          ? this.nav.scrollLeft - this.nav.clientWidth
          : this.nav.scrollLeft + this.nav.clientWidth,
      behavior: "smooth",
    });
  }
  setActiveTab(tab, options) {
    options = __spreadValues(
      {
        emitEvents: true,
        scrollBehavior: "auto",
      },
      options,
    );
    if (tab !== this.activeTab && !tab.disabled) {
      const previousTab = this.activeTab;
      this.activeTab = tab;
      this.tabs.forEach((el) => {
        el.active = el === this.activeTab;
        el.tabIndex = el === this.activeTab ? 0 : -1;
      });
      this.panels.forEach((el) => {
        var _a2;
        return (el.active =
          el.name === ((_a2 = this.activeTab) == null ? void 0 : _a2.panel));
      });
      this.syncIndicator();
      if (["top", "bottom"].includes(this.placement)) {
        scrollIntoView(
          this.activeTab,
          this.nav,
          "horizontal",
          options.scrollBehavior,
        );
      }
      if (options.emitEvents) {
        if (previousTab) {
          this.emit("sl-tab-hide", { detail: { name: previousTab.panel } });
        }
        this.emit("sl-tab-show", { detail: { name: this.activeTab.panel } });
      }
    }
  }
  setAriaLabels() {
    this.tabs.forEach((tab) => {
      const panel = this.panels.find((el) => el.name === tab.panel);
      if (panel) {
        tab.setAttribute("aria-controls", panel.getAttribute("id"));
        panel.setAttribute("aria-labelledby", tab.getAttribute("id"));
      }
    });
  }
  repositionIndicator() {
    const currentTab = this.getActiveTab();
    if (!currentTab) {
      return;
    }
    const width = currentTab.clientWidth;
    const height = currentTab.clientHeight;
    const isRtl = this.localize.dir() === "rtl";
    const allTabs = this.getAllTabs();
    const precedingTabs = allTabs.slice(0, allTabs.indexOf(currentTab));
    const offset2 = precedingTabs.reduce(
      (previous, current) => ({
        left: previous.left + current.clientWidth,
        top: previous.top + current.clientHeight,
      }),
      { left: 0, top: 0 },
    );
    switch (this.placement) {
      case "top":
      case "bottom":
        this.indicator.style.width = `${width}px`;
        this.indicator.style.height = "auto";
        this.indicator.style.translate = isRtl
          ? `${-1 * offset2.left}px`
          : `${offset2.left}px`;
        break;
      case "start":
      case "end":
        this.indicator.style.width = "auto";
        this.indicator.style.height = `${height}px`;
        this.indicator.style.translate = `0 ${offset2.top}px`;
        break;
    }
  }
  // This stores tabs and panels so we can refer to a cache instead of calling querySelectorAll() multiple times.
  syncTabsAndPanels() {
    this.tabs = this.getAllTabs();
    this.focusableTabs = this.tabs.filter((el) => !el.disabled);
    this.panels = this.getAllPanels();
    this.syncIndicator();
    this.updateComplete.then(() => this.updateScrollControls());
  }
  findNextFocusableTab(currentIndex, direction) {
    let nextTab = null;
    const iterator = direction === "forward" ? 1 : -1;
    let nextIndex = currentIndex + iterator;
    while (currentIndex < this.tabs.length) {
      nextTab = this.tabs[nextIndex] || null;
      if (nextTab === null) {
        if (direction === "forward") {
          nextTab = this.focusableTabs[0];
        } else {
          nextTab = this.focusableTabs[this.focusableTabs.length - 1];
        }
        break;
      }
      if (!nextTab.disabled) {
        break;
      }
      nextIndex += iterator;
    }
    return nextTab;
  }
  updateScrollButtons() {
    if (this.hasScrollControls && !this.fixedScrollControls) {
      this.shouldHideScrollStartButton =
        this.scrollFromStart() <= this.scrollOffset;
      this.shouldHideScrollEndButton = this.isScrolledToEnd();
    }
  }
  isScrolledToEnd() {
    return (
      this.scrollFromStart() + this.nav.clientWidth >=
      this.nav.scrollWidth - this.scrollOffset
    );
  }
  scrollFromStart() {
    return this.localize.dir() === "rtl"
      ? -this.nav.scrollLeft
      : this.nav.scrollLeft;
  }
  updateScrollControls() {
    if (this.noScrollControls) {
      this.hasScrollControls = false;
    } else {
      this.hasScrollControls =
        ["top", "bottom"].includes(this.placement) &&
        this.nav.scrollWidth > this.nav.clientWidth + 1;
    }
    this.updateScrollButtons();
  }
  syncIndicator() {
    const tab = this.getActiveTab();
    if (tab) {
      this.indicator.style.display = "block";
      this.repositionIndicator();
    } else {
      this.indicator.style.display = "none";
    }
  }
  /** Shows the specified tab panel. */
  show(panel) {
    const tab = this.tabs.find((el) => el.panel === panel);
    if (tab) {
      this.setActiveTab(tab, { scrollBehavior: "smooth" });
    }
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    return x$2`
      <div
        part="base"
        class=${e$4({
          "tab-group": true,
          "tab-group--top": this.placement === "top",
          "tab-group--bottom": this.placement === "bottom",
          "tab-group--start": this.placement === "start",
          "tab-group--end": this.placement === "end",
          "tab-group--rtl": this.localize.dir() === "rtl",
          "tab-group--has-scroll-controls": this.hasScrollControls,
        })}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
      >
        <div class="tab-group__nav-container" part="nav">
          ${
            this.hasScrollControls
              ? x$2`
                <sl-icon-button
                  part="scroll-button scroll-button--start"
                  exportparts="base:scroll-button__base"
                  class=${e$4({
                    "tab-group__scroll-button": true,
                    "tab-group__scroll-button--start": true,
                    "tab-group__scroll-button--start--hidden":
                      this.shouldHideScrollStartButton,
                  })}
                  name=${isRtl ? "chevron-right" : "chevron-left"}
                  library="system"
                  tabindex="-1"
                  aria-hidden="true"
                  label=${this.localize.term("scrollToStart")}
                  @click=${this.handleScrollToStart}
                ></sl-icon-button>
              `
              : ""
          }

          <div class="tab-group__nav" @scrollend=${this.updateScrollButtons}>
            <div part="tabs" class="tab-group__tabs" role="tablist">
              <div part="active-tab-indicator" class="tab-group__indicator"></div>
              <sl-resize-observer @sl-resize=${this.syncIndicator}>
                <slot name="nav" @slotchange=${this.syncTabsAndPanels}></slot>
              </sl-resize-observer>
            </div>
          </div>

          ${
            this.hasScrollControls
              ? x$2`
                <sl-icon-button
                  part="scroll-button scroll-button--end"
                  exportparts="base:scroll-button__base"
                  class=${e$4({
                    "tab-group__scroll-button": true,
                    "tab-group__scroll-button--end": true,
                    "tab-group__scroll-button--end--hidden":
                      this.shouldHideScrollEndButton,
                  })}
                  name=${isRtl ? "chevron-left" : "chevron-right"}
                  library="system"
                  tabindex="-1"
                  aria-hidden="true"
                  label=${this.localize.term("scrollToEnd")}
                  @click=${this.handleScrollToEnd}
                ></sl-icon-button>
              `
              : ""
          }
        </div>

        <slot part="body" class="tab-group__body" @slotchange=${this.syncTabsAndPanels}></slot>
      </div>
    `;
  }
};
SlTabGroup.styles = [component_styles_default, tab_group_styles_default];
SlTabGroup.dependencies = {
  "sl-icon-button": SlIconButton,
  "sl-resize-observer": SlResizeObserver,
};
__decorateClass([e$8(".tab-group")], SlTabGroup.prototype, "tabGroup", 2);
__decorateClass([e$8(".tab-group__body")], SlTabGroup.prototype, "body", 2);
__decorateClass([e$8(".tab-group__nav")], SlTabGroup.prototype, "nav", 2);
__decorateClass(
  [e$8(".tab-group__indicator")],
  SlTabGroup.prototype,
  "indicator",
  2,
);
__decorateClass([r$4()], SlTabGroup.prototype, "hasScrollControls", 2);
__decorateClass(
  [r$4()],
  SlTabGroup.prototype,
  "shouldHideScrollStartButton",
  2,
);
__decorateClass([r$4()], SlTabGroup.prototype, "shouldHideScrollEndButton", 2);
__decorateClass([n$6()], SlTabGroup.prototype, "placement", 2);
__decorateClass([n$6()], SlTabGroup.prototype, "activation", 2);
__decorateClass(
  [n$6({ attribute: "no-scroll-controls", type: Boolean })],
  SlTabGroup.prototype,
  "noScrollControls",
  2,
);
__decorateClass(
  [n$6({ attribute: "fixed-scroll-controls", type: Boolean })],
  SlTabGroup.prototype,
  "fixedScrollControls",
  2,
);
__decorateClass(
  [t$3({ passive: true })],
  SlTabGroup.prototype,
  "updateScrollButtons",
  1,
);
__decorateClass(
  [watch("noScrollControls", { waitUntilFirstUpdate: true })],
  SlTabGroup.prototype,
  "updateScrollControls",
  1,
);
__decorateClass(
  [watch("placement", { waitUntilFirstUpdate: true })],
  SlTabGroup.prototype,
  "syncIndicator",
  1,
);
var tagName$T = "sl-tab-group";
SlTabGroup.define("sl-tab-group");
o$8({
  tagName: tagName$T,
  elementClass: SlTabGroup,
  react: React,
  events: {
    onSlTabShow: "sl-tab-show",
    onSlTabHide: "sl-tab-hide",
  },
  displayName: "SlTabGroup",
});
var tab_panel_styles_default = i$8`
  :host {
    --padding: 0;

    display: none;
  }

  :host([active]) {
    display: block;
  }

  .tab-panel {
    display: block;
    padding: var(--padding);
  }
`;
var id$1 = 0;
var SlTabPanel = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.attrId = ++id$1;
    this.componentId = `sl-tab-panel-${this.attrId}`;
    this.name = "";
    this.active = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.id = this.id.length > 0 ? this.id : this.componentId;
    this.setAttribute("role", "tabpanel");
  }
  handleActiveChange() {
    this.setAttribute("aria-hidden", this.active ? "false" : "true");
  }
  render() {
    return x$2`
      <slot
        part="base"
        class=${e$4({
          "tab-panel": true,
          "tab-panel--active": this.active,
        })}
      ></slot>
    `;
  }
};
SlTabPanel.styles = [component_styles_default, tab_panel_styles_default];
__decorateClass([n$6({ reflect: true })], SlTabPanel.prototype, "name", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlTabPanel.prototype,
  "active",
  2,
);
__decorateClass(
  [watch("active")],
  SlTabPanel.prototype,
  "handleActiveChange",
  1,
);
var tagName$S = "sl-tab-panel";
SlTabPanel.define("sl-tab-panel");
o$8({
  tagName: tagName$S,
  elementClass: SlTabPanel,
  react: React,
  events: {},
  displayName: "SlTabPanel",
});
var tag_styles_default = i$8`
  :host {
    display: inline-block;
  }

  .tag {
    display: flex;
    align-items: center;
    border: solid 1px;
    line-height: 1;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
  }

  .tag__remove::part(base) {
    color: inherit;
    padding: 0;
  }

  /*
   * Variant modifiers
   */

  .tag--primary {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-200);
    color: var(--sl-color-primary-800);
  }

  .tag--primary:active > sl-icon-button {
    color: var(--sl-color-primary-600);
  }

  .tag--success {
    background-color: var(--sl-color-success-50);
    border-color: var(--sl-color-success-200);
    color: var(--sl-color-success-800);
  }

  .tag--success:active > sl-icon-button {
    color: var(--sl-color-success-600);
  }

  .tag--neutral {
    background-color: var(--sl-color-neutral-50);
    border-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-800);
  }

  .tag--neutral:active > sl-icon-button {
    color: var(--sl-color-neutral-600);
  }

  .tag--warning {
    background-color: var(--sl-color-warning-50);
    border-color: var(--sl-color-warning-200);
    color: var(--sl-color-warning-800);
  }

  .tag--warning:active > sl-icon-button {
    color: var(--sl-color-warning-600);
  }

  .tag--danger {
    background-color: var(--sl-color-danger-50);
    border-color: var(--sl-color-danger-200);
    color: var(--sl-color-danger-800);
  }

  .tag--danger:active > sl-icon-button {
    color: var(--sl-color-danger-600);
  }

  /*
   * Size modifiers
   */

  .tag--small {
    font-size: var(--sl-button-font-size-small);
    height: calc(var(--sl-input-height-small) * 0.8);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
    padding: 0 var(--sl-spacing-x-small);
  }

  .tag--medium {
    font-size: var(--sl-button-font-size-medium);
    height: calc(var(--sl-input-height-medium) * 0.8);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
    padding: 0 var(--sl-spacing-small);
  }

  .tag--large {
    font-size: var(--sl-button-font-size-large);
    height: calc(var(--sl-input-height-large) * 0.8);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
    padding: 0 var(--sl-spacing-medium);
  }

  .tag__remove {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /*
   * Pill modifier
   */

  .tag--pill {
    border-radius: var(--sl-border-radius-pill);
  }
`;
var SlTag = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.variant = "neutral";
    this.size = "medium";
    this.pill = false;
    this.removable = false;
  }
  handleRemoveClick() {
    this.emit("sl-remove");
  }
  render() {
    return x$2`
      <span
        part="base"
        class=${e$4({
          tag: true,
          // Types
          "tag--primary": this.variant === "primary",
          "tag--success": this.variant === "success",
          "tag--neutral": this.variant === "neutral",
          "tag--warning": this.variant === "warning",
          "tag--danger": this.variant === "danger",
          "tag--text": this.variant === "text",
          // Sizes
          "tag--small": this.size === "small",
          "tag--medium": this.size === "medium",
          "tag--large": this.size === "large",
          // Modifiers
          "tag--pill": this.pill,
          "tag--removable": this.removable,
        })}
      >
        <slot part="content" class="tag__content"></slot>

        ${
          this.removable
            ? x$2`
              <sl-icon-button
                part="remove-button"
                exportparts="base:remove-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("remove")}
                class="tag__remove"
                @click=${this.handleRemoveClick}
                tabindex="-1"
              ></sl-icon-button>
            `
            : ""
        }
      </span>
    `;
  }
};
SlTag.styles = [component_styles_default, tag_styles_default];
SlTag.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([n$6({ reflect: true })], SlTag.prototype, "variant", 2);
__decorateClass([n$6({ reflect: true })], SlTag.prototype, "size", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlTag.prototype,
  "pill",
  2,
);
__decorateClass([n$6({ type: Boolean })], SlTag.prototype, "removable", 2);
var tagName$R = "sl-tag";
SlTag.define("sl-tag");
var reactWrapper$h = o$8({
  tagName: tagName$R,
  elementClass: SlTag,
  react: React,
  events: {
    onSlRemove: "sl-remove",
  },
  displayName: "SlTag",
});
var tag_default = reactWrapper$h;
var tooltip_styles_default = i$8`
  :host {
    --max-width: 20rem;
    --hide-delay: 0ms;
    --show-delay: 150ms;

    display: contents;
  }

  .tooltip {
    --arrow-size: var(--sl-tooltip-arrow-size);
    --arrow-color: var(--sl-tooltip-background-color);
  }

  .tooltip::part(popup) {
    z-index: var(--sl-z-index-tooltip);
  }

  .tooltip[placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .tooltip[placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .tooltip[placement^='left']::part(popup) {
    transform-origin: right;
  }

  .tooltip[placement^='right']::part(popup) {
    transform-origin: left;
  }

  .tooltip__body {
    display: block;
    width: max-content;
    max-width: var(--max-width);
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    text-align: start;
    white-space: normal;
    color: var(--sl-tooltip-color);
    padding: var(--sl-tooltip-padding);
    pointer-events: none;
    user-select: none;
    -webkit-user-select: none;
  }
`;
var popup_styles_default = i$8`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2,
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom",
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start",
};
function clamp$1(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide =
    alignmentAxis === "x"
      ? alignment === (rtl ? "end" : "start")
        ? "right"
        : "left"
      : alignment === "start"
        ? "bottom"
        : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [
    getOppositeAlignmentPlacement(placement),
    oppositePlacement,
    getOppositeAlignmentPlacement(oppositePlacement),
  ];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(
    /start|end/g,
    (alignment) => oppositeAlignmentMap[alignment],
  );
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(
    /left|right|bottom|top/g,
    (side) => oppositeSideMap[side],
  );
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding,
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number"
    ? expandPaddingObject(padding)
    : {
        top: padding,
        right: padding,
        bottom: padding,
        left: padding,
      };
}
function rectToClientRect(rect) {
  const { x: x2, y: y2, width, height } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2,
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let { reference, floating } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height,
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height,
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY,
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY,
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y,
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null
    ? void 0
    : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy,
  });
  let { x: x2, y: y2 } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i3 = 0; i3 < validMiddleware.length; i3++) {
    const { name, fn: fn2 } = validMiddleware[i3];
    const {
      x: nextX,
      y: nextY,
      data,
      reset,
    } = await fn2({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating,
      },
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data,
      },
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects =
            reset.rects === true
              ? await platform2.getElementRects({
                  reference,
                  floating,
                  strategy,
                })
              : reset.rects;
        }
        ({ x: x2, y: y2 } = computeCoordsFromPlacement(
          rects,
          statefulPlacement,
          rtl,
        ));
      }
      i3 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData,
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy,
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0,
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(
    await platform2.getClippingRect({
      element: (
        (_await$platform$isEle = await (platform2.isElement == null
          ? void 0
          : platform2.isElement(element))) != null
          ? _await$platform$isEle
          : true
      )
        ? element
        : element.contextElement ||
          (await (platform2.getDocumentElement == null
            ? void 0
            : platform2.getDocumentElement(elements.floating))),
      boundary,
      rootBoundary,
      strategy,
    }),
  );
  const rect =
    elementContext === "floating"
      ? {
          x: x2,
          y: y2,
          width: rects.floating.width,
          height: rects.floating.height,
        }
      : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null
    ? void 0
    : platform2.getOffsetParent(elements.floating));
  const offsetScale = (await (platform2.isElement == null
    ? void 0
    : platform2.isElement(offsetParent)))
    ? (await (platform2.getScale == null
        ? void 0
        : platform2.getScale(offsetParent))) || {
        x: 1,
        y: 1,
      }
    : {
        x: 1,
        y: 1,
      };
  const elementClientRect = rectToClientRect(
    platform2.convertOffsetParentRelativeRectToViewportRelativeRect
      ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
          elements,
          rect,
          offsetParent,
          strategy,
        })
      : rect,
  );
  return {
    top:
      (clippingClientRect.top - elementClientRect.top + paddingObject.top) /
      offsetScale.y,
    bottom:
      (elementClientRect.bottom -
        clippingClientRect.bottom +
        paddingObject.bottom) /
      offsetScale.y,
    left:
      (clippingClientRect.left - elementClientRect.left + paddingObject.left) /
      offsetScale.x,
    right:
      (elementClientRect.right -
        clippingClientRect.right +
        paddingObject.right) /
      offsetScale.x,
  };
}
const arrow$1 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData,
    } = state;
    const { element, padding = 0 } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2,
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff =
      rects.reference[length] +
      rects.reference[axis] -
      coords[axis] -
      rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null
      ? void 0
      : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (
      !clientSize ||
      !(await (platform2.isElement == null
        ? void 0
        : platform2.isElement(arrowOffsetParent)))
    ) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding =
      clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center =
      clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp$1(min$1, center, max2);
    const shouldAddOffset =
      !middlewareData.arrow &&
      getAlignment(placement) != null &&
      center !== offset2 &&
      rects.reference[length] / 2 -
        (center < min$1 ? minPadding : maxPadding) -
        arrowDimensions[length] / 2 <
        0;
    const alignmentOffset = shouldAddOffset
      ? center < min$1
        ? center - min$1
        : center - max2
      : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...(shouldAddOffset && {
          alignmentOffset,
        }),
      },
      reset: shouldAddOffset,
    };
  },
});
const flip$2 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements,
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if (
        (_middlewareData$arrow = middlewareData.arrow) != null &&
        _middlewareData$arrow.alignmentOffset
      ) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null
        ? void 0
        : platform2.isRTL(elements.floating));
      const fallbackPlacements =
        specifiedFallbackPlacements ||
        (isBasePlacement || !flipAlignment
          ? [getOppositePlacement(initialPlacement)]
          : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(
          ...getOppositeAxisPlacements(
            initialPlacement,
            flipAlignment,
            fallbackAxisSideDirection,
            rtl,
          ),
        );
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData =
        ((_middlewareData$flip = middlewareData.flip) == null
          ? void 0
          : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [
        ...overflowsData,
        {
          placement,
          overflows,
        },
      ];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex =
          (((_middlewareData$flip2 = middlewareData.flip) == null
            ? void 0
            : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData,
            },
            reset: {
              placement: nextPlacement,
            },
          };
        }
        let resetPlacement =
          (_overflowsData$filter = overflowsData
            .filter((d2) => d2.overflows[0] <= 0)
            .sort((a2, b3) => a2.overflows[1] - b3.overflows[1])[0]) == null
            ? void 0
            : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 =
                (_overflowsData$filter2 = overflowsData
                  .filter((d2) => {
                    if (hasFallbackAxisSideDirection) {
                      const currentSideAxis = getSideAxis(d2.placement);
                      return (
                        currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                        // reading directions favoring greater width.
                        currentSideAxis === "y"
                      );
                    }
                    return true;
                  })
                  .map((d2) => [
                    d2.placement,
                    d2.overflows
                      .filter((overflow2) => overflow2 > 0)
                      .reduce((acc, overflow2) => acc + overflow2, 0),
                  ])
                  .sort((a2, b3) => a2[1] - b3[1])[0]) == null
                  ? void 0
                  : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement,
            },
          };
        }
      }
      return {};
    },
  };
};
async function convertValueToCoords(state, options) {
  const { placement, platform: platform2, elements } = state;
  const rtl = await (platform2.isRTL == null
    ? void 0
    : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let { mainAxis, crossAxis, alignmentAxis } =
    typeof rawValue === "number"
      ? {
          mainAxis: rawValue,
          crossAxis: 0,
          alignmentAxis: null,
        }
      : {
          mainAxis: rawValue.mainAxis || 0,
          crossAxis: rawValue.crossAxis || 0,
          alignmentAxis: rawValue.alignmentAxis,
        };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical
    ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti,
      }
    : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti,
      };
}
const offset$1 = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const { x: x2, y: y2, placement, middlewareData } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (
        placement ===
          ((_middlewareData$offse = middlewareData.offset) == null
            ? void 0
            : _middlewareData$offse.placement) &&
        (_middlewareData$arrow = middlewareData.arrow) != null &&
        _middlewareData$arrow.alignmentOffset
      ) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement,
        },
      };
    },
  };
};
const shift$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const { x: x2, y: y2, placement } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let { x: x3, y: y3 } = _ref;
            return {
              x: x3,
              y: y3,
            };
          },
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2,
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord,
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis,
          },
        },
      };
    },
  };
};
const size$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const { placement, rects, platform: platform2, elements } = state;
      const { apply = () => {}, ...detectOverflowOptions } = evaluate(
        options,
        state,
      );
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const { width, height } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide =
          alignment ===
          ((await (platform2.isRTL == null
            ? void 0
            : platform2.isRTL(elements.floating)))
            ? "start"
            : "end")
            ? "left"
            : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(
        height - overflow[heightSide],
        maximumClippingHeight,
      );
      const overflowAvailableWidth = min(
        width - overflow[widthSide],
        maximumClippingWidth,
      );
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (
        (_state$middlewareData = state.middlewareData.shift) != null &&
        _state$middlewareData.enabled.x
      ) {
        availableWidth = maximumClippingWidth;
      }
      if (
        (_state$middlewareData2 = state.middlewareData.shift) != null &&
        _state$middlewareData2.enabled.y
      ) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth =
            width -
            2 *
              (xMin !== 0 || xMax !== 0
                ? xMin + xMax
                : max(overflow.left, overflow.right));
        } else {
          availableHeight =
            height -
            2 *
              (yMin !== 0 || yMax !== 0
                ? yMin + yMax
                : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight,
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true,
          },
        };
      }
      return {};
    },
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (
    (node == null || (_node$ownerDocument = node.ownerDocument) == null
      ? void 0
      : _node$ownerDocument.defaultView) || window
  );
}
function getDocumentElement(node) {
  var _ref;
  return (_ref =
    (isNode(node) ? node.ownerDocument : node.document) || window.document) ==
    null
    ? void 0
    : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return (
    value instanceof HTMLElement ||
    value instanceof getWindow(value).HTMLElement
  );
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return (
    value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot
  );
}
function isOverflowElement(element) {
  const { overflow, overflowX, overflowY, display } =
    getComputedStyle$1(element);
  return (
    /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) &&
    !["inline", "contents"].includes(display)
  );
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e3) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss)
    ? getComputedStyle$1(elementOrCss)
    : elementOrCss;
  return (
    ["transform", "translate", "scale", "rotate", "perspective"].some(
      (value) => (css[value] ? css[value] !== "none" : false),
    ) ||
    (css.containerType ? css.containerType !== "normal" : false) ||
    (!webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false)) ||
    (!webkit && (css.filter ? css.filter !== "none" : false)) ||
    ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(
      (value) => (css.willChange || "").includes(value),
    ) ||
    ["paint", "layout", "strict", "content"].some((value) =>
      (css.contain || "").includes(value),
    )
  );
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop,
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY,
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result =
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    (isShadowRoot(node) && node.host) || // Fallback.
    getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody =
    scrollableAncestor ===
    ((_node$ownerDocument2 = node.ownerDocument) == null
      ? void 0
      : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(
      win,
      win.visualViewport || [],
      isOverflowElement(scrollableAncestor) ? scrollableAncestor : [],
      frameElement && traverseIframes ? getOverflowAncestors(frameElement) : [],
    );
  }
  return list.concat(
    scrollableAncestor,
    getOverflowAncestors(scrollableAncestor, [], traverseIframes),
  );
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent)
    ? win.frameElement
    : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback =
    round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback,
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const { width, height, $: $2 } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2,
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop,
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (
    !floatingOffsetParent ||
    (isFixed && floatingOffsetParent !== getWindow(element))
  ) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(
  element,
  includeScale,
  isFixedStrategy,
  offsetParent,
) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(
    domElement,
    isFixedStrategy,
    offsetParent,
  )
    ? getVisualOffsets(domElement)
    : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin =
      offsetParent && isElement(offsetParent)
        ? getWindow(offsetParent)
        : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left =
        iframeRect.left +
        (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) *
          iframeScale.x;
      const top =
        iframeRect.top +
        (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2,
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 =
    htmlRect.left +
    scroll.scrollLeft -
    (ignoreScrollbarX
      ? 0
      : // RTL <body> scrollbar.
        getWindowScrollBarX(documentElement, htmlRect));
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2,
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let { elements, rect, offsetParent, strategy } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || (topLayer && isFixed)) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0,
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
    if (
      getNodeName(offsetParent) !== "body" ||
      isOverflowElement(documentElement)
    ) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset =
    documentElement && !isOffsetParentAnElement && !isFixed
      ? getHTMLOffset(documentElement, scroll, true)
      : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x:
      rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y,
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(
    html.scrollWidth,
    html.clientWidth,
    body.scrollWidth,
    body.clientWidth,
  );
  const height = max(
    html.scrollHeight,
    html.clientHeight,
    body.scrollHeight,
    body.clientHeight,
  );
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2,
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || (visualViewportBased && strategy === "fixed")) {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2,
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2,
  };
}
function getClientRectFromClippingAncestor(
  element,
  clippingAncestor,
  strategy,
) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height,
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (
    parentNode === stopNode ||
    !isElement(parentNode) ||
    isLastTraversableNode(parentNode)
  ) {
    return false;
  }
  return (
    getComputedStyle$1(parentNode).position === "fixed" ||
    hasFixedPositionAncestor(parentNode, stopNode)
  );
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter(
    (el) => isElement(el) && getNodeName(el) !== "body",
  );
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed
      ? !currentNodeIsContaining && !currentContainingBlockComputedStyle
      : (!currentNodeIsContaining &&
          computedStyle.position === "static" &&
          !!currentContainingBlockComputedStyle &&
          ["absolute", "fixed"].includes(
            currentContainingBlockComputedStyle.position,
          )) ||
        (isOverflowElement(currentNode) &&
          !currentNodeIsContaining &&
          hasFixedPositionAncestor(element, currentNode));
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let { element, boundary, rootBoundary, strategy } = _ref;
  const elementClippingAncestors =
    boundary === "clippingAncestors"
      ? isTopLayer(element)
        ? []
        : getClippingElementAncestors(element, this._c)
      : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce(
    (accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(
        element,
        clippingAncestor,
        strategy,
      );
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    },
    getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy),
  );
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top,
  };
}
function getDimensions(element) {
  const { width, height } = getCssDimensions(element);
  return {
    width,
    height,
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0,
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
    if (
      getNodeName(offsetParent) !== "body" ||
      isOverflowElement(documentElement)
    ) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(
        offsetParent,
        true,
        isFixed,
        offsetParent,
      );
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset =
    documentElement && !isOffsetParentAnElement && !isFixed
      ? getHTMLOffset(documentElement, scroll)
      : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height,
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill2) {
  if (
    !isHTMLElement(element) ||
    getComputedStyle$1(element).position === "fixed"
  ) {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill2) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill2);
  while (
    offsetParent &&
    isTableElement(offsetParent) &&
    isStaticPositioned(offsetParent)
  ) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill2);
  }
  if (
    offsetParent &&
    isLastTraversableNode(offsetParent) &&
    isStaticPositioned(offsetParent) &&
    !isContainingBlock(offsetParent)
  ) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function (data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(
      data.reference,
      await getOffsetParentFn(data.floating),
      data.strategy,
    ),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height,
    },
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL,
};
function rectsAreEqual(a2, b3) {
  return (
    a2.x === b3.x &&
    a2.y === b3.y &&
    a2.width === b3.width &&
    a2.height === b3.height
  );
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const { left, top, width, height } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin =
      -insetTop +
      "px " +
      -insetRight +
      "px " +
      -insetBottom +
      "px " +
      -insetLeft +
      "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1,
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (
        ratio === 1 &&
        !rectsAreEqual(
          elementRectForRootMargin,
          element.getBoundingClientRect(),
        )
      ) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument,
      });
    } catch (e3) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false,
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors =
    ancestorScroll || ancestorResize
      ? [
          ...(referenceEl ? getOverflowAncestors(referenceEl) : []),
          ...getOverflowAncestors(floating),
        ]
      : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll &&
      ancestor.addEventListener("scroll", update2, {
        passive: true,
      });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo =
    referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null ||
            _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null ||
      _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset = offset$1;
const shift = shift$1;
const flip$1 = flip$2;
const size = size$1;
const arrow = arrow$1;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options,
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache,
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache,
  });
};
function e$2(t2) {
  return i$1(t2);
}
function r$1(t2) {
  return t2.assignedSlot
    ? t2.assignedSlot
    : t2.parentNode instanceof ShadowRoot
      ? t2.parentNode.host
      : t2.parentNode;
}
function i$1(e3) {
  for (let t2 = e3; t2; t2 = r$1(t2))
    if (t2 instanceof Element && "none" === getComputedStyle(t2).display)
      return null;
  for (let n3 = r$1(e3); n3; n3 = r$1(n3)) {
    if (!(n3 instanceof Element)) continue;
    const e4 = getComputedStyle(n3);
    if ("contents" !== e4.display) {
      if ("static" !== e4.position || isContainingBlock(e4)) return n3;
      if ("BODY" === n3.tagName) return n3;
    }
  }
  return null;
}
function isVirtualElement(e3) {
  return (
    e3 !== null &&
    typeof e3 === "object" &&
    "getBoundingClientRect" in e3 &&
    ("contextElement" in e3 ? e3 instanceof Element : true)
  );
}
var SlPopup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.active = false;
    this.placement = "top";
    this.strategy = "absolute";
    this.distance = 0;
    this.skidding = 0;
    this.arrow = false;
    this.arrowPlacement = "anchor";
    this.arrowPadding = 10;
    this.flip = false;
    this.flipFallbackPlacements = "";
    this.flipFallbackStrategy = "best-fit";
    this.flipPadding = 0;
    this.shift = false;
    this.shiftPadding = 0;
    this.autoSizePadding = 0;
    this.hoverBridge = false;
    this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const anchorRect = this.anchorEl.getBoundingClientRect();
        const popupRect = this.popup.getBoundingClientRect();
        const isVertical =
          this.placement.includes("top") || this.placement.includes("bottom");
        let topLeftX = 0;
        let topLeftY = 0;
        let topRightX = 0;
        let topRightY = 0;
        let bottomLeftX = 0;
        let bottomLeftY = 0;
        let bottomRightX = 0;
        let bottomRightY = 0;
        if (isVertical) {
          if (anchorRect.top < popupRect.top) {
            topLeftX = anchorRect.left;
            topLeftY = anchorRect.bottom;
            topRightX = anchorRect.right;
            topRightY = anchorRect.bottom;
            bottomLeftX = popupRect.left;
            bottomLeftY = popupRect.top;
            bottomRightX = popupRect.right;
            bottomRightY = popupRect.top;
          } else {
            topLeftX = popupRect.left;
            topLeftY = popupRect.bottom;
            topRightX = popupRect.right;
            topRightY = popupRect.bottom;
            bottomLeftX = anchorRect.left;
            bottomLeftY = anchorRect.top;
            bottomRightX = anchorRect.right;
            bottomRightY = anchorRect.top;
          }
        } else {
          if (anchorRect.left < popupRect.left) {
            topLeftX = anchorRect.right;
            topLeftY = anchorRect.top;
            topRightX = popupRect.left;
            topRightY = popupRect.top;
            bottomLeftX = anchorRect.right;
            bottomLeftY = anchorRect.bottom;
            bottomRightX = popupRect.left;
            bottomRightY = popupRect.bottom;
          } else {
            topLeftX = popupRect.right;
            topLeftY = popupRect.top;
            topRightX = anchorRect.left;
            topRightY = anchorRect.top;
            bottomLeftX = popupRect.right;
            bottomLeftY = popupRect.bottom;
            bottomRightX = anchorRect.left;
            bottomRightY = anchorRect.bottom;
          }
        }
        this.style.setProperty("--hover-bridge-top-left-x", `${topLeftX}px`);
        this.style.setProperty("--hover-bridge-top-left-y", `${topLeftY}px`);
        this.style.setProperty("--hover-bridge-top-right-x", `${topRightX}px`);
        this.style.setProperty("--hover-bridge-top-right-y", `${topRightY}px`);
        this.style.setProperty(
          "--hover-bridge-bottom-left-x",
          `${bottomLeftX}px`,
        );
        this.style.setProperty(
          "--hover-bridge-bottom-left-y",
          `${bottomLeftY}px`,
        );
        this.style.setProperty(
          "--hover-bridge-bottom-right-x",
          `${bottomRightX}px`,
        );
        this.style.setProperty(
          "--hover-bridge-bottom-right-y",
          `${bottomRightY}px`,
        );
      }
    };
  }
  async connectedCallback() {
    super.connectedCallback();
    await this.updateComplete;
    this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stop();
  }
  async updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("active")) {
      if (this.active) {
        this.start();
      } else {
        this.stop();
      }
    }
    if (changedProps.has("anchor")) {
      this.handleAnchorChange();
    }
    if (this.active) {
      await this.updateComplete;
      this.reposition();
    }
  }
  async handleAnchorChange() {
    await this.stop();
    if (this.anchor && typeof this.anchor === "string") {
      const root = this.getRootNode();
      this.anchorEl = root.getElementById(this.anchor);
    } else if (
      this.anchor instanceof Element ||
      isVirtualElement(this.anchor)
    ) {
      this.anchorEl = this.anchor;
    } else {
      this.anchorEl = this.querySelector('[slot="anchor"]');
    }
    if (this.anchorEl instanceof HTMLSlotElement) {
      this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];
    }
    if (this.anchorEl && this.active) {
      this.start();
    }
  }
  start() {
    if (!this.anchorEl || !this.active) {
      return;
    }
    this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {
      this.reposition();
    });
  }
  async stop() {
    return new Promise((resolve) => {
      if (this.cleanup) {
        this.cleanup();
        this.cleanup = void 0;
        this.removeAttribute("data-current-placement");
        this.style.removeProperty("--auto-size-available-width");
        this.style.removeProperty("--auto-size-available-height");
        requestAnimationFrame(() => resolve());
      } else {
        resolve();
      }
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl) {
      return;
    }
    const middleware = [
      // The offset middleware goes first
      offset({ mainAxis: this.distance, crossAxis: this.skidding }),
    ];
    if (this.sync) {
      middleware.push(
        size({
          apply: ({ rects }) => {
            const syncWidth = this.sync === "width" || this.sync === "both";
            const syncHeight = this.sync === "height" || this.sync === "both";
            this.popup.style.width = syncWidth
              ? `${rects.reference.width}px`
              : "";
            this.popup.style.height = syncHeight
              ? `${rects.reference.height}px`
              : "";
          },
        }),
      );
    } else {
      this.popup.style.width = "";
      this.popup.style.height = "";
    }
    if (this.flip) {
      middleware.push(
        flip$1({
          boundary: this.flipBoundary,
          // @ts-expect-error - We're converting a string attribute to an array here
          fallbackPlacements: this.flipFallbackPlacements,
          fallbackStrategy:
            this.flipFallbackStrategy === "best-fit"
              ? "bestFit"
              : "initialPlacement",
          padding: this.flipPadding,
        }),
      );
    }
    if (this.shift) {
      middleware.push(
        shift({
          boundary: this.shiftBoundary,
          padding: this.shiftPadding,
        }),
      );
    }
    if (this.autoSize) {
      middleware.push(
        size({
          boundary: this.autoSizeBoundary,
          padding: this.autoSizePadding,
          apply: ({ availableWidth, availableHeight }) => {
            if (this.autoSize === "vertical" || this.autoSize === "both") {
              this.style.setProperty(
                "--auto-size-available-height",
                `${availableHeight}px`,
              );
            } else {
              this.style.removeProperty("--auto-size-available-height");
            }
            if (this.autoSize === "horizontal" || this.autoSize === "both") {
              this.style.setProperty(
                "--auto-size-available-width",
                `${availableWidth}px`,
              );
            } else {
              this.style.removeProperty("--auto-size-available-width");
            }
          },
        }),
      );
    } else {
      this.style.removeProperty("--auto-size-available-width");
      this.style.removeProperty("--auto-size-available-height");
    }
    if (this.arrow) {
      middleware.push(
        arrow({
          element: this.arrowEl,
          padding: this.arrowPadding,
        }),
      );
    }
    const getOffsetParent2 =
      this.strategy === "absolute"
        ? (element) => platform.getOffsetParent(element, e$2)
        : platform.getOffsetParent;
    computePosition(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware,
      strategy: this.strategy,
      platform: __spreadProps(__spreadValues({}, platform), {
        getOffsetParent: getOffsetParent2,
      }),
    }).then(({ x: x2, y: y2, middlewareData, placement }) => {
      const isRtl = this.localize.dir() === "rtl";
      const staticSide = {
        top: "bottom",
        right: "left",
        bottom: "top",
        left: "right",
      }[placement.split("-")[0]];
      this.setAttribute("data-current-placement", placement);
      Object.assign(this.popup.style, {
        left: `${x2}px`,
        top: `${y2}px`,
      });
      if (this.arrow) {
        const arrowX = middlewareData.arrow.x;
        const arrowY = middlewareData.arrow.y;
        let top = "";
        let right = "";
        let bottom = "";
        let left = "";
        if (this.arrowPlacement === "start") {
          const value =
            typeof arrowX === "number"
              ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))`
              : "";
          top =
            typeof arrowY === "number"
              ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))`
              : "";
          right = isRtl ? value : "";
          left = isRtl ? "" : value;
        } else if (this.arrowPlacement === "end") {
          const value =
            typeof arrowX === "number"
              ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))`
              : "";
          right = isRtl ? "" : value;
          left = isRtl ? value : "";
          bottom =
            typeof arrowY === "number"
              ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))`
              : "";
        } else if (this.arrowPlacement === "center") {
          left =
            typeof arrowX === "number"
              ? `calc(50% - var(--arrow-size-diagonal))`
              : "";
          top =
            typeof arrowY === "number"
              ? `calc(50% - var(--arrow-size-diagonal))`
              : "";
        } else {
          left = typeof arrowX === "number" ? `${arrowX}px` : "";
          top = typeof arrowY === "number" ? `${arrowY}px` : "";
        }
        Object.assign(this.arrowEl.style, {
          top,
          right,
          bottom,
          left,
          [staticSide]: "calc(var(--arrow-size-diagonal) * -1)",
        });
      }
    });
    requestAnimationFrame(() => this.updateHoverBridge());
    this.emit("sl-reposition");
  }
  render() {
    return x$2`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${e$4({
          "popup-hover-bridge": true,
          "popup-hover-bridge--visible": this.hoverBridge && this.active,
        })}
      ></span>

      <div
        part="popup"
        class=${e$4({
          popup: true,
          "popup--active": this.active,
          "popup--fixed": this.strategy === "fixed",
          "popup--has-arrow": this.arrow,
        })}
      >
        <slot></slot>
        ${this.arrow ? x$2`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
SlPopup.styles = [component_styles_default, popup_styles_default];
__decorateClass([e$8(".popup")], SlPopup.prototype, "popup", 2);
__decorateClass([e$8(".popup__arrow")], SlPopup.prototype, "arrowEl", 2);
__decorateClass([n$6()], SlPopup.prototype, "anchor", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlPopup.prototype,
  "active",
  2,
);
__decorateClass([n$6({ reflect: true })], SlPopup.prototype, "placement", 2);
__decorateClass([n$6({ reflect: true })], SlPopup.prototype, "strategy", 2);
__decorateClass([n$6({ type: Number })], SlPopup.prototype, "distance", 2);
__decorateClass([n$6({ type: Number })], SlPopup.prototype, "skidding", 2);
__decorateClass([n$6({ type: Boolean })], SlPopup.prototype, "arrow", 2);
__decorateClass(
  [n$6({ attribute: "arrow-placement" })],
  SlPopup.prototype,
  "arrowPlacement",
  2,
);
__decorateClass(
  [n$6({ attribute: "arrow-padding", type: Number })],
  SlPopup.prototype,
  "arrowPadding",
  2,
);
__decorateClass([n$6({ type: Boolean })], SlPopup.prototype, "flip", 2);
__decorateClass(
  [
    n$6({
      attribute: "flip-fallback-placements",
      converter: {
        fromAttribute: (value) => {
          return value
            .split(" ")
            .map((p2) => p2.trim())
            .filter((p2) => p2 !== "");
        },
        toAttribute: (value) => {
          return value.join(" ");
        },
      },
    }),
  ],
  SlPopup.prototype,
  "flipFallbackPlacements",
  2,
);
__decorateClass(
  [n$6({ attribute: "flip-fallback-strategy" })],
  SlPopup.prototype,
  "flipFallbackStrategy",
  2,
);
__decorateClass([n$6({ type: Object })], SlPopup.prototype, "flipBoundary", 2);
__decorateClass(
  [n$6({ attribute: "flip-padding", type: Number })],
  SlPopup.prototype,
  "flipPadding",
  2,
);
__decorateClass([n$6({ type: Boolean })], SlPopup.prototype, "shift", 2);
__decorateClass([n$6({ type: Object })], SlPopup.prototype, "shiftBoundary", 2);
__decorateClass(
  [n$6({ attribute: "shift-padding", type: Number })],
  SlPopup.prototype,
  "shiftPadding",
  2,
);
__decorateClass(
  [n$6({ attribute: "auto-size" })],
  SlPopup.prototype,
  "autoSize",
  2,
);
__decorateClass([n$6()], SlPopup.prototype, "sync", 2);
__decorateClass(
  [n$6({ type: Object })],
  SlPopup.prototype,
  "autoSizeBoundary",
  2,
);
__decorateClass(
  [n$6({ attribute: "auto-size-padding", type: Number })],
  SlPopup.prototype,
  "autoSizePadding",
  2,
);
__decorateClass(
  [n$6({ attribute: "hover-bridge", type: Boolean })],
  SlPopup.prototype,
  "hoverBridge",
  2,
);
var defaultAnimationRegistry = /* @__PURE__ */ new Map();
var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(animation) {
  return animation != null
    ? animation
    : { keyframes: [], options: { duration: 0 } };
}
function getLogicalAnimation(animation, dir) {
  if (dir.toLowerCase() === "rtl") {
    return {
      keyframes: animation.rtlKeyframes || animation.keyframes,
      options: animation.options,
    };
  }
  return animation;
}
function setDefaultAnimation(animationName, animation) {
  defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
}
function getAnimation(el, animationName, options) {
  const customAnimation = customAnimationRegistry.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return getLogicalAnimation(customAnimation[animationName], options.dir);
  }
  const defaultAnimation = defaultAnimationRegistry.get(animationName);
  if (defaultAnimation) {
    return getLogicalAnimation(defaultAnimation, options.dir);
  }
  return {
    keyframes: [],
    options: { duration: 0 },
  };
}
function waitForEvent(el, eventName) {
  return new Promise((resolve) => {
    function done(event) {
      if (event.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}
function animateTo(el, keyframes, options) {
  return new Promise((resolve) => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(
      keyframes,
      __spreadProps(__spreadValues({}, options), {
        duration: prefersReducedMotion() ? 0 : options.duration,
      }),
    );
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function parseDuration(delay) {
  delay = delay.toString().toLowerCase();
  if (delay.indexOf("ms") > -1) {
    return parseFloat(delay);
  }
  if (delay.indexOf("s") > -1) {
    return parseFloat(delay) * 1e3;
  }
  return parseFloat(delay);
}
function prefersReducedMotion() {
  const query = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query.matches;
}
function stopAnimations(el) {
  return Promise.all(
    el.getAnimations().map((animation) => {
      return new Promise((resolve) => {
        animation.cancel();
        requestAnimationFrame(resolve);
      });
    }),
  );
}
function shimKeyframesHeightAuto(keyframes, calculatedHeight) {
  return keyframes.map((keyframe) =>
    __spreadProps(__spreadValues({}, keyframe), {
      height:
        keyframe.height === "auto" ? `${calculatedHeight}px` : keyframe.height,
    }),
  );
}
var SlTooltip = class extends ShoelaceElement {
  constructor() {
    super();
    this.localize = new LocalizeController2(this);
    this.content = "";
    this.placement = "top";
    this.disabled = false;
    this.distance = 8;
    this.open = false;
    this.skidding = 0;
    this.trigger = "hover focus";
    this.hoist = false;
    this.handleBlur = () => {
      if (this.hasTrigger("focus")) {
        this.hide();
      }
    };
    this.handleClick = () => {
      if (this.hasTrigger("click")) {
        if (this.open) {
          this.hide();
        } else {
          this.show();
        }
      }
    };
    this.handleFocus = () => {
      if (this.hasTrigger("focus")) {
        this.show();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      if (event.key === "Escape") {
        event.stopPropagation();
        this.hide();
      }
    };
    this.handleMouseOver = () => {
      if (this.hasTrigger("hover")) {
        const delay = parseDuration(
          getComputedStyle(this).getPropertyValue("--show-delay"),
        );
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = window.setTimeout(() => this.show(), delay);
      }
    };
    this.handleMouseOut = () => {
      if (this.hasTrigger("hover")) {
        const delay = parseDuration(
          getComputedStyle(this).getPropertyValue("--hide-delay"),
        );
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = window.setTimeout(() => this.hide(), delay);
      }
    };
    this.addEventListener("blur", this.handleBlur, true);
    this.addEventListener("focus", this.handleFocus, true);
    this.addEventListener("click", this.handleClick);
    this.addEventListener("mouseover", this.handleMouseOver);
    this.addEventListener("mouseout", this.handleMouseOut);
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback();
    (_a2 = this.closeWatcher) == null ? void 0 : _a2.destroy();
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  firstUpdated() {
    this.body.hidden = !this.open;
    if (this.open) {
      this.popup.active = true;
      this.popup.reposition();
    }
  }
  hasTrigger(triggerType) {
    const triggers = this.trigger.split(" ");
    return triggers.includes(triggerType);
  }
  async handleOpenChange() {
    var _a2, _b2;
    if (this.open) {
      if (this.disabled) {
        return;
      }
      this.emit("sl-show");
      if ("CloseWatcher" in window) {
        (_a2 = this.closeWatcher) == null ? void 0 : _a2.destroy();
        this.closeWatcher = new CloseWatcher();
        this.closeWatcher.onclose = () => {
          this.hide();
        };
      } else {
        document.addEventListener("keydown", this.handleDocumentKeyDown);
      }
      await stopAnimations(this.body);
      this.body.hidden = false;
      this.popup.active = true;
      const { keyframes, options } = getAnimation(this, "tooltip.show", {
        dir: this.localize.dir(),
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.popup.reposition();
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      (_b2 = this.closeWatcher) == null ? void 0 : _b2.destroy();
      document.removeEventListener("keydown", this.handleDocumentKeyDown);
      await stopAnimations(this.body);
      const { keyframes, options } = getAnimation(this, "tooltip.hide", {
        dir: this.localize.dir(),
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.popup.active = false;
      this.body.hidden = true;
      this.emit("sl-after-hide");
    }
  }
  async handleOptionsChange() {
    if (this.hasUpdated) {
      await this.updateComplete;
      this.popup.reposition();
    }
  }
  handleDisabledChange() {
    if (this.disabled && this.open) {
      this.hide();
    }
  }
  /** Shows the tooltip. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the tooltip */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  //
  // NOTE: Tooltip is a bit unique in that we're using aria-live instead of aria-labelledby to trick screen readers into
  // announcing the content. It works really well, but it violates an accessibility rule. We're also adding the
  // aria-describedby attribute to a slot, which is required by <sl-popup> to correctly locate the first assigned
  // element, otherwise positioning is incorrect.
  //
  render() {
    return x$2`
      <sl-popup
        part="base"
        exportparts="
          popup:base__popup,
          arrow:base__arrow
        "
        class=${e$4({
          tooltip: true,
          "tooltip--open": this.open,
        })}
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        arrow
        hover-bridge
      >
        ${""}
        <slot slot="anchor" aria-describedby="tooltip"></slot>

        ${""}
        <div part="body" id="tooltip" class="tooltip__body" role="tooltip" aria-live=${this.open ? "polite" : "off"}>
          <slot name="content">${this.content}</slot>
        </div>
      </sl-popup>
    `;
  }
};
SlTooltip.styles = [component_styles_default, tooltip_styles_default];
SlTooltip.dependencies = { "sl-popup": SlPopup };
__decorateClass(
  [e$8("slot:not([name])")],
  SlTooltip.prototype,
  "defaultSlot",
  2,
);
__decorateClass([e$8(".tooltip__body")], SlTooltip.prototype, "body", 2);
__decorateClass([e$8("sl-popup")], SlTooltip.prototype, "popup", 2);
__decorateClass([n$6()], SlTooltip.prototype, "content", 2);
__decorateClass([n$6()], SlTooltip.prototype, "placement", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlTooltip.prototype,
  "disabled",
  2,
);
__decorateClass([n$6({ type: Number })], SlTooltip.prototype, "distance", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlTooltip.prototype,
  "open",
  2,
);
__decorateClass([n$6({ type: Number })], SlTooltip.prototype, "skidding", 2);
__decorateClass([n$6()], SlTooltip.prototype, "trigger", 2);
__decorateClass([n$6({ type: Boolean })], SlTooltip.prototype, "hoist", 2);
__decorateClass(
  [watch("open", { waitUntilFirstUpdate: true })],
  SlTooltip.prototype,
  "handleOpenChange",
  1,
);
__decorateClass(
  [watch(["content", "distance", "hoist", "placement", "skidding"])],
  SlTooltip.prototype,
  "handleOptionsChange",
  1,
);
__decorateClass(
  [watch("disabled")],
  SlTooltip.prototype,
  "handleDisabledChange",
  1,
);
setDefaultAnimation("tooltip.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 },
  ],
  options: { duration: 150, easing: "ease" },
});
setDefaultAnimation("tooltip.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 },
  ],
  options: { duration: 150, easing: "ease" },
});
var tagName$Q = "sl-tooltip";
SlTooltip.define("sl-tooltip");
var reactWrapper$g = o$8({
  tagName: tagName$Q,
  elementClass: SlTooltip,
  react: React,
  events: {
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide",
  },
  displayName: "SlTooltip",
});
var tooltip_default = reactWrapper$g;
var textarea_styles_default = i$8`
  :host {
    display: block;
  }

  .textarea {
    display: grid;
    align-items: center;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
    cursor: text;
  }

  /* Standard textareas */
  .textarea--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .textarea--standard:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }
  .textarea--standard:hover:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-hover);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    color: var(--sl-input-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-focus);
  }

  .textarea--standard.textarea--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea__control,
  .textarea__size-adjuster {
    grid-area: 1 / 1 / 2 / 2;
  }

  .textarea__size-adjuster {
    visibility: hidden;
    pointer-events: none;
    opacity: 0;
  }

  .textarea--standard.textarea--disabled .textarea__control {
    color: var(--sl-input-color-disabled);
  }

  .textarea--standard.textarea--disabled .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled textareas */
  .textarea--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .textarea--filled:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .textarea--filled.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .textarea--filled.textarea--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea__control {
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    line-height: 1.4;
    color: var(--sl-input-color);
    border: none;
    background: none;
    box-shadow: none;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .textarea__control::-webkit-search-decoration,
  .textarea__control::-webkit-search-cancel-button,
  .textarea__control::-webkit-search-results-button,
  .textarea__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .textarea__control:focus {
    outline: none;
  }

  /*
   * Size modifiers
   */

  .textarea--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
  }

  .textarea--small .textarea__control {
    padding: 0.5em var(--sl-input-spacing-small);
  }

  .textarea--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .textarea--medium .textarea__control {
    padding: 0.5em var(--sl-input-spacing-medium);
  }

  .textarea--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
  }

  .textarea--large .textarea__control {
    padding: 0.5em var(--sl-input-spacing-large);
  }

  /*
   * Resize types
   */

  .textarea--resize-none .textarea__control {
    resize: none;
  }

  .textarea--resize-vertical .textarea__control {
    resize: vertical;
  }

  .textarea--resize-auto .textarea__control {
    height: auto;
    resize: none;
    overflow-y: hidden;
  }
`;
var SlTextarea = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"],
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.value = "";
    this.size = "medium";
    this.filled = false;
    this.label = "";
    this.helpText = "";
    this.placeholder = "";
    this.rows = 4;
    this.resize = "vertical";
    this.disabled = false;
    this.readonly = false;
    this.form = "";
    this.required = false;
    this.spellcheck = true;
    this.defaultValue = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => this.setTextareaHeight());
    this.updateComplete.then(() => {
      this.setTextareaHeight();
      this.resizeObserver.observe(this.input);
    });
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback();
    if (this.input) {
      (_a2 = this.resizeObserver) == null ? void 0 : _a2.unobserve(this.input);
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    this.setTextareaHeight();
    this.emit("sl-change");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  setTextareaHeight() {
    if (this.resize === "auto") {
      this.sizeAdjuster.style.height = `${this.input.clientHeight}px`;
      this.input.style.height = "auto";
      this.input.style.height = `${this.input.scrollHeight}px`;
    } else {
      this.input.style.height = "";
    }
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleRowsChange() {
    this.setTextareaHeight();
  }
  async handleValueChange() {
    await this.updateComplete;
    this.formControlController.updateValidity();
    this.setTextareaHeight();
  }
  /** Sets focus on the textarea. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the textarea. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the textarea. */
  select() {
    this.input.select();
  }
  /** Gets or sets the textarea's scroll position. */
  scrollPosition(position) {
    if (position) {
      if (typeof position.top === "number") this.input.scrollTop = position.top;
      if (typeof position.left === "number")
        this.input.scrollLeft = position.left;
      return void 0;
    }
    return {
      top: this.input.scrollTop,
      left: this.input.scrollTop,
    };
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(
      selectionStart,
      selectionEnd,
      selectionDirection,
    );
  }
  /** Replaces a range of text with a new string. */
  setRangeText(replacement, start, end, selectMode = "preserve") {
    const selectionStart = start != null ? start : this.input.selectionStart;
    const selectionEnd = end != null ? end : this.input.selectionEnd;
    this.input.setRangeText(
      replacement,
      selectionStart,
      selectionEnd,
      selectMode,
    );
    if (this.value !== this.input.value) {
      this.value = this.input.value;
      this.setTextareaHeight();
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return x$2`
      <div
        part="form-control"
        class=${e$4({
          "form-control": true,
          "form-control--small": this.size === "small",
          "form-control--medium": this.size === "medium",
          "form-control--large": this.size === "large",
          "form-control--has-label": hasLabel,
          "form-control--has-help-text": hasHelpText,
        })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e$4({
              textarea: true,
              "textarea--small": this.size === "small",
              "textarea--medium": this.size === "medium",
              "textarea--large": this.size === "large",
              "textarea--standard": !this.filled,
              "textarea--filled": this.filled,
              "textarea--disabled": this.disabled,
              "textarea--focused": this.hasFocus,
              "textarea--empty": !this.value,
              "textarea--resize-none": this.resize === "none",
              "textarea--resize-vertical": this.resize === "vertical",
              "textarea--resize-auto": this.resize === "auto",
            })}
          >
            <textarea
              part="textarea"
              id="input"
              class="textarea__control"
              title=${this.title}
              name=${o$7(this.name)}
              .value=${l$1(this.value)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${o$7(this.placeholder)}
              rows=${o$7(this.rows)}
              minlength=${o$7(this.minlength)}
              maxlength=${o$7(this.maxlength)}
              autocapitalize=${o$7(this.autocapitalize)}
              autocorrect=${o$7(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${o$7(this.spellcheck)}
              enterkeyhint=${o$7(this.enterkeyhint)}
              inputmode=${o$7(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            ></textarea>
            <!-- This "adjuster" exists to prevent layout shifting. https://github.com/shoelace-style/shoelace/issues/2180 -->
            <div part="textarea-adjuster" class="textarea__size-adjuster" ?hidden=${this.resize !== "auto"}></div>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlTextarea.styles = [
  component_styles_default,
  form_control_styles_default,
  textarea_styles_default,
];
__decorateClass([e$8(".textarea__control")], SlTextarea.prototype, "input", 2);
__decorateClass(
  [e$8(".textarea__size-adjuster")],
  SlTextarea.prototype,
  "sizeAdjuster",
  2,
);
__decorateClass([r$4()], SlTextarea.prototype, "hasFocus", 2);
__decorateClass([n$6()], SlTextarea.prototype, "title", 2);
__decorateClass([n$6()], SlTextarea.prototype, "name", 2);
__decorateClass([n$6()], SlTextarea.prototype, "value", 2);
__decorateClass([n$6({ reflect: true })], SlTextarea.prototype, "size", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlTextarea.prototype,
  "filled",
  2,
);
__decorateClass([n$6()], SlTextarea.prototype, "label", 2);
__decorateClass(
  [n$6({ attribute: "help-text" })],
  SlTextarea.prototype,
  "helpText",
  2,
);
__decorateClass([n$6()], SlTextarea.prototype, "placeholder", 2);
__decorateClass([n$6({ type: Number })], SlTextarea.prototype, "rows", 2);
__decorateClass([n$6()], SlTextarea.prototype, "resize", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlTextarea.prototype,
  "disabled",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlTextarea.prototype,
  "readonly",
  2,
);
__decorateClass([n$6({ reflect: true })], SlTextarea.prototype, "form", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlTextarea.prototype,
  "required",
  2,
);
__decorateClass([n$6({ type: Number })], SlTextarea.prototype, "minlength", 2);
__decorateClass([n$6({ type: Number })], SlTextarea.prototype, "maxlength", 2);
__decorateClass([n$6()], SlTextarea.prototype, "autocapitalize", 2);
__decorateClass([n$6()], SlTextarea.prototype, "autocorrect", 2);
__decorateClass([n$6()], SlTextarea.prototype, "autocomplete", 2);
__decorateClass([n$6({ type: Boolean })], SlTextarea.prototype, "autofocus", 2);
__decorateClass([n$6()], SlTextarea.prototype, "enterkeyhint", 2);
__decorateClass(
  [
    n$6({
      type: Boolean,
      converter: {
        // Allow "true|false" attribute values but keep the property boolean
        fromAttribute: (value) => (!value || value === "false" ? false : true),
        toAttribute: (value) => (value ? "true" : "false"),
      },
    }),
  ],
  SlTextarea.prototype,
  "spellcheck",
  2,
);
__decorateClass([n$6()], SlTextarea.prototype, "inputmode", 2);
__decorateClass([defaultValue()], SlTextarea.prototype, "defaultValue", 2);
__decorateClass(
  [watch("disabled", { waitUntilFirstUpdate: true })],
  SlTextarea.prototype,
  "handleDisabledChange",
  1,
);
__decorateClass(
  [watch("rows", { waitUntilFirstUpdate: true })],
  SlTextarea.prototype,
  "handleRowsChange",
  1,
);
__decorateClass(
  [watch("value", { waitUntilFirstUpdate: true })],
  SlTextarea.prototype,
  "handleValueChange",
  1,
);
var tagName$P = "sl-textarea";
SlTextarea.define("sl-textarea");
o$8({
  tagName: tagName$P,
  elementClass: SlTextarea,
  react: React,
  events: {
    onSlBlur: "sl-blur",
    onSlChange: "sl-change",
    onSlFocus: "sl-focus",
    onSlInput: "sl-input",
    onSlInvalid: "sl-invalid",
  },
  displayName: "SlTextarea",
});
var tree_styles_default = i$8`
  :host {
    /*
     * These are actually used by tree item, but we define them here so they can more easily be set and all tree items
     * stay consistent.
     */
    --indent-guide-color: var(--sl-color-neutral-200);
    --indent-guide-offset: 0;
    --indent-guide-style: solid;
    --indent-guide-width: 0;
    --indent-size: var(--sl-spacing-large);

    display: block;

    /*
     * Tree item indentation uses the "em" unit to increment its width on each level, so setting the font size to zero
     * here removes the indentation for all the nodes on the first level.
     */
    font-size: 0;
  }
`;
var tree_item_styles_default = i$8`
  :host {
    display: block;
    outline: 0;
    z-index: 0;
  }

  :host(:focus) {
    outline: none;
  }

  slot:not([name])::slotted(sl-icon) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .tree-item {
    position: relative;
    display: flex;
    align-items: stretch;
    flex-direction: column;
    color: var(--sl-color-neutral-700);
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
  }

  .tree-item__checkbox {
    pointer-events: none;
  }

  .tree-item__expand-button,
  .tree-item__checkbox,
  .tree-item__label {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-dense);
    letter-spacing: var(--sl-letter-spacing-normal);
  }

  .tree-item__checkbox::part(base) {
    display: flex;
    align-items: center;
  }

  .tree-item__indentation {
    display: block;
    width: 1em;
    flex-shrink: 0;
  }

  .tree-item__expand-button {
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: content-box;
    color: var(--sl-color-neutral-500);
    padding: var(--sl-spacing-x-small);
    width: 1rem;
    height: 1rem;
    flex-shrink: 0;
    cursor: pointer;
  }

  .tree-item__expand-button {
    transition: var(--sl-transition-medium) rotate ease;
  }

  .tree-item--expanded .tree-item__expand-button {
    rotate: 90deg;
  }

  .tree-item--expanded.tree-item--rtl .tree-item__expand-button {
    rotate: -90deg;
  }

  .tree-item--expanded slot[name='expand-icon'],
  .tree-item:not(.tree-item--expanded) slot[name='collapse-icon'] {
    display: none;
  }

  .tree-item:not(.tree-item--has-expand-button) .tree-item__expand-icon-slot {
    display: none;
  }

  .tree-item__expand-button--visible {
    cursor: pointer;
  }

  .tree-item__item {
    display: flex;
    align-items: center;
    border-inline-start: solid 3px transparent;
  }

  .tree-item--disabled .tree-item__item {
    opacity: 0.5;
    outline: none;
    cursor: not-allowed;
  }

  :host(:focus-visible) .tree-item__item {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
    z-index: 2;
  }

  :host(:not([aria-disabled='true'])) .tree-item--selected .tree-item__item {
    background-color: var(--sl-color-neutral-100);
    border-inline-start-color: var(--sl-color-primary-600);
  }

  :host(:not([aria-disabled='true'])) .tree-item__expand-button {
    color: var(--sl-color-neutral-600);
  }

  .tree-item__label {
    display: flex;
    align-items: center;
    transition: var(--sl-transition-fast) color;
  }

  .tree-item__children {
    display: block;
    font-size: calc(1em + var(--indent-size, var(--sl-spacing-medium)));
  }

  /* Indentation lines */
  .tree-item__children {
    position: relative;
  }

  .tree-item__children::before {
    content: '';
    position: absolute;
    top: var(--indent-guide-offset);
    bottom: var(--indent-guide-offset);
    left: calc(1em - (var(--indent-guide-width) / 2) - 1px);
    border-inline-end: var(--indent-guide-width) var(--indent-guide-style) var(--indent-guide-color);
    z-index: 1;
  }

  .tree-item--rtl .tree-item__children::before {
    left: auto;
    right: 1em;
  }

  @media (forced-colors: active) {
    :host(:not([aria-disabled='true'])) .tree-item--selected .tree-item__item {
      outline: dashed 1px SelectedItem;
    }
  }
`;
var checkbox_styles_default = i$8`
  :host {
    display: inline-block;
  }

  .checkbox {
    position: relative;
    display: inline-flex;
    align-items: flex-start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .checkbox--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .checkbox--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .checkbox--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .checkbox__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 2px;
    background-color: var(--sl-input-background-color);
    color: var(--sl-color-neutral-0);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .checkbox__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  .checkbox__checked-icon,
  .checkbox__indeterminate-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  /* Hover */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked/indeterminate */
  .checkbox--checked .checkbox__control,
  .checkbox--indeterminate .checkbox__control {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked/indeterminate + hover */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__control:hover,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked/indeterminate + focus */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .checkbox--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .checkbox__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .checkbox__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }
`;
var SlCheckbox = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      value: (control) => (control.checked ? control.value || "on" : void 0),
      defaultValue: (control) => control.defaultChecked,
      setValue: (control, checked) => (control.checked = checked),
    });
    this.hasSlotController = new HasSlotController(this, "help-text");
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.size = "medium";
    this.disabled = false;
    this.checked = false;
    this.indeterminate = false;
    this.defaultChecked = false;
    this.form = "";
    this.required = false;
    this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleClick() {
    this.checked = !this.checked;
    this.indeterminate = false;
    this.emit("sl-change");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStateChange() {
    this.input.checked = this.checked;
    this.input.indeterminate = this.indeterminate;
    this.formControlController.updateValidity();
  }
  /** Simulates a click on the checkbox. */
  click() {
    this.input.click();
  }
  /** Sets focus on the checkbox. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the checkbox. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /**
   * Sets a custom validation message. The value provided will be shown to the user when the form is submitted. To clear
   * the custom validation message, call this method with an empty string.
   */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return x$2`
      <div
        class=${e$4({
          "form-control": true,
          "form-control--small": this.size === "small",
          "form-control--medium": this.size === "medium",
          "form-control--large": this.size === "large",
          "form-control--has-help-text": hasHelpText,
        })}
      >
        <label
          part="base"
          class=${e$4({
            checkbox: true,
            "checkbox--checked": this.checked,
            "checkbox--disabled": this.disabled,
            "checkbox--focused": this.hasFocus,
            "checkbox--indeterminate": this.indeterminate,
            "checkbox--small": this.size === "small",
            "checkbox--medium": this.size === "medium",
            "checkbox--large": this.size === "large",
          })}
        >
          <input
            class="checkbox__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${o$7(this.value)}
            .indeterminate=${l$1(this.indeterminate)}
            .checked=${l$1(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
          />

          <span
            part="control${this.checked ? " control--checked" : ""}${this.indeterminate ? " control--indeterminate" : ""}"
            class="checkbox__control"
          >
            ${
              this.checked
                ? x$2`
                  <sl-icon part="checked-icon" class="checkbox__checked-icon" library="system" name="check"></sl-icon>
                `
                : ""
            }
            ${
              !this.checked && this.indeterminate
                ? x$2`
                  <sl-icon
                    part="indeterminate-icon"
                    class="checkbox__indeterminate-icon"
                    library="system"
                    name="indeterminate"
                  ></sl-icon>
                `
                : ""
            }
          </span>

          <div part="label" class="checkbox__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${hasHelpText ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlCheckbox.styles = [
  component_styles_default,
  form_control_styles_default,
  checkbox_styles_default,
];
SlCheckbox.dependencies = { "sl-icon": SlIcon };
__decorateClass(
  [e$8('input[type="checkbox"]')],
  SlCheckbox.prototype,
  "input",
  2,
);
__decorateClass([r$4()], SlCheckbox.prototype, "hasFocus", 2);
__decorateClass([n$6()], SlCheckbox.prototype, "title", 2);
__decorateClass([n$6()], SlCheckbox.prototype, "name", 2);
__decorateClass([n$6()], SlCheckbox.prototype, "value", 2);
__decorateClass([n$6({ reflect: true })], SlCheckbox.prototype, "size", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlCheckbox.prototype,
  "disabled",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlCheckbox.prototype,
  "checked",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlCheckbox.prototype,
  "indeterminate",
  2,
);
__decorateClass(
  [defaultValue("checked")],
  SlCheckbox.prototype,
  "defaultChecked",
  2,
);
__decorateClass([n$6({ reflect: true })], SlCheckbox.prototype, "form", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlCheckbox.prototype,
  "required",
  2,
);
__decorateClass(
  [n$6({ attribute: "help-text" })],
  SlCheckbox.prototype,
  "helpText",
  2,
);
__decorateClass(
  [watch("disabled", { waitUntilFirstUpdate: true })],
  SlCheckbox.prototype,
  "handleDisabledChange",
  1,
);
__decorateClass(
  [watch(["checked", "indeterminate"], { waitUntilFirstUpdate: true })],
  SlCheckbox.prototype,
  "handleStateChange",
  1,
);
var spinner_styles_default = i$8`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`;
var SlSpinner = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
  }
  render() {
    return x$2`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner.styles = [component_styles_default, spinner_styles_default];
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function n$3(n3, r3, t2) {
  return n3 ? r3(n3) : t2 == null ? void 0 : t2(n3);
}
var _SlTreeItem = class _SlTreeItem2 extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.indeterminate = false;
    this.isLeaf = false;
    this.loading = false;
    this.selectable = false;
    this.expanded = false;
    this.selected = false;
    this.disabled = false;
    this.lazy = false;
  }
  static isTreeItem(node) {
    return node instanceof Element && node.getAttribute("role") === "treeitem";
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "treeitem");
    this.setAttribute("tabindex", "-1");
    if (this.isNestedItem()) {
      this.slot = "children";
    }
  }
  firstUpdated() {
    this.childrenContainer.hidden = !this.expanded;
    this.childrenContainer.style.height = this.expanded ? "auto" : "0";
    this.isLeaf = !this.lazy && this.getChildrenItems().length === 0;
    this.handleExpandedChange();
  }
  async animateCollapse() {
    this.emit("sl-collapse");
    await stopAnimations(this.childrenContainer);
    const { keyframes, options } = getAnimation(this, "tree-item.collapse", {
      dir: this.localize.dir(),
    });
    await animateTo(
      this.childrenContainer,
      shimKeyframesHeightAuto(keyframes, this.childrenContainer.scrollHeight),
      options,
    );
    this.childrenContainer.hidden = true;
    this.emit("sl-after-collapse");
  }
  // Checks whether the item is nested into an item
  isNestedItem() {
    const parent = this.parentElement;
    return !!parent && _SlTreeItem2.isTreeItem(parent);
  }
  handleChildrenSlotChange() {
    this.loading = false;
    this.isLeaf = !this.lazy && this.getChildrenItems().length === 0;
  }
  willUpdate(changedProperties) {
    if (
      changedProperties.has("selected") &&
      !changedProperties.has("indeterminate")
    ) {
      this.indeterminate = false;
    }
  }
  async animateExpand() {
    this.emit("sl-expand");
    await stopAnimations(this.childrenContainer);
    this.childrenContainer.hidden = false;
    const { keyframes, options } = getAnimation(this, "tree-item.expand", {
      dir: this.localize.dir(),
    });
    await animateTo(
      this.childrenContainer,
      shimKeyframesHeightAuto(keyframes, this.childrenContainer.scrollHeight),
      options,
    );
    this.childrenContainer.style.height = "auto";
    this.emit("sl-after-expand");
  }
  handleLoadingChange() {
    this.setAttribute("aria-busy", this.loading ? "true" : "false");
    if (!this.loading) {
      this.animateExpand();
    }
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleExpandedChange() {
    if (!this.isLeaf) {
      this.setAttribute("aria-expanded", this.expanded ? "true" : "false");
    } else {
      this.removeAttribute("aria-expanded");
    }
  }
  handleExpandAnimation() {
    if (this.expanded) {
      if (this.lazy) {
        this.loading = true;
        this.emit("sl-lazy-load");
      } else {
        this.animateExpand();
      }
    } else {
      this.animateCollapse();
    }
  }
  handleLazyChange() {
    this.emit("sl-lazy-change");
  }
  /** Gets all the nested tree items in this node. */
  getChildrenItems({ includeDisabled = true } = {}) {
    return this.childrenSlot
      ? [...this.childrenSlot.assignedElements({ flatten: true })].filter(
          (item) =>
            _SlTreeItem2.isTreeItem(item) &&
            (includeDisabled || !item.disabled),
        )
      : [];
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    const showExpandButton = !this.loading && (!this.isLeaf || this.lazy);
    return x$2`
      <div
        part="base"
        class="${e$4({
          "tree-item": true,
          "tree-item--expanded": this.expanded,
          "tree-item--selected": this.selected,
          "tree-item--disabled": this.disabled,
          "tree-item--leaf": this.isLeaf,
          "tree-item--has-expand-button": showExpandButton,
          "tree-item--rtl": this.localize.dir() === "rtl",
        })}"
      >
        <div
          class="tree-item__item"
          part="
            item
            ${this.disabled ? "item--disabled" : ""}
            ${this.expanded ? "item--expanded" : ""}
            ${this.indeterminate ? "item--indeterminate" : ""}
            ${this.selected ? "item--selected" : ""}
          "
        >
          <div class="tree-item__indentation" part="indentation"></div>

          <div
            part="expand-button"
            class=${e$4({
              "tree-item__expand-button": true,
              "tree-item__expand-button--visible": showExpandButton,
            })}
            aria-hidden="true"
          >
            ${n$3(
              this.loading,
              () =>
                x$2` <sl-spinner part="spinner" exportparts="base:spinner__base"></sl-spinner> `,
            )}
            <slot class="tree-item__expand-icon-slot" name="expand-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
            <slot class="tree-item__expand-icon-slot" name="collapse-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
          </div>

          ${n$3(
            this.selectable,
            () => x$2`
              <sl-checkbox
                part="checkbox"
                exportparts="
                    base:checkbox__base,
                    control:checkbox__control,
                    control--checked:checkbox__control--checked,
                    control--indeterminate:checkbox__control--indeterminate,
                    checked-icon:checkbox__checked-icon,
                    indeterminate-icon:checkbox__indeterminate-icon,
                    label:checkbox__label
                  "
                class="tree-item__checkbox"
                ?disabled="${this.disabled}"
                ?checked="${l$1(this.selected)}"
                ?indeterminate="${this.indeterminate}"
                tabindex="-1"
              ></sl-checkbox>
            `,
          )}

          <slot class="tree-item__label" part="label"></slot>
        </div>

        <div class="tree-item__children" part="children" role="group">
          <slot name="children" @slotchange="${this.handleChildrenSlotChange}"></slot>
        </div>
      </div>
    `;
  }
};
_SlTreeItem.styles = [component_styles_default, tree_item_styles_default];
_SlTreeItem.dependencies = {
  "sl-checkbox": SlCheckbox,
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner,
};
__decorateClass([r$4()], _SlTreeItem.prototype, "indeterminate", 2);
__decorateClass([r$4()], _SlTreeItem.prototype, "isLeaf", 2);
__decorateClass([r$4()], _SlTreeItem.prototype, "loading", 2);
__decorateClass([r$4()], _SlTreeItem.prototype, "selectable", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  _SlTreeItem.prototype,
  "expanded",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  _SlTreeItem.prototype,
  "selected",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  _SlTreeItem.prototype,
  "disabled",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  _SlTreeItem.prototype,
  "lazy",
  2,
);
__decorateClass(
  [e$8("slot:not([name])")],
  _SlTreeItem.prototype,
  "defaultSlot",
  2,
);
__decorateClass(
  [e$8("slot[name=children]")],
  _SlTreeItem.prototype,
  "childrenSlot",
  2,
);
__decorateClass(
  [e$8(".tree-item__item")],
  _SlTreeItem.prototype,
  "itemElement",
  2,
);
__decorateClass(
  [e$8(".tree-item__children")],
  _SlTreeItem.prototype,
  "childrenContainer",
  2,
);
__decorateClass(
  [e$8(".tree-item__expand-button slot")],
  _SlTreeItem.prototype,
  "expandButtonSlot",
  2,
);
__decorateClass(
  [watch("loading", { waitUntilFirstUpdate: true })],
  _SlTreeItem.prototype,
  "handleLoadingChange",
  1,
);
__decorateClass(
  [watch("disabled")],
  _SlTreeItem.prototype,
  "handleDisabledChange",
  1,
);
__decorateClass(
  [watch("selected")],
  _SlTreeItem.prototype,
  "handleSelectedChange",
  1,
);
__decorateClass(
  [watch("expanded", { waitUntilFirstUpdate: true })],
  _SlTreeItem.prototype,
  "handleExpandedChange",
  1,
);
__decorateClass(
  [watch("expanded", { waitUntilFirstUpdate: true })],
  _SlTreeItem.prototype,
  "handleExpandAnimation",
  1,
);
__decorateClass(
  [watch("lazy", { waitUntilFirstUpdate: true })],
  _SlTreeItem.prototype,
  "handleLazyChange",
  1,
);
var SlTreeItem = _SlTreeItem;
setDefaultAnimation("tree-item.expand", {
  keyframes: [
    { height: "0", opacity: "0", overflow: "hidden" },
    { height: "auto", opacity: "1", overflow: "hidden" },
  ],
  options: { duration: 250, easing: "cubic-bezier(0.4, 0.0, 0.2, 1)" },
});
setDefaultAnimation("tree-item.collapse", {
  keyframes: [
    { height: "auto", opacity: "1", overflow: "hidden" },
    { height: "0", opacity: "0", overflow: "hidden" },
  ],
  options: { duration: 200, easing: "cubic-bezier(0.4, 0.0, 0.2, 1)" },
});
function clamp(value, min2, max2) {
  const noNegativeZero = (n3) => (Object.is(n3, -0) ? 0 : n3);
  if (value < min2) {
    return noNegativeZero(min2);
  }
  if (value > max2) {
    return noNegativeZero(max2);
  }
  return noNegativeZero(value);
}
function syncCheckboxes(changedTreeItem, initialSync = false) {
  function syncParentItem(treeItem) {
    const children = treeItem.getChildrenItems({ includeDisabled: false });
    if (children.length) {
      const allChecked = children.every((item) => item.selected);
      const allUnchecked = children.every(
        (item) => !item.selected && !item.indeterminate,
      );
      treeItem.selected = allChecked;
      treeItem.indeterminate = !allChecked && !allUnchecked;
    }
  }
  function syncAncestors(treeItem) {
    const parentItem = treeItem.parentElement;
    if (SlTreeItem.isTreeItem(parentItem)) {
      syncParentItem(parentItem);
      syncAncestors(parentItem);
    }
  }
  function syncDescendants(treeItem) {
    for (const childItem of treeItem.getChildrenItems()) {
      childItem.selected = initialSync
        ? treeItem.selected || childItem.selected
        : !childItem.disabled && treeItem.selected;
      syncDescendants(childItem);
    }
    if (initialSync) {
      syncParentItem(treeItem);
    }
  }
  syncDescendants(changedTreeItem);
  syncAncestors(changedTreeItem);
}
var SlTree = class extends ShoelaceElement {
  constructor() {
    super();
    this.selection = "single";
    this.clickTarget = null;
    this.localize = new LocalizeController2(this);
    this.initTreeItem = (item) => {
      item.selectable = this.selection === "multiple";
      ["expand", "collapse"]
        .filter((status) => !!this.querySelector(`[slot="${status}-icon"]`))
        .forEach((status) => {
          const existingIcon = item.querySelector(`[slot="${status}-icon"]`);
          const expandButtonIcon = this.getExpandButtonIcon(status);
          if (!expandButtonIcon) return;
          if (existingIcon === null) {
            item.append(expandButtonIcon);
          } else if (existingIcon.hasAttribute("data-default")) {
            existingIcon.replaceWith(expandButtonIcon);
          } else;
        });
    };
    this.handleTreeChanged = (mutations) => {
      for (const mutation of mutations) {
        const addedNodes = [...mutation.addedNodes].filter(
          SlTreeItem.isTreeItem,
        );
        const removedNodes = [...mutation.removedNodes].filter(
          SlTreeItem.isTreeItem,
        );
        addedNodes.forEach(this.initTreeItem);
        if (
          this.lastFocusedItem &&
          removedNodes.includes(this.lastFocusedItem)
        ) {
          this.lastFocusedItem = null;
        }
      }
    };
    this.handleFocusOut = (event) => {
      const relatedTarget = event.relatedTarget;
      if (!relatedTarget || !this.contains(relatedTarget)) {
        this.tabIndex = 0;
      }
    };
    this.handleFocusIn = (event) => {
      const target = event.target;
      if (event.target === this) {
        this.focusItem(this.lastFocusedItem || this.getAllTreeItems()[0]);
      }
      if (SlTreeItem.isTreeItem(target) && !target.disabled) {
        if (this.lastFocusedItem) {
          this.lastFocusedItem.tabIndex = -1;
        }
        this.lastFocusedItem = target;
        this.tabIndex = -1;
        target.tabIndex = 0;
      }
    };
    this.addEventListener("focusin", this.handleFocusIn);
    this.addEventListener("focusout", this.handleFocusOut);
    this.addEventListener("sl-lazy-change", this.handleSlotChange);
  }
  async connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "tree");
    this.setAttribute("tabindex", "0");
    await this.updateComplete;
    this.mutationObserver = new MutationObserver(this.handleTreeChanged);
    this.mutationObserver.observe(this, { childList: true, subtree: true });
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback();
    (_a2 = this.mutationObserver) == null ? void 0 : _a2.disconnect();
  }
  // Generates a clone of the expand icon element to use for each tree item
  getExpandButtonIcon(status) {
    const slot =
      status === "expand" ? this.expandedIconSlot : this.collapsedIconSlot;
    const icon = slot.assignedElements({ flatten: true })[0];
    if (icon) {
      const clone = icon.cloneNode(true);
      [clone, ...clone.querySelectorAll("[id]")].forEach((el) =>
        el.removeAttribute("id"),
      );
      clone.setAttribute("data-default", "");
      clone.slot = `${status}-icon`;
      return clone;
    }
    return null;
  }
  selectItem(selectedItem) {
    const previousSelection = [...this.selectedItems];
    if (this.selection === "multiple") {
      selectedItem.selected = !selectedItem.selected;
      if (selectedItem.lazy) {
        selectedItem.expanded = true;
      }
      syncCheckboxes(selectedItem);
    } else if (this.selection === "single" || selectedItem.isLeaf) {
      const items = this.getAllTreeItems();
      for (const item of items) {
        item.selected = item === selectedItem;
      }
    } else if (this.selection === "leaf") {
      selectedItem.expanded = !selectedItem.expanded;
    }
    const nextSelection = this.selectedItems;
    if (
      previousSelection.length !== nextSelection.length ||
      nextSelection.some((item) => !previousSelection.includes(item))
    ) {
      Promise.all(nextSelection.map((el) => el.updateComplete)).then(() => {
        this.emit("sl-selection-change", {
          detail: { selection: nextSelection },
        });
      });
    }
  }
  getAllTreeItems() {
    return [...this.querySelectorAll("sl-tree-item")];
  }
  focusItem(item) {
    item == null ? void 0 : item.focus();
  }
  handleKeyDown(event) {
    if (
      ![
        "ArrowDown",
        "ArrowUp",
        "ArrowRight",
        "ArrowLeft",
        "Home",
        "End",
        "Enter",
        " ",
      ].includes(event.key)
    ) {
      return;
    }
    if (
      event.composedPath().some((el) => {
        var _a2;
        return ["input", "textarea"].includes(
          (_a2 = el == null ? void 0 : el.tagName) == null
            ? void 0
            : _a2.toLowerCase(),
        );
      })
    ) {
      return;
    }
    const items = this.getFocusableItems();
    const isLtr = this.localize.dir() === "ltr";
    const isRtl = this.localize.dir() === "rtl";
    if (items.length > 0) {
      event.preventDefault();
      const activeItemIndex = items.findIndex((item) => item.matches(":focus"));
      const activeItem = items[activeItemIndex];
      const focusItemAt = (index) => {
        const item = items[clamp(index, 0, items.length - 1)];
        this.focusItem(item);
      };
      const toggleExpand = (expanded) => {
        activeItem.expanded = expanded;
      };
      if (event.key === "ArrowDown") {
        focusItemAt(activeItemIndex + 1);
      } else if (event.key === "ArrowUp") {
        focusItemAt(activeItemIndex - 1);
      } else if (
        (isLtr && event.key === "ArrowRight") ||
        (isRtl && event.key === "ArrowLeft")
      ) {
        if (
          !activeItem ||
          activeItem.disabled ||
          activeItem.expanded ||
          (activeItem.isLeaf && !activeItem.lazy)
        ) {
          focusItemAt(activeItemIndex + 1);
        } else {
          toggleExpand(true);
        }
      } else if (
        (isLtr && event.key === "ArrowLeft") ||
        (isRtl && event.key === "ArrowRight")
      ) {
        if (
          !activeItem ||
          activeItem.disabled ||
          activeItem.isLeaf ||
          !activeItem.expanded
        ) {
          focusItemAt(activeItemIndex - 1);
        } else {
          toggleExpand(false);
        }
      } else if (event.key === "Home") {
        focusItemAt(0);
      } else if (event.key === "End") {
        focusItemAt(items.length - 1);
      } else if (event.key === "Enter" || event.key === " ") {
        if (!activeItem.disabled) {
          this.selectItem(activeItem);
        }
      }
    }
  }
  handleClick(event) {
    const target = event.target;
    const treeItem = target.closest("sl-tree-item");
    const isExpandButton = event.composedPath().some((el) => {
      var _a2;
      return (_a2 = el == null ? void 0 : el.classList) == null
        ? void 0
        : _a2.contains("tree-item__expand-button");
    });
    if (!treeItem || treeItem.disabled || target !== this.clickTarget) {
      return;
    }
    if (isExpandButton) {
      treeItem.expanded = !treeItem.expanded;
    } else {
      this.selectItem(treeItem);
    }
  }
  handleMouseDown(event) {
    this.clickTarget = event.target;
  }
  handleSlotChange() {
    const items = this.getAllTreeItems();
    items.forEach(this.initTreeItem);
  }
  async handleSelectionChange() {
    const isSelectionMultiple = this.selection === "multiple";
    const items = this.getAllTreeItems();
    this.setAttribute(
      "aria-multiselectable",
      isSelectionMultiple ? "true" : "false",
    );
    for (const item of items) {
      item.selectable = isSelectionMultiple;
    }
    if (isSelectionMultiple) {
      await this.updateComplete;
      [...this.querySelectorAll(":scope > sl-tree-item")].forEach((treeItem) =>
        syncCheckboxes(treeItem, true),
      );
    }
  }
  /** @internal Returns the list of tree items that are selected in the tree. */
  get selectedItems() {
    const items = this.getAllTreeItems();
    const isSelected = (item) => item.selected;
    return items.filter(isSelected);
  }
  /** @internal Gets focusable tree items in the tree. */
  getFocusableItems() {
    const items = this.getAllTreeItems();
    const collapsedItems = /* @__PURE__ */ new Set();
    return items.filter((item) => {
      var _a2;
      if (item.disabled) return false;
      const parent =
        (_a2 = item.parentElement) == null
          ? void 0
          : _a2.closest("[role=treeitem]");
      if (
        parent &&
        (!parent.expanded || parent.loading || collapsedItems.has(parent))
      ) {
        collapsedItems.add(item);
      }
      return !collapsedItems.has(item);
    });
  }
  render() {
    return x$2`
      <div
        part="base"
        class="tree"
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
        <span hidden aria-hidden="true"><slot name="expand-icon"></slot></span>
        <span hidden aria-hidden="true"><slot name="collapse-icon"></slot></span>
      </div>
    `;
  }
};
SlTree.styles = [component_styles_default, tree_styles_default];
__decorateClass([e$8("slot:not([name])")], SlTree.prototype, "defaultSlot", 2);
__decorateClass(
  [e$8("slot[name=expand-icon]")],
  SlTree.prototype,
  "expandedIconSlot",
  2,
);
__decorateClass(
  [e$8("slot[name=collapse-icon]")],
  SlTree.prototype,
  "collapsedIconSlot",
  2,
);
__decorateClass([n$6()], SlTree.prototype, "selection", 2);
__decorateClass(
  [watch("selection")],
  SlTree.prototype,
  "handleSelectionChange",
  1,
);
var tagName$O = "sl-tree";
SlTree.define("sl-tree");
o$8({
  tagName: tagName$O,
  elementClass: SlTree,
  react: React,
  events: {
    onSlSelectionChange: "sl-selection-change",
  },
  displayName: "SlTree",
});
var tagName$N = "sl-tree-item";
SlTreeItem.define("sl-tree-item");
o$8({
  tagName: tagName$N,
  elementClass: SlTreeItem,
  react: React,
  events: {
    onSlExpand: "sl-expand",
    onSlAfterExpand: "sl-after-expand",
    onSlCollapse: "sl-collapse",
    onSlAfterCollapse: "sl-after-collapse",
    onSlLazyChange: "sl-lazy-change",
    onSlLazyLoad: "sl-lazy-load",
  },
  displayName: "SlTreeItem",
});
var availableUnits = [
  { max: 276e4, value: 6e4, unit: "minute" },
  // max 46 minutes
  { max: 72e6, value: 36e5, unit: "hour" },
  // max 20 hours
  { max: 5184e5, value: 864e5, unit: "day" },
  // max 6 days
  { max: 24192e5, value: 6048e5, unit: "week" },
  // max 28 days
  { max: 28512e6, value: 2592e6, unit: "month" },
  // max 11 months
  { max: Infinity, value: 31536e6, unit: "year" },
];
var SlRelativeTime = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.isoTime = "";
    this.relativeTime = "";
    this.date = /* @__PURE__ */ new Date();
    this.format = "long";
    this.numeric = "auto";
    this.sync = false;
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    clearTimeout(this.updateTimeout);
  }
  render() {
    const now = /* @__PURE__ */ new Date();
    const then = new Date(this.date);
    if (isNaN(then.getMilliseconds())) {
      this.relativeTime = "";
      this.isoTime = "";
      return "";
    }
    const diff = then.getTime() - now.getTime();
    const { unit, value } = availableUnits.find(
      (singleUnit) => Math.abs(diff) < singleUnit.max,
    );
    this.isoTime = then.toISOString();
    this.relativeTime = this.localize.relativeTime(
      Math.round(diff / value),
      unit,
      {
        numeric: this.numeric,
        style: this.format,
      },
    );
    clearTimeout(this.updateTimeout);
    if (this.sync) {
      let nextInterval;
      if (unit === "minute") {
        nextInterval = getTimeUntilNextUnit("second");
      } else if (unit === "hour") {
        nextInterval = getTimeUntilNextUnit("minute");
      } else if (unit === "day") {
        nextInterval = getTimeUntilNextUnit("hour");
      } else {
        nextInterval = getTimeUntilNextUnit("day");
      }
      this.updateTimeout = window.setTimeout(
        () => this.requestUpdate(),
        nextInterval,
      );
    }
    return x$2` <time datetime=${this.isoTime}>${this.relativeTime}</time> `;
  }
};
__decorateClass([r$4()], SlRelativeTime.prototype, "isoTime", 2);
__decorateClass([r$4()], SlRelativeTime.prototype, "relativeTime", 2);
__decorateClass([n$6()], SlRelativeTime.prototype, "date", 2);
__decorateClass([n$6()], SlRelativeTime.prototype, "format", 2);
__decorateClass([n$6()], SlRelativeTime.prototype, "numeric", 2);
__decorateClass([n$6({ type: Boolean })], SlRelativeTime.prototype, "sync", 2);
function getTimeUntilNextUnit(unit) {
  const units = { second: 1e3, minute: 6e4, hour: 36e5, day: 864e5 };
  const value = units[unit];
  return value - (Date.now() % value);
}
var tagName$M = "sl-relative-time";
SlRelativeTime.define("sl-relative-time");
o$8({
  tagName: tagName$M,
  elementClass: SlRelativeTime,
  react: React,
  events: {},
  displayName: "SlRelativeTime",
});
var range_styles_default = i$8`
  :host {
    --thumb-size: 20px;
    --tooltip-offset: 10px;
    --track-color-active: var(--sl-color-neutral-200);
    --track-color-inactive: var(--sl-color-neutral-200);
    --track-active-offset: 0%;
    --track-height: 6px;

    display: block;
  }

  .range {
    position: relative;
  }

  .range__control {
    --percent: 0%;
    -webkit-appearance: none;
    border-radius: 3px;
    width: 100%;
    height: var(--track-height);
    background: transparent;
    line-height: var(--sl-input-height-medium);
    vertical-align: middle;
    margin: 0;

    background-image: linear-gradient(
      to right,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  .range--rtl .range__control {
    background-image: linear-gradient(
      to left,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  /* Webkit */
  .range__control::-webkit-slider-runnable-track {
    width: 100%;
    height: var(--track-height);
    border-radius: 3px;
    border: none;
  }

  .range__control::-webkit-slider-thumb {
    border: none;
    width: var(--thumb-size);
    height: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border: solid var(--sl-input-border-width) var(--sl-color-primary-600);
    -webkit-appearance: none;
    margin-top: calc(var(--thumb-size) / -2 + var(--track-height) / 2);
    cursor: pointer;
  }

  .range__control:enabled::-webkit-slider-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-webkit-slider-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-webkit-slider-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* Firefox */
  .range__control::-moz-focus-outer {
    border: 0;
  }

  .range__control::-moz-range-progress {
    background-color: var(--track-color-active);
    border-radius: 3px;
    height: var(--track-height);
  }

  .range__control::-moz-range-track {
    width: 100%;
    height: var(--track-height);
    background-color: var(--track-color-inactive);
    border-radius: 3px;
    border: none;
  }

  .range__control::-moz-range-thumb {
    border: none;
    height: var(--thumb-size);
    width: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
    cursor: pointer;
  }

  .range__control:enabled::-moz-range-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-moz-range-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-moz-range-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* States */
  .range__control:focus-visible {
    outline: none;
  }

  .range__control:disabled {
    opacity: 0.5;
  }

  .range__control:disabled::-webkit-slider-thumb {
    cursor: not-allowed;
  }

  .range__control:disabled::-moz-range-thumb {
    cursor: not-allowed;
  }

  /* Tooltip output */
  .range__tooltip {
    position: absolute;
    z-index: var(--sl-z-index-tooltip);
    left: 0;
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    opacity: 0;
    padding: var(--sl-tooltip-padding);
    transition: var(--sl-transition-fast) opacity;
    pointer-events: none;
  }

  .range__tooltip:after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    left: 50%;
    translate: calc(-1 * var(--sl-tooltip-arrow-size));
  }

  .range--tooltip-visible .range__tooltip {
    opacity: 1;
  }

  /* Tooltip on top */
  .range--tooltip-top .range__tooltip {
    top: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-top .range__tooltip:after {
    border-top: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    top: 100%;
  }

  /* Tooltip on bottom */
  .range--tooltip-bottom .range__tooltip {
    bottom: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-bottom .range__tooltip:after {
    border-bottom: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    bottom: 100%;
  }

  @media (forced-colors: active) {
    .range__control,
    .range__tooltip {
      border: solid 1px transparent;
    }

    .range__control::-webkit-slider-thumb {
      border: solid 1px transparent;
    }

    .range__control::-moz-range-thumb {
      border: solid 1px transparent;
    }

    .range__tooltip:after {
      display: none;
    }
  }
`;
var SlRange = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this);
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.hasTooltip = false;
    this.title = "";
    this.name = "";
    this.value = 0;
    this.label = "";
    this.helpText = "";
    this.disabled = false;
    this.min = 0;
    this.max = 100;
    this.step = 1;
    this.tooltip = "top";
    this.tooltipFormatter = (value) => value.toString();
    this.form = "";
    this.defaultValue = 0;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => this.syncRange());
    if (this.value < this.min) {
      this.value = this.min;
    }
    if (this.value > this.max) {
      this.value = this.max;
    }
    this.updateComplete.then(() => {
      this.syncRange();
      this.resizeObserver.observe(this.input);
    });
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback();
    (_a2 = this.resizeObserver) == null ? void 0 : _a2.unobserve(this.input);
  }
  handleChange() {
    this.emit("sl-change");
  }
  handleInput() {
    this.value = parseFloat(this.input.value);
    this.emit("sl-input");
    this.syncRange();
  }
  handleBlur() {
    this.hasFocus = false;
    this.hasTooltip = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.hasTooltip = true;
    this.emit("sl-focus");
  }
  handleThumbDragStart() {
    this.hasTooltip = true;
  }
  handleThumbDragEnd() {
    this.hasTooltip = false;
  }
  syncProgress(percent) {
    this.input.style.setProperty("--percent", `${percent * 100}%`);
  }
  syncTooltip(percent) {
    if (this.output !== null) {
      const inputWidth = this.input.offsetWidth;
      const tooltipWidth = this.output.offsetWidth;
      const thumbSize = getComputedStyle(this.input).getPropertyValue(
        "--thumb-size",
      );
      const isRtl = this.localize.dir() === "rtl";
      const percentAsWidth = inputWidth * percent;
      if (isRtl) {
        const x2 = `${inputWidth - percentAsWidth}px + ${percent} * ${thumbSize}`;
        this.output.style.translate = `calc((${x2} - ${tooltipWidth / 2}px - ${thumbSize} / 2))`;
      } else {
        const x2 = `${percentAsWidth}px - ${percent} * ${thumbSize}`;
        this.output.style.translate = `calc(${x2} - ${tooltipWidth / 2}px + ${thumbSize} / 2)`;
      }
    }
  }
  handleValueChange() {
    this.formControlController.updateValidity();
    this.input.value = this.value.toString();
    this.value = parseFloat(this.input.value);
    this.syncRange();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  syncRange() {
    const percent = Math.max(
      0,
      (this.value - this.min) / (this.max - this.min),
    );
    this.syncProgress(percent);
    if (this.tooltip !== "none" && this.hasTooltip) {
      this.updateComplete.then(() => this.syncTooltip(percent));
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  /** Sets focus on the range. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the range. */
  blur() {
    this.input.blur();
  }
  /** Increments the value of the range by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== Number(this.input.value)) {
      this.value = Number(this.input.value);
    }
  }
  /** Decrements the value of the range by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== Number(this.input.value)) {
      this.value = Number(this.input.value);
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return x$2`
      <div
        part="form-control"
        class=${e$4({
          "form-control": true,
          "form-control--medium": true,
          // range only has one size
          "form-control--has-label": hasLabel,
          "form-control--has-help-text": hasHelpText,
        })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e$4({
              range: true,
              "range--disabled": this.disabled,
              "range--focused": this.hasFocus,
              "range--rtl": this.localize.dir() === "rtl",
              "range--tooltip-visible": this.hasTooltip,
              "range--tooltip-top": this.tooltip === "top",
              "range--tooltip-bottom": this.tooltip === "bottom",
            })}
            @mousedown=${this.handleThumbDragStart}
            @mouseup=${this.handleThumbDragEnd}
            @touchstart=${this.handleThumbDragStart}
            @touchend=${this.handleThumbDragEnd}
          >
            <input
              part="input"
              id="input"
              class="range__control"
              title=${this.title}
              type="range"
              name=${o$7(this.name)}
              ?disabled=${this.disabled}
              min=${o$7(this.min)}
              max=${o$7(this.max)}
              step=${o$7(this.step)}
              .value=${l$1(this.value.toString())}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @focus=${this.handleFocus}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @blur=${this.handleBlur}
            />
            ${
              this.tooltip !== "none" && !this.disabled
                ? x$2`
                  <output part="tooltip" class="range__tooltip">
                    ${typeof this.tooltipFormatter === "function" ? this.tooltipFormatter(this.value) : this.value}
                  </output>
                `
                : ""
            }
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlRange.styles = [
  component_styles_default,
  form_control_styles_default,
  range_styles_default,
];
__decorateClass([e$8(".range__control")], SlRange.prototype, "input", 2);
__decorateClass([e$8(".range__tooltip")], SlRange.prototype, "output", 2);
__decorateClass([r$4()], SlRange.prototype, "hasFocus", 2);
__decorateClass([r$4()], SlRange.prototype, "hasTooltip", 2);
__decorateClass([n$6()], SlRange.prototype, "title", 2);
__decorateClass([n$6()], SlRange.prototype, "name", 2);
__decorateClass([n$6({ type: Number })], SlRange.prototype, "value", 2);
__decorateClass([n$6()], SlRange.prototype, "label", 2);
__decorateClass(
  [n$6({ attribute: "help-text" })],
  SlRange.prototype,
  "helpText",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlRange.prototype,
  "disabled",
  2,
);
__decorateClass([n$6({ type: Number })], SlRange.prototype, "min", 2);
__decorateClass([n$6({ type: Number })], SlRange.prototype, "max", 2);
__decorateClass([n$6({ type: Number })], SlRange.prototype, "step", 2);
__decorateClass([n$6()], SlRange.prototype, "tooltip", 2);
__decorateClass(
  [n$6({ attribute: false })],
  SlRange.prototype,
  "tooltipFormatter",
  2,
);
__decorateClass([n$6({ reflect: true })], SlRange.prototype, "form", 2);
__decorateClass([defaultValue()], SlRange.prototype, "defaultValue", 2);
__decorateClass(
  [t$3({ passive: true })],
  SlRange.prototype,
  "handleThumbDragStart",
  1,
);
__decorateClass(
  [watch("value", { waitUntilFirstUpdate: true })],
  SlRange.prototype,
  "handleValueChange",
  1,
);
__decorateClass(
  [watch("disabled", { waitUntilFirstUpdate: true })],
  SlRange.prototype,
  "handleDisabledChange",
  1,
);
__decorateClass(
  [watch("hasTooltip", { waitUntilFirstUpdate: true })],
  SlRange.prototype,
  "syncRange",
  1,
);
var tagName$L = "sl-range";
SlRange.define("sl-range");
o$8({
  tagName: tagName$L,
  elementClass: SlRange,
  react: React,
  events: {
    onSlBlur: "sl-blur",
    onSlChange: "sl-change",
    onSlFocus: "sl-focus",
    onSlInput: "sl-input",
    onSlInvalid: "sl-invalid",
  },
  displayName: "SlRange",
});
var tagName$K = "sl-resize-observer";
SlResizeObserver.define("sl-resize-observer");
o$8({
  tagName: tagName$K,
  elementClass: SlResizeObserver,
  react: React,
  events: {
    onSlResize: "sl-resize",
  },
  displayName: "SlResizeObserver",
});
var select_styles_default = i$8`
  :host {
    display: block;
  }

  /** The popup */
  .select {
    flex: 1 1 auto;
    display: inline-flex;
    width: 100%;
    position: relative;
    vertical-align: middle;
  }

  .select::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .select[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .select[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  /* Combobox */
  .select__combobox {
    flex: 1;
    display: flex;
    width: 100%;
    min-width: 0;
    position: relative;
    align-items: center;
    justify-content: start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: pointer;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  .select__display-input {
    position: relative;
    width: 100%;
    font: inherit;
    border: none;
    background: none;
    color: var(--sl-input-color);
    cursor: inherit;
    overflow: hidden;
    padding: 0;
    margin: 0;
    -webkit-appearance: none;
  }

  .select__display-input::placeholder {
    color: var(--sl-input-placeholder-color);
  }

  .select:not(.select--disabled):hover .select__display-input {
    color: var(--sl-input-color-hover);
  }

  .select__display-input:focus {
    outline: none;
  }

  /* Visually hide the display input when multiple is enabled */
  .select--multiple:not(.select--placeholder-visible) .select__display-input {
    position: absolute;
    z-index: -1;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
  }

  .select__value-input {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: -1;
  }

  .select__tags {
    display: flex;
    flex: 1;
    align-items: center;
    flex-wrap: wrap;
    margin-inline-start: var(--sl-spacing-2x-small);
  }

  .select__tags::slotted(sl-tag) {
    cursor: pointer !important;
  }

  .select--disabled .select__tags,
  .select--disabled .select__tags::slotted(sl-tag) {
    cursor: not-allowed !important;
  }

  /* Standard selects */
  .select--standard .select__combobox {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .select--standard.select--disabled .select__combobox {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    color: var(--sl-input-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
    outline: none;
  }

  .select--standard:not(.select--disabled).select--open .select__combobox,
  .select--standard:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  /* Filled selects */
  .select--filled .select__combobox {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .select--filled:hover:not(.select--disabled) .select__combobox {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .select--filled.select--disabled .select__combobox {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .select--filled:not(.select--disabled).select--open .select__combobox,
  .select--filled:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
  }

  /* Sizes */
  .select--small .select__combobox {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    min-height: var(--sl-input-height-small);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-small);
  }

  .select--small .select__clear {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__prefix::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-block: 2px;
    padding-inline-start: 0;
  }

  .select--small .select__tags {
    gap: 2px;
  }

  .select--medium .select__combobox {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    min-height: var(--sl-input-height-medium);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-medium);
  }

  .select--medium .select__clear {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__prefix::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 3px;
  }

  .select--medium .select__tags {
    gap: 3px;
  }

  .select--large .select__combobox {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    min-height: var(--sl-input-height-large);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-large);
  }

  .select--large .select__clear {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__prefix::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 4px;
  }

  .select--large .select__tags {
    gap: 4px;
  }

  /* Pills */
  .select--pill.select--small .select__combobox {
    border-radius: var(--sl-input-height-small);
  }

  .select--pill.select--medium .select__combobox {
    border-radius: var(--sl-input-height-medium);
  }

  .select--pill.select--large .select__combobox {
    border-radius: var(--sl-input-height-large);
  }

  /* Prefix and Suffix */
  .select__prefix,
  .select__suffix {
    flex: 0;
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  .select__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-small);
  }

  /* Clear button */
  .select__clear {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .select__clear:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .select__clear:focus {
    outline: none;
  }

  /* Expand icon */
  .select__expand-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
    rotate: 0;
    margin-inline-start: var(--sl-spacing-small);
  }

  .select--open .select__expand-icon {
    rotate: -180deg;
  }

  /* Listbox */
  .select__listbox {
    display: block;
    position: relative;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: 0;
    overflow: auto;
    overscroll-behavior: none;

    /* Make sure it adheres to the popup's auto size */
    max-width: var(--auto-size-available-width);
    max-height: var(--auto-size-available-height);
  }

  .select__listbox ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }

  .select__listbox ::slotted(small) {
    display: block;
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-500);
    padding-block: var(--sl-spacing-2x-small);
    padding-inline: var(--sl-spacing-x-large);
  }
`;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let e$1 = class e extends i$3 {
  constructor(i3) {
    if ((super(i3), (this.it = E$1), i3.type !== t.CHILD))
      throw Error(
        this.constructor.directiveName +
          "() can only be used in child bindings",
      );
  }
  render(r3) {
    if (r3 === E$1 || null == r3) return (this._t = void 0), (this.it = r3);
    if (r3 === T$2) return r3;
    if ("string" != typeof r3)
      throw Error(
        this.constructor.directiveName + "() called with a non-string value",
      );
    if (r3 === this.it) return this._t;
    this.it = r3;
    const s2 = [r3];
    return (
      (s2.raw = s2),
      (this._t = {
        _$litType$: this.constructor.resultType,
        strings: s2,
        values: [],
      })
    );
  }
};
(e$1.directiveName = "unsafeHTML"), (e$1.resultType = 1);
const o$5 = e$5(e$1);
var SlSelect = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"],
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.typeToSelectString = "";
    this.hasFocus = false;
    this.displayLabel = "";
    this.selectedOptions = [];
    this.valueHasChanged = false;
    this.name = "";
    this._value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.placeholder = "";
    this.multiple = false;
    this.maxOptionsVisible = 3;
    this.disabled = false;
    this.clearable = false;
    this.open = false;
    this.hoist = false;
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.placement = "bottom";
    this.helpText = "";
    this.form = "";
    this.required = false;
    this.getTag = (option) => {
      return x$2`
      <sl-tag
        part="tag"
        exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button,
              remove-button__base:tag__remove-button__base
            "
        ?pill=${this.pill}
        size=${this.size}
        removable
        @sl-remove=${(event) => this.handleTagRemove(event, option)}
      >
        ${option.getTextLabel()}
      </sl-tag>
    `;
    };
    this.handleDocumentFocusIn = (event) => {
      const path = event.composedPath();
      if (this && !path.includes(this)) {
        this.hide();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      const target = event.target;
      const isClearButton = target.closest(".select__clear") !== null;
      const isIconButton = target.closest("sl-icon-button") !== null;
      if (isClearButton || isIconButton) {
        return;
      }
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.preventDefault();
        event.stopPropagation();
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
      if (
        event.key === "Enter" ||
        (event.key === " " && this.typeToSelectString === "")
      ) {
        event.preventDefault();
        event.stopImmediatePropagation();
        if (!this.open) {
          this.show();
          return;
        }
        if (this.currentOption && !this.currentOption.disabled) {
          this.valueHasChanged = true;
          if (this.multiple) {
            this.toggleOptionSelection(this.currentOption);
          } else {
            this.setSelectedOptions(this.currentOption);
          }
          this.updateComplete.then(() => {
            this.emit("sl-input");
            this.emit("sl-change");
          });
          if (!this.multiple) {
            this.hide();
            this.displayInput.focus({ preventScroll: true });
          }
        }
        return;
      }
      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
        const allOptions = this.getAllOptions();
        const currentIndex = allOptions.indexOf(this.currentOption);
        let newIndex = Math.max(0, currentIndex);
        event.preventDefault();
        if (!this.open) {
          this.show();
          if (this.currentOption) {
            return;
          }
        }
        if (event.key === "ArrowDown") {
          newIndex = currentIndex + 1;
          if (newIndex > allOptions.length - 1) newIndex = 0;
        } else if (event.key === "ArrowUp") {
          newIndex = currentIndex - 1;
          if (newIndex < 0) newIndex = allOptions.length - 1;
        } else if (event.key === "Home") {
          newIndex = 0;
        } else if (event.key === "End") {
          newIndex = allOptions.length - 1;
        }
        this.setCurrentOption(allOptions[newIndex]);
      }
      if ((event.key && event.key.length === 1) || event.key === "Backspace") {
        const allOptions = this.getAllOptions();
        if (event.metaKey || event.ctrlKey || event.altKey) {
          return;
        }
        if (!this.open) {
          if (event.key === "Backspace") {
            return;
          }
          this.show();
        }
        event.stopPropagation();
        event.preventDefault();
        clearTimeout(this.typeToSelectTimeout);
        this.typeToSelectTimeout = window.setTimeout(
          () => (this.typeToSelectString = ""),
          1e3,
        );
        if (event.key === "Backspace") {
          this.typeToSelectString = this.typeToSelectString.slice(0, -1);
        } else {
          this.typeToSelectString += event.key.toLowerCase();
        }
        for (const option of allOptions) {
          const label = option.getTextLabel().toLowerCase();
          if (label.startsWith(this.typeToSelectString)) {
            this.setCurrentOption(option);
            break;
          }
        }
      }
    };
    this.handleDocumentMouseDown = (event) => {
      const path = event.composedPath();
      if (this && !path.includes(this)) {
        this.hide();
      }
    };
  }
  get value() {
    return this._value;
  }
  set value(val) {
    if (this.multiple) {
      val = Array.isArray(val) ? val : val.split(" ");
    } else {
      val = Array.isArray(val) ? val.join(" ") : val;
    }
    if (this._value === val) {
      return;
    }
    this.valueHasChanged = true;
    this._value = val;
  }
  /** Gets the validity state object */
  get validity() {
    return this.valueInput.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.valueInput.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    setTimeout(() => {
      this.handleDefaultSlotChange();
    });
    this.open = false;
  }
  addOpenListeners() {
    var _a2;
    document.addEventListener("focusin", this.handleDocumentFocusIn);
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
    if (this.getRootNode() !== document) {
      this.getRootNode().addEventListener(
        "focusin",
        this.handleDocumentFocusIn,
      );
    }
    if ("CloseWatcher" in window) {
      (_a2 = this.closeWatcher) == null ? void 0 : _a2.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        if (this.open) {
          this.hide();
          this.displayInput.focus({ preventScroll: true });
        }
      };
    }
  }
  removeOpenListeners() {
    var _a2;
    document.removeEventListener("focusin", this.handleDocumentFocusIn);
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    if (this.getRootNode() !== document) {
      this.getRootNode().removeEventListener(
        "focusin",
        this.handleDocumentFocusIn,
      );
    }
    (_a2 = this.closeWatcher) == null ? void 0 : _a2.destroy();
  }
  handleFocus() {
    this.hasFocus = true;
    this.displayInput.setSelectionRange(0, 0);
    this.emit("sl-focus");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleLabelClick() {
    this.displayInput.focus();
  }
  handleComboboxMouseDown(event) {
    const path = event.composedPath();
    const isIconButton = path.some(
      (el) =>
        el instanceof Element && el.tagName.toLowerCase() === "sl-icon-button",
    );
    if (this.disabled || isIconButton) {
      return;
    }
    event.preventDefault();
    this.displayInput.focus({ preventScroll: true });
    this.open = !this.open;
  }
  handleComboboxKeyDown(event) {
    if (event.key === "Tab") {
      return;
    }
    event.stopPropagation();
    this.handleDocumentKeyDown(event);
  }
  handleClearClick(event) {
    event.stopPropagation();
    this.valueHasChanged = true;
    if (this.value !== "") {
      this.setSelectedOptions([]);
      this.displayInput.focus({ preventScroll: true });
      this.updateComplete.then(() => {
        this.emit("sl-clear");
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  handleClearMouseDown(event) {
    event.stopPropagation();
    event.preventDefault();
  }
  handleOptionClick(event) {
    const target = event.target;
    const option = target.closest("sl-option");
    const oldValue = this.value;
    if (option && !option.disabled) {
      this.valueHasChanged = true;
      if (this.multiple) {
        this.toggleOptionSelection(option);
      } else {
        this.setSelectedOptions(option);
      }
      this.updateComplete.then(() =>
        this.displayInput.focus({ preventScroll: true }),
      );
      if (this.value !== oldValue) {
        this.updateComplete.then(() => {
          this.emit("sl-input");
          this.emit("sl-change");
        });
      }
      if (!this.multiple) {
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
    }
  }
  /* @internal - used by options to update labels */
  handleDefaultSlotChange() {
    if (!customElements.get("sl-option")) {
      customElements
        .whenDefined("sl-option")
        .then(() => this.handleDefaultSlotChange());
    }
    const allOptions = this.getAllOptions();
    const val = this.valueHasChanged ? this.value : this.defaultValue;
    const value = Array.isArray(val) ? val : [val];
    const values = [];
    allOptions.forEach((option) => values.push(option.value));
    this.setSelectedOptions(
      allOptions.filter((el) => value.includes(el.value)),
    );
  }
  handleTagRemove(event, option) {
    event.stopPropagation();
    this.valueHasChanged = true;
    if (!this.disabled) {
      this.toggleOptionSelection(option, false);
      this.updateComplete.then(() => {
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  // Gets an array of all <sl-option> elements
  getAllOptions() {
    return [...this.querySelectorAll("sl-option")];
  }
  // Gets the first <sl-option> element
  getFirstOption() {
    return this.querySelector("sl-option");
  }
  // Sets the current option, which is the option the user is currently interacting with (e.g. via keyboard). Only one
  // option may be "current" at a time.
  setCurrentOption(option) {
    const allOptions = this.getAllOptions();
    allOptions.forEach((el) => {
      el.current = false;
      el.tabIndex = -1;
    });
    if (option) {
      this.currentOption = option;
      option.current = true;
      option.tabIndex = 0;
      option.focus();
    }
  }
  // Sets the selected option(s)
  setSelectedOptions(option) {
    const allOptions = this.getAllOptions();
    const newSelectedOptions = Array.isArray(option) ? option : [option];
    allOptions.forEach((el) => (el.selected = false));
    if (newSelectedOptions.length) {
      newSelectedOptions.forEach((el) => (el.selected = true));
    }
    this.selectionChanged();
  }
  // Toggles an option's selected state
  toggleOptionSelection(option, force) {
    if (force === true || force === false) {
      option.selected = force;
    } else {
      option.selected = !option.selected;
    }
    this.selectionChanged();
  }
  // This method must be called whenever the selection changes. It will update the selected options cache, the current
  // value, and the display value
  selectionChanged() {
    var _a2, _b2, _c2;
    const options = this.getAllOptions();
    this.selectedOptions = options.filter((el) => el.selected);
    const cachedValueHasChanged = this.valueHasChanged;
    if (this.multiple) {
      this.value = this.selectedOptions.map((el) => el.value);
      if (this.placeholder && this.value.length === 0) {
        this.displayLabel = "";
      } else {
        this.displayLabel = this.localize.term(
          "numOptionsSelected",
          this.selectedOptions.length,
        );
      }
    } else {
      const selectedOption = this.selectedOptions[0];
      this.value =
        (_a2 = selectedOption == null ? void 0 : selectedOption.value) != null
          ? _a2
          : "";
      this.displayLabel =
        (_c2 =
          (_b2 =
            selectedOption == null ? void 0 : selectedOption.getTextLabel) ==
          null
            ? void 0
            : _b2.call(selectedOption)) != null
          ? _c2
          : "";
    }
    this.valueHasChanged = cachedValueHasChanged;
    this.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  get tags() {
    return this.selectedOptions.map((option, index) => {
      if (index < this.maxOptionsVisible || this.maxOptionsVisible <= 0) {
        const tag = this.getTag(option, index);
        return x$2`<div @sl-remove=${(e3) => this.handleTagRemove(e3, option)}>
          ${typeof tag === "string" ? o$5(tag) : tag}
        </div>`;
      } else if (index === this.maxOptionsVisible) {
        return x$2`<sl-tag size=${this.size}>+${this.selectedOptions.length - index}</sl-tag>`;
      }
      return x$2``;
    });
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.open = false;
      this.handleOpenChange();
    }
  }
  attributeChangedCallback(name, oldVal, newVal) {
    super.attributeChangedCallback(name, oldVal, newVal);
    if (name === "value") {
      const cachedValueHasChanged = this.valueHasChanged;
      this.value = this.defaultValue;
      this.valueHasChanged = cachedValueHasChanged;
    }
  }
  handleValueChange() {
    if (!this.valueHasChanged) {
      const cachedValueHasChanged = this.valueHasChanged;
      this.value = this.defaultValue;
      this.valueHasChanged = cachedValueHasChanged;
    }
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    this.setSelectedOptions(
      allOptions.filter((el) => value.includes(el.value)),
    );
  }
  async handleOpenChange() {
    if (this.open && !this.disabled) {
      this.setCurrentOption(this.selectedOptions[0] || this.getFirstOption());
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.listbox.hidden = false;
      this.popup.active = true;
      requestAnimationFrame(() => {
        this.setCurrentOption(this.currentOption);
      });
      const { keyframes, options } = getAnimation(this, "select.show", {
        dir: this.localize.dir(),
      });
      await animateTo(this.popup.popup, keyframes, options);
      if (this.currentOption) {
        scrollIntoView(this.currentOption, this.listbox, "vertical", "auto");
      }
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "select.hide", {
        dir: this.localize.dir(),
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.listbox.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  /** Shows the listbox. */
  async show() {
    if (this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the listbox. */
  async hide() {
    if (!this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.valueInput.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.valueInput.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.valueInput.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  /** Sets focus on the control. */
  focus(options) {
    this.displayInput.focus(options);
  }
  /** Removes focus from the control. */
  blur() {
    this.displayInput.blur();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon =
      this.clearable && !this.disabled && this.value.length > 0;
    const isPlaceholderVisible =
      this.placeholder && this.value && this.value.length <= 0;
    return x$2`
      <div
        part="form-control"
        class=${e$4({
          "form-control": true,
          "form-control--small": this.size === "small",
          "form-control--medium": this.size === "medium",
          "form-control--large": this.size === "large",
          "form-control--has-label": hasLabel,
          "form-control--has-help-text": hasHelpText,
        })}
      >
        <label
          id="label"
          part="form-control-label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <sl-popup
            class=${e$4({
              select: true,
              "select--standard": true,
              "select--filled": this.filled,
              "select--pill": this.pill,
              "select--open": this.open,
              "select--disabled": this.disabled,
              "select--multiple": this.multiple,
              "select--focused": this.hasFocus,
              "select--placeholder-visible": isPlaceholderVisible,
              "select--top": this.placement === "top",
              "select--bottom": this.placement === "bottom",
              "select--small": this.size === "small",
              "select--medium": this.size === "medium",
              "select--large": this.size === "large",
            })}
            placement=${this.placement}
            strategy=${this.hoist ? "fixed" : "absolute"}
            flip
            shift
            sync="width"
            auto-size="vertical"
            auto-size-padding="10"
          >
            <div
              part="combobox"
              class="select__combobox"
              slot="anchor"
              @keydown=${this.handleComboboxKeyDown}
              @mousedown=${this.handleComboboxMouseDown}
            >
              <slot part="prefix" name="prefix" class="select__prefix"></slot>

              <input
                part="display-input"
                class="select__display-input"
                type="text"
                placeholder=${this.placeholder}
                .disabled=${this.disabled}
                .value=${this.displayLabel}
                autocomplete="off"
                spellcheck="false"
                autocapitalize="off"
                readonly
                aria-controls="listbox"
                aria-expanded=${this.open ? "true" : "false"}
                aria-haspopup="listbox"
                aria-labelledby="label"
                aria-disabled=${this.disabled ? "true" : "false"}
                aria-describedby="help-text"
                role="combobox"
                tabindex="0"
                @focus=${this.handleFocus}
                @blur=${this.handleBlur}
              />

              ${this.multiple ? x$2`<div part="tags" class="select__tags">${this.tags}</div>` : ""}

              <input
                class="select__value-input"
                type="text"
                ?disabled=${this.disabled}
                ?required=${this.required}
                .value=${Array.isArray(this.value) ? this.value.join(", ") : this.value}
                tabindex="-1"
                aria-hidden="true"
                @focus=${() => this.focus()}
                @invalid=${this.handleInvalid}
              />

              ${
                hasClearIcon
                  ? x$2`
                    <button
                      part="clear-button"
                      class="select__clear"
                      type="button"
                      aria-label=${this.localize.term("clearEntry")}
                      @mousedown=${this.handleClearMouseDown}
                      @click=${this.handleClearClick}
                      tabindex="-1"
                    >
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  `
                  : ""
              }

              <slot name="suffix" part="suffix" class="select__suffix"></slot>

              <slot name="expand-icon" part="expand-icon" class="select__expand-icon">
                <sl-icon library="system" name="chevron-down"></sl-icon>
              </slot>
            </div>

            <div
              id="listbox"
              role="listbox"
              aria-expanded=${this.open ? "true" : "false"}
              aria-multiselectable=${this.multiple ? "true" : "false"}
              aria-labelledby="label"
              part="listbox"
              class="select__listbox"
              tabindex="-1"
              @mouseup=${this.handleOptionClick}
              @slotchange=${this.handleDefaultSlotChange}
            >
              <slot></slot>
            </div>
          </sl-popup>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSelect.styles = [
  component_styles_default,
  form_control_styles_default,
  select_styles_default,
];
SlSelect.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-tag": SlTag,
};
__decorateClass([e$8(".select")], SlSelect.prototype, "popup", 2);
__decorateClass([e$8(".select__combobox")], SlSelect.prototype, "combobox", 2);
__decorateClass(
  [e$8(".select__display-input")],
  SlSelect.prototype,
  "displayInput",
  2,
);
__decorateClass(
  [e$8(".select__value-input")],
  SlSelect.prototype,
  "valueInput",
  2,
);
__decorateClass([e$8(".select__listbox")], SlSelect.prototype, "listbox", 2);
__decorateClass([r$4()], SlSelect.prototype, "hasFocus", 2);
__decorateClass([r$4()], SlSelect.prototype, "displayLabel", 2);
__decorateClass([r$4()], SlSelect.prototype, "currentOption", 2);
__decorateClass([r$4()], SlSelect.prototype, "selectedOptions", 2);
__decorateClass([r$4()], SlSelect.prototype, "valueHasChanged", 2);
__decorateClass([n$6()], SlSelect.prototype, "name", 2);
__decorateClass([r$4()], SlSelect.prototype, "value", 1);
__decorateClass(
  [n$6({ attribute: "value" })],
  SlSelect.prototype,
  "defaultValue",
  2,
);
__decorateClass([n$6({ reflect: true })], SlSelect.prototype, "size", 2);
__decorateClass([n$6()], SlSelect.prototype, "placeholder", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlSelect.prototype,
  "multiple",
  2,
);
__decorateClass(
  [n$6({ attribute: "max-options-visible", type: Number })],
  SlSelect.prototype,
  "maxOptionsVisible",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlSelect.prototype,
  "disabled",
  2,
);
__decorateClass([n$6({ type: Boolean })], SlSelect.prototype, "clearable", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlSelect.prototype,
  "open",
  2,
);
__decorateClass([n$6({ type: Boolean })], SlSelect.prototype, "hoist", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlSelect.prototype,
  "filled",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlSelect.prototype,
  "pill",
  2,
);
__decorateClass([n$6()], SlSelect.prototype, "label", 2);
__decorateClass([n$6({ reflect: true })], SlSelect.prototype, "placement", 2);
__decorateClass(
  [n$6({ attribute: "help-text" })],
  SlSelect.prototype,
  "helpText",
  2,
);
__decorateClass([n$6({ reflect: true })], SlSelect.prototype, "form", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlSelect.prototype,
  "required",
  2,
);
__decorateClass([n$6()], SlSelect.prototype, "getTag", 2);
__decorateClass(
  [watch("disabled", { waitUntilFirstUpdate: true })],
  SlSelect.prototype,
  "handleDisabledChange",
  1,
);
__decorateClass(
  [watch(["defaultValue", "value"], { waitUntilFirstUpdate: true })],
  SlSelect.prototype,
  "handleValueChange",
  1,
);
__decorateClass(
  [watch("open", { waitUntilFirstUpdate: true })],
  SlSelect.prototype,
  "handleOpenChange",
  1,
);
setDefaultAnimation("select.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 },
  ],
  options: { duration: 100, easing: "ease" },
});
setDefaultAnimation("select.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 },
  ],
  options: { duration: 100, easing: "ease" },
});
var tagName$J = "sl-select";
SlSelect.define("sl-select");
o$8({
  tagName: tagName$J,
  elementClass: SlSelect,
  react: React,
  events: {
    onSlChange: "sl-change",
    onSlClear: "sl-clear",
    onSlInput: "sl-input",
    onSlFocus: "sl-focus",
    onSlBlur: "sl-blur",
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide",
    onSlInvalid: "sl-invalid",
  },
  displayName: "SlSelect",
});
var skeleton_styles_default = i$8`
  :host {
    --border-radius: var(--sl-border-radius-pill);
    --color: var(--sl-color-neutral-200);
    --sheen-color: var(--sl-color-neutral-300);

    display: block;
    position: relative;
  }

  .skeleton {
    display: flex;
    width: 100%;
    height: 100%;
    min-height: 1rem;
  }

  .skeleton__indicator {
    flex: 1 1 auto;
    background: var(--color);
    border-radius: var(--border-radius);
  }

  .skeleton--sheen .skeleton__indicator {
    background: linear-gradient(270deg, var(--sheen-color), var(--color), var(--color), var(--sheen-color));
    background-size: 400% 100%;
    animation: sheen 8s ease-in-out infinite;
  }

  .skeleton--pulse .skeleton__indicator {
    animation: pulse 2s ease-in-out 0.5s infinite;
  }

  /* Forced colors mode */
  @media (forced-colors: active) {
    :host {
      --color: GrayText;
    }
  }

  @keyframes sheen {
    0% {
      background-position: 200% 0;
    }
    to {
      background-position: -200% 0;
    }
  }

  @keyframes pulse {
    0% {
      opacity: 1;
    }
    50% {
      opacity: 0.4;
    }
    100% {
      opacity: 1;
    }
  }
`;
var SlSkeleton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.effect = "none";
  }
  render() {
    return x$2`
      <div
        part="base"
        class=${e$4({
          skeleton: true,
          "skeleton--pulse": this.effect === "pulse",
          "skeleton--sheen": this.effect === "sheen",
        })}
      >
        <div part="indicator" class="skeleton__indicator"></div>
      </div>
    `;
  }
};
SlSkeleton.styles = [component_styles_default, skeleton_styles_default];
__decorateClass([n$6()], SlSkeleton.prototype, "effect", 2);
var tagName$I = "sl-skeleton";
SlSkeleton.define("sl-skeleton");
o$8({
  tagName: tagName$I,
  elementClass: SlSkeleton,
  react: React,
  events: {},
  displayName: "SlSkeleton",
});
var tagName$H = "sl-spinner";
SlSpinner.define("sl-spinner");
var reactWrapper$f = o$8({
  tagName: tagName$H,
  elementClass: SlSpinner,
  react: React,
  events: {},
  displayName: "SlSpinner",
});
var spinner_default = reactWrapper$f;
var split_panel_styles_default = i$8`
  :host {
    --divider-width: 4px;
    --divider-hit-area: 12px;
    --min: 0%;
    --max: 100%;

    display: grid;
  }

  .start,
  .end {
    overflow: hidden;
  }

  .divider {
    flex: 0 0 var(--divider-width);
    display: flex;
    position: relative;
    align-items: center;
    justify-content: center;
    background-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-900);
    z-index: 1;
  }

  .divider:focus {
    outline: none;
  }

  :host(:not([disabled])) .divider:focus-visible {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  :host([disabled]) .divider {
    cursor: not-allowed;
  }

  /* Horizontal */
  :host(:not([vertical], [disabled])) .divider {
    cursor: col-resize;
  }

  :host(:not([vertical])) .divider::after {
    display: flex;
    content: '';
    position: absolute;
    height: 100%;
    left: calc(var(--divider-hit-area) / -2 + var(--divider-width) / 2);
    width: var(--divider-hit-area);
  }

  /* Vertical */
  :host([vertical]) {
    flex-direction: column;
  }

  :host([vertical]:not([disabled])) .divider {
    cursor: row-resize;
  }

  :host([vertical]) .divider::after {
    content: '';
    position: absolute;
    width: 100%;
    top: calc(var(--divider-hit-area) / -2 + var(--divider-width) / 2);
    height: var(--divider-hit-area);
  }

  @media (forced-colors: active) {
    .divider {
      outline: solid 1px transparent;
    }
  }
`;
function drag(container, options) {
  function move(pointerEvent) {
    const dims = container.getBoundingClientRect();
    const defaultView = container.ownerDocument.defaultView;
    const offsetX = dims.left + defaultView.scrollX;
    const offsetY = dims.top + defaultView.scrollY;
    const x2 = pointerEvent.pageX - offsetX;
    const y2 = pointerEvent.pageY - offsetY;
    if (options == null ? void 0 : options.onMove) {
      options.onMove(x2, y2);
    }
  }
  function stop() {
    document.removeEventListener("pointermove", move);
    document.removeEventListener("pointerup", stop);
    if (options == null ? void 0 : options.onStop) {
      options.onStop();
    }
  }
  document.addEventListener("pointermove", move, { passive: true });
  document.addEventListener("pointerup", stop);
  if (
    (options == null ? void 0 : options.initialEvent) instanceof PointerEvent
  ) {
    move(options.initialEvent);
  }
}
var SNAP_NONE = () => null;
var SlSplitPanel = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.isCollapsed = false;
    this.localize = new LocalizeController2(this);
    this.positionBeforeCollapsing = 0;
    this.position = 50;
    this.vertical = false;
    this.disabled = false;
    this.snapValue = "";
    this.snapFunction = SNAP_NONE;
    this.snapThreshold = 12;
  }
  /**
   * Converts a string containing either a series of fixed/repeated snap points (e.g. "repeat(20%)", "100px 200px 800px", or "10% 50% repeat(10px)") into a SnapFunction. `SnapFunction`s take in a `SnapFunctionOpts` and return the position that the split panel should snap to.
   *
   * @param snap - The snap string.
   * @returns a `SnapFunction` representing the snap string's logic.
   */
  toSnapFunction(snap) {
    const snapPoints = snap.split(" ");
    return ({ pos, size: size2, snapThreshold, isRtl, vertical }) => {
      let newPos = pos;
      let minDistance = Number.POSITIVE_INFINITY;
      snapPoints.forEach((value) => {
        let snapPoint;
        if (value.startsWith("repeat(")) {
          const repeatVal = snap.substring("repeat(".length, snap.length - 1);
          const isPercent = repeatVal.endsWith("%");
          const repeatNum = Number.parseFloat(repeatVal);
          const snapIntervalPx = isPercent
            ? size2 * (repeatNum / 100)
            : repeatNum;
          snapPoint =
            Math.round(
              (isRtl && !vertical ? size2 - pos : pos) / snapIntervalPx,
            ) * snapIntervalPx;
        } else if (value.endsWith("%")) {
          snapPoint = size2 * (Number.parseFloat(value) / 100);
        } else {
          snapPoint = Number.parseFloat(value);
        }
        if (isRtl && !vertical) {
          snapPoint = size2 - snapPoint;
        }
        const distance = Math.abs(pos - snapPoint);
        if (distance <= snapThreshold && distance < minDistance) {
          newPos = snapPoint;
          minDistance = distance;
        }
      });
      return newPos;
    };
  }
  set snap(snap) {
    this.snapValue = snap != null ? snap : "";
    if (snap) {
      this.snapFunction =
        typeof snap === "string" ? this.toSnapFunction(snap) : snap;
    } else {
      this.snapFunction = SNAP_NONE;
    }
  }
  get snap() {
    return this.snapValue;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver((entries) =>
      this.handleResize(entries),
    );
    this.updateComplete.then(() => this.resizeObserver.observe(this));
    this.detectSize();
    this.cachedPositionInPixels = this.percentageToPixels(this.position);
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback();
    (_a2 = this.resizeObserver) == null ? void 0 : _a2.unobserve(this);
  }
  detectSize() {
    const { width, height } = this.getBoundingClientRect();
    this.size = this.vertical ? height : width;
  }
  percentageToPixels(value) {
    return this.size * (value / 100);
  }
  pixelsToPercentage(value) {
    return (value / this.size) * 100;
  }
  handleDrag(event) {
    const isRtl = this.localize.dir() === "rtl";
    if (this.disabled) {
      return;
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    drag(this, {
      onMove: (x2, y2) => {
        var _a2;
        let newPositionInPixels = this.vertical ? y2 : x2;
        if (this.primary === "end") {
          newPositionInPixels = this.size - newPositionInPixels;
        }
        newPositionInPixels =
          (_a2 = this.snapFunction({
            pos: newPositionInPixels,
            size: this.size,
            snapThreshold: this.snapThreshold,
            isRtl,
            vertical: this.vertical,
          })) != null
            ? _a2
            : newPositionInPixels;
        this.position = clamp(
          this.pixelsToPercentage(newPositionInPixels),
          0,
          100,
        );
      },
      initialEvent: event,
    });
  }
  handleKeyDown(event) {
    if (this.disabled) {
      return;
    }
    if (
      [
        "ArrowLeft",
        "ArrowRight",
        "ArrowUp",
        "ArrowDown",
        "Home",
        "End",
        "Enter",
      ].includes(event.key)
    ) {
      let newPosition = this.position;
      const incr =
        (event.shiftKey ? 10 : 1) * (this.primary === "end" ? -1 : 1);
      event.preventDefault();
      if (
        (event.key === "ArrowLeft" && !this.vertical) ||
        (event.key === "ArrowUp" && this.vertical)
      ) {
        newPosition -= incr;
      }
      if (
        (event.key === "ArrowRight" && !this.vertical) ||
        (event.key === "ArrowDown" && this.vertical)
      ) {
        newPosition += incr;
      }
      if (event.key === "Home") {
        newPosition = this.primary === "end" ? 100 : 0;
      }
      if (event.key === "End") {
        newPosition = this.primary === "end" ? 0 : 100;
      }
      if (event.key === "Enter") {
        if (this.isCollapsed) {
          newPosition = this.positionBeforeCollapsing;
          this.isCollapsed = false;
        } else {
          const positionBeforeCollapsing = this.position;
          newPosition = 0;
          requestAnimationFrame(() => {
            this.isCollapsed = true;
            this.positionBeforeCollapsing = positionBeforeCollapsing;
          });
        }
      }
      this.position = clamp(newPosition, 0, 100);
    }
  }
  handleResize(entries) {
    const { width, height } = entries[0].contentRect;
    this.size = this.vertical ? height : width;
    if (isNaN(this.cachedPositionInPixels) || this.position === Infinity) {
      this.cachedPositionInPixels = Number(
        this.getAttribute("position-in-pixels"),
      );
      this.positionInPixels = Number(this.getAttribute("position-in-pixels"));
      this.position = this.pixelsToPercentage(this.positionInPixels);
    }
    if (this.primary) {
      this.position = this.pixelsToPercentage(this.cachedPositionInPixels);
    }
  }
  handlePositionChange() {
    this.cachedPositionInPixels = this.percentageToPixels(this.position);
    this.isCollapsed = false;
    this.positionBeforeCollapsing = 0;
    this.positionInPixels = this.percentageToPixels(this.position);
    this.emit("sl-reposition");
  }
  handlePositionInPixelsChange() {
    this.position = this.pixelsToPercentage(this.positionInPixels);
  }
  handleVerticalChange() {
    this.detectSize();
  }
  render() {
    const gridTemplate = this.vertical
      ? "gridTemplateRows"
      : "gridTemplateColumns";
    const gridTemplateAlt = this.vertical
      ? "gridTemplateColumns"
      : "gridTemplateRows";
    const isRtl = this.localize.dir() === "rtl";
    const primary = `
      clamp(
        0%,
        clamp(
          var(--min),
          ${this.position}% - var(--divider-width) / 2,
          var(--max)
        ),
        calc(100% - var(--divider-width))
      )
    `;
    const secondary = "auto";
    if (this.primary === "end") {
      if (isRtl && !this.vertical) {
        this.style[gridTemplate] =
          `${primary} var(--divider-width) ${secondary}`;
      } else {
        this.style[gridTemplate] =
          `${secondary} var(--divider-width) ${primary}`;
      }
    } else {
      if (isRtl && !this.vertical) {
        this.style[gridTemplate] =
          `${secondary} var(--divider-width) ${primary}`;
      } else {
        this.style[gridTemplate] =
          `${primary} var(--divider-width) ${secondary}`;
      }
    }
    this.style[gridTemplateAlt] = "";
    return x$2`
      <slot name="start" part="panel start" class="start"></slot>

      <div
        part="divider"
        class="divider"
        tabindex=${o$7(this.disabled ? void 0 : "0")}
        role="separator"
        aria-valuenow=${this.position}
        aria-valuemin="0"
        aria-valuemax="100"
        aria-label=${this.localize.term("resize")}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleDrag}
        @touchstart=${this.handleDrag}
      >
        <slot name="divider"></slot>
      </div>

      <slot name="end" part="panel end" class="end"></slot>
    `;
  }
};
SlSplitPanel.styles = [component_styles_default, split_panel_styles_default];
__decorateClass([e$8(".divider")], SlSplitPanel.prototype, "divider", 2);
__decorateClass(
  [n$6({ type: Number, reflect: true })],
  SlSplitPanel.prototype,
  "position",
  2,
);
__decorateClass(
  [n$6({ attribute: "position-in-pixels", type: Number })],
  SlSplitPanel.prototype,
  "positionInPixels",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlSplitPanel.prototype,
  "vertical",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlSplitPanel.prototype,
  "disabled",
  2,
);
__decorateClass([n$6()], SlSplitPanel.prototype, "primary", 2);
__decorateClass([n$6({ reflect: true })], SlSplitPanel.prototype, "snap", 1);
__decorateClass(
  [n$6({ type: Number, attribute: "snap-threshold" })],
  SlSplitPanel.prototype,
  "snapThreshold",
  2,
);
__decorateClass(
  [watch("position")],
  SlSplitPanel.prototype,
  "handlePositionChange",
  1,
);
__decorateClass(
  [watch("positionInPixels")],
  SlSplitPanel.prototype,
  "handlePositionInPixelsChange",
  1,
);
__decorateClass(
  [watch("vertical")],
  SlSplitPanel.prototype,
  "handleVerticalChange",
  1,
);
var tagName$G = "sl-split-panel";
SlSplitPanel.define("sl-split-panel");
o$8({
  tagName: tagName$G,
  elementClass: SlSplitPanel,
  react: React,
  events: {
    onSlReposition: "sl-reposition",
  },
  displayName: "SlSplitPanel",
});
var tab_styles_default = i$8`
  :host {
    display: inline-block;
  }

  .tab {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    border-radius: var(--sl-border-radius-medium);
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-medium) var(--sl-spacing-large);
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
    transition:
      var(--transition-speed) box-shadow,
      var(--transition-speed) color;
  }

  .tab:hover:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  :host(:focus) {
    outline: transparent;
  }

  :host(:focus-visible) {
    color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: calc(-1 * var(--sl-focus-ring-width) - var(--sl-focus-ring-offset));
  }

  .tab.tab--active:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab.tab--closable {
    padding-inline-end: var(--sl-spacing-small);
  }

  .tab.tab--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tab__close-button {
    font-size: var(--sl-font-size-small);
    margin-inline-start: var(--sl-spacing-small);
  }

  .tab__close-button::part(base) {
    padding: var(--sl-spacing-3x-small);
  }

  @media (forced-colors: active) {
    .tab.tab--active:not(.tab--disabled) {
      outline: solid 1px transparent;
      outline-offset: -3px;
    }
  }
`;
var id = 0;
var SlTab = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.attrId = ++id;
    this.componentId = `sl-tab-${this.attrId}`;
    this.panel = "";
    this.active = false;
    this.closable = false;
    this.disabled = false;
    this.tabIndex = 0;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "tab");
  }
  handleCloseClick(event) {
    event.stopPropagation();
    this.emit("sl-close");
  }
  handleActiveChange() {
    this.setAttribute("aria-selected", this.active ? "true" : "false");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
    if (this.disabled && !this.active) {
      this.tabIndex = -1;
    } else {
      this.tabIndex = 0;
    }
  }
  render() {
    this.id = this.id.length > 0 ? this.id : this.componentId;
    return x$2`
      <div
        part="base"
        class=${e$4({
          tab: true,
          "tab--active": this.active,
          "tab--closable": this.closable,
          "tab--disabled": this.disabled,
        })}
      >
        <slot></slot>
        ${
          this.closable
            ? x$2`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                class="tab__close-button"
                @click=${this.handleCloseClick}
                tabindex="-1"
              ></sl-icon-button>
            `
            : ""
        }
      </div>
    `;
  }
};
SlTab.styles = [component_styles_default, tab_styles_default];
SlTab.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([e$8(".tab")], SlTab.prototype, "tab", 2);
__decorateClass([n$6({ reflect: true })], SlTab.prototype, "panel", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlTab.prototype,
  "active",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlTab.prototype,
  "closable",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlTab.prototype,
  "disabled",
  2,
);
__decorateClass(
  [n$6({ type: Number, reflect: true })],
  SlTab.prototype,
  "tabIndex",
  2,
);
__decorateClass([watch("active")], SlTab.prototype, "handleActiveChange", 1);
__decorateClass(
  [watch("disabled")],
  SlTab.prototype,
  "handleDisabledChange",
  1,
);
var tagName$F = "sl-tab";
SlTab.define("sl-tab");
o$8({
  tagName: tagName$F,
  elementClass: SlTab,
  react: React,
  events: {
    onSlClose: "sl-close",
  },
  displayName: "SlTab",
});
var mutation_observer_styles_default = i$8`
  :host {
    display: contents;
  }
`;
var SlMutationObserver = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.attrOldValue = false;
    this.charData = false;
    this.charDataOldValue = false;
    this.childList = false;
    this.disabled = false;
    this.handleMutation = (mutationList) => {
      this.emit("sl-mutation", {
        detail: { mutationList },
      });
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.mutationObserver = new MutationObserver(this.handleMutation);
    if (!this.disabled) {
      this.startObserver();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stopObserver();
  }
  startObserver() {
    const observeAttributes =
      typeof this.attr === "string" && this.attr.length > 0;
    const attributeFilter =
      observeAttributes && this.attr !== "*" ? this.attr.split(" ") : void 0;
    try {
      this.mutationObserver.observe(this, {
        subtree: true,
        childList: this.childList,
        attributes: observeAttributes,
        attributeFilter,
        attributeOldValue: this.attrOldValue,
        characterData: this.charData,
        characterDataOldValue: this.charDataOldValue,
      });
    } catch (e3) {}
  }
  stopObserver() {
    this.mutationObserver.disconnect();
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.stopObserver();
    } else {
      this.startObserver();
    }
  }
  handleChange() {
    this.stopObserver();
    this.startObserver();
  }
  render() {
    return x$2` <slot></slot> `;
  }
};
SlMutationObserver.styles = [
  component_styles_default,
  mutation_observer_styles_default,
];
__decorateClass(
  [n$6({ reflect: true })],
  SlMutationObserver.prototype,
  "attr",
  2,
);
__decorateClass(
  [n$6({ attribute: "attr-old-value", type: Boolean, reflect: true })],
  SlMutationObserver.prototype,
  "attrOldValue",
  2,
);
__decorateClass(
  [n$6({ attribute: "char-data", type: Boolean, reflect: true })],
  SlMutationObserver.prototype,
  "charData",
  2,
);
__decorateClass(
  [n$6({ attribute: "char-data-old-value", type: Boolean, reflect: true })],
  SlMutationObserver.prototype,
  "charDataOldValue",
  2,
);
__decorateClass(
  [n$6({ attribute: "child-list", type: Boolean, reflect: true })],
  SlMutationObserver.prototype,
  "childList",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlMutationObserver.prototype,
  "disabled",
  2,
);
__decorateClass(
  [watch("disabled")],
  SlMutationObserver.prototype,
  "handleDisabledChange",
  1,
);
__decorateClass(
  [
    watch("attr", { waitUntilFirstUpdate: true }),
    watch("attr-old-value", { waitUntilFirstUpdate: true }),
    watch("char-data", { waitUntilFirstUpdate: true }),
    watch("char-data-old-value", { waitUntilFirstUpdate: true }),
    watch("childList", { waitUntilFirstUpdate: true }),
  ],
  SlMutationObserver.prototype,
  "handleChange",
  1,
);
var tagName$E = "sl-mutation-observer";
SlMutationObserver.define("sl-mutation-observer");
o$8({
  tagName: tagName$E,
  elementClass: SlMutationObserver,
  react: React,
  events: {
    onSlMutation: "sl-mutation",
  },
  displayName: "SlMutationObserver",
});
var tagName$D = "sl-popup";
SlPopup.define("sl-popup");
o$8({
  tagName: tagName$D,
  elementClass: SlPopup,
  react: React,
  events: {
    onSlReposition: "sl-reposition",
  },
  displayName: "SlPopup",
});
var progress_ring_styles_default = i$8`
  :host {
    --size: 128px;
    --track-width: 4px;
    --track-color: var(--sl-color-neutral-200);
    --indicator-width: var(--track-width);
    --indicator-color: var(--sl-color-primary-600);
    --indicator-transition-duration: 0.35s;

    display: inline-flex;
  }

  .progress-ring {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .progress-ring__image {
    width: var(--size);
    height: var(--size);
    rotate: -90deg;
    transform-origin: 50% 50%;
  }

  .progress-ring__track,
  .progress-ring__indicator {
    --radius: calc(var(--size) / 2 - max(var(--track-width), var(--indicator-width)) * 0.5);
    --circumference: calc(var(--radius) * 2 * 3.141592654);

    fill: none;
    r: var(--radius);
    cx: calc(var(--size) / 2);
    cy: calc(var(--size) / 2);
  }

  .progress-ring__track {
    stroke: var(--track-color);
    stroke-width: var(--track-width);
  }

  .progress-ring__indicator {
    stroke: var(--indicator-color);
    stroke-width: var(--indicator-width);
    stroke-linecap: round;
    transition-property: stroke-dashoffset;
    transition-duration: var(--indicator-transition-duration);
    stroke-dasharray: var(--circumference) var(--circumference);
    stroke-dashoffset: calc(var(--circumference) - var(--percentage) * var(--circumference));
  }

  .progress-ring__label {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    text-align: center;
    user-select: none;
    -webkit-user-select: none;
  }
`;
var SlProgressRing = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.value = 0;
    this.label = "";
  }
  updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("value")) {
      const radius = parseFloat(
        getComputedStyle(this.indicator).getPropertyValue("r"),
      );
      const circumference = 2 * Math.PI * radius;
      const offset2 = circumference - (this.value / 100) * circumference;
      this.indicatorOffset = `${offset2}px`;
    }
  }
  render() {
    return x$2`
      <div
        part="base"
        class="progress-ring"
        role="progressbar"
        aria-label=${this.label.length > 0 ? this.label : this.localize.term("progress")}
        aria-describedby="label"
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow="${this.value}"
        style="--percentage: ${this.value / 100}"
      >
        <svg class="progress-ring__image">
          <circle class="progress-ring__track"></circle>
          <circle class="progress-ring__indicator" style="stroke-dashoffset: ${this.indicatorOffset}"></circle>
        </svg>

        <slot id="label" part="label" class="progress-ring__label"></slot>
      </div>
    `;
  }
};
SlProgressRing.styles = [
  component_styles_default,
  progress_ring_styles_default,
];
__decorateClass(
  [e$8(".progress-ring__indicator")],
  SlProgressRing.prototype,
  "indicator",
  2,
);
__decorateClass([r$4()], SlProgressRing.prototype, "indicatorOffset", 2);
__decorateClass(
  [n$6({ type: Number, reflect: true })],
  SlProgressRing.prototype,
  "value",
  2,
);
__decorateClass([n$6()], SlProgressRing.prototype, "label", 2);
var tagName$C = "sl-progress-ring";
SlProgressRing.define("sl-progress-ring");
o$8({
  tagName: tagName$C,
  elementClass: SlProgressRing,
  react: React,
  events: {},
  displayName: "SlProgressRing",
});
var radio_styles_default = i$8`
  :host {
    display: block;
  }

  :host(:focus-visible) {
    outline: 0px;
  }

  .radio {
    display: inline-flex;
    align-items: top;
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .radio--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .radio--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .radio--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .radio__checked-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  .radio__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 50%;
    background-color: var(--sl-input-background-color);
    color: transparent;
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .radio__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .radio:not(.radio--checked):not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Checked */
  .radio--checked .radio__control {
    color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked + hover */
  .radio.radio--checked:not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked + focus */
  :host(:focus-visible) .radio__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .radio--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When the control isn't checked, hide the circle for Windows High Contrast mode a11y */
  .radio:not(.radio--checked) svg circle {
    opacity: 0;
  }

  .radio__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }
`;
var SlRadio = class extends ShoelaceElement {
  constructor() {
    super();
    this.checked = false;
    this.hasFocus = false;
    this.size = "medium";
    this.disabled = false;
    this.handleBlur = () => {
      this.hasFocus = false;
      this.emit("sl-blur");
    };
    this.handleClick = () => {
      if (!this.disabled) {
        this.checked = true;
      }
    };
    this.handleFocus = () => {
      this.hasFocus = true;
      this.emit("sl-focus");
    };
    this.addEventListener("blur", this.handleBlur);
    this.addEventListener("click", this.handleClick);
    this.addEventListener("focus", this.handleFocus);
  }
  connectedCallback() {
    super.connectedCallback();
    this.setInitialAttributes();
  }
  setInitialAttributes() {
    this.setAttribute("role", "radio");
    this.setAttribute("tabindex", "-1");
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleCheckedChange() {
    this.setAttribute("aria-checked", this.checked ? "true" : "false");
    this.setAttribute("tabindex", this.checked ? "0" : "-1");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  render() {
    return x$2`
      <span
        part="base"
        class=${e$4({
          radio: true,
          "radio--checked": this.checked,
          "radio--disabled": this.disabled,
          "radio--focused": this.hasFocus,
          "radio--small": this.size === "small",
          "radio--medium": this.size === "medium",
          "radio--large": this.size === "large",
        })}
      >
        <span part="${`control${this.checked ? " control--checked" : ""}`}" class="radio__control">
          ${this.checked ? x$2` <sl-icon part="checked-icon" class="radio__checked-icon" library="system" name="radio"></sl-icon> ` : ""}
        </span>

        <slot part="label" class="radio__label"></slot>
      </span>
    `;
  }
};
SlRadio.styles = [component_styles_default, radio_styles_default];
SlRadio.dependencies = { "sl-icon": SlIcon };
__decorateClass([r$4()], SlRadio.prototype, "checked", 2);
__decorateClass([r$4()], SlRadio.prototype, "hasFocus", 2);
__decorateClass([n$6()], SlRadio.prototype, "value", 2);
__decorateClass([n$6({ reflect: true })], SlRadio.prototype, "size", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlRadio.prototype,
  "disabled",
  2,
);
__decorateClass(
  [watch("checked")],
  SlRadio.prototype,
  "handleCheckedChange",
  1,
);
__decorateClass(
  [watch("disabled", { waitUntilFirstUpdate: true })],
  SlRadio.prototype,
  "handleDisabledChange",
  1,
);
var tagName$B = "sl-radio";
SlRadio.define("sl-radio");
o$8({
  tagName: tagName$B,
  elementClass: SlRadio,
  react: React,
  events: {
    onSlBlur: "sl-blur",
    onSlFocus: "sl-focus",
  },
  displayName: "SlRadio",
});
var qr_code_styles_default = i$8`
  :host {
    display: inline-block;
  }
`;
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const n$2 = "important",
  i2 = " !" + n$2,
  o$4 = e$5(
    class extends i$3 {
      constructor(t$12) {
        var _a2;
        if (
          (super(t$12),
          t$12.type !== t.ATTRIBUTE ||
            "style" !== t$12.name ||
            ((_a2 = t$12.strings) == null ? void 0 : _a2.length) > 2)
        )
          throw Error(
            "The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.",
          );
      }
      render(t2) {
        return Object.keys(t2).reduce((e3, r3) => {
          const s2 = t2[r3];
          return null == s2
            ? e3
            : e3 +
                `${(r3 = r3.includes("-") ? r3 : r3.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase())}:${s2};`;
        }, "");
      }
      update(e3, [r3]) {
        const { style: s2 } = e3.element;
        if (void 0 === this.ft)
          return (this.ft = new Set(Object.keys(r3))), this.render(r3);
        for (const t2 of this.ft)
          null == r3[t2] &&
            (this.ft.delete(t2),
            t2.includes("-") ? s2.removeProperty(t2) : (s2[t2] = null));
        for (const t2 in r3) {
          const e4 = r3[t2];
          if (null != e4) {
            this.ft.add(t2);
            const r4 = "string" == typeof e4 && e4.endsWith(i2);
            t2.includes("-") || r4
              ? s2.setProperty(t2, r4 ? e4.slice(0, -11) : e4, r4 ? n$2 : "")
              : (s2[t2] = e4);
          }
        }
        return T$2;
      }
    },
  );
let G = null;
class H2 {}
H2.render = function (w2, B2) {
  G(w2, B2);
};
self.QrCreator = H2;
(function (w2) {
  function B2(t2, c2, a2, e3) {
    var b3 = {},
      h2 = w2(a2, c2);
    h2.u(t2);
    h2.J();
    e3 = e3 || 0;
    var r3 = h2.h(),
      d2 = h2.h() + 2 * e3;
    b3.text = t2;
    b3.level = c2;
    b3.version = a2;
    b3.O = d2;
    b3.a = function (b4, a3) {
      b4 -= e3;
      a3 -= e3;
      return 0 > b4 || b4 >= r3 || 0 > a3 || a3 >= r3 ? false : h2.a(b4, a3);
    };
    return b3;
  }
  function C2(t2, c2, a2, e3, b3, h2, r3, d2, g2, x2) {
    function u2(b4, a3, f2, c3, d3, r4, g3) {
      b4
        ? (t2.lineTo(a3 + r4, f2 + g3), t2.arcTo(a3, f2, c3, d3, h2))
        : t2.lineTo(a3, f2);
    }
    r3 ? t2.moveTo(c2 + h2, a2) : t2.moveTo(c2, a2);
    u2(d2, e3, a2, e3, b3, -h2, 0);
    u2(g2, e3, b3, c2, b3, 0, -h2);
    u2(x2, c2, b3, c2, a2, h2, 0);
    u2(r3, c2, a2, e3, a2, 0, h2);
  }
  function z3(t2, c2, a2, e3, b3, h2, r3, d2, g2, x2) {
    function u2(b4, a3, c3, d3) {
      t2.moveTo(b4 + c3, a3);
      t2.lineTo(b4, a3);
      t2.lineTo(b4, a3 + d3);
      t2.arcTo(b4, a3, b4 + c3, a3, h2);
    }
    r3 && u2(c2, a2, h2, h2);
    d2 && u2(e3, a2, -h2, h2);
    g2 && u2(e3, b3, -h2, -h2);
    x2 && u2(c2, b3, h2, -h2);
  }
  function A2(t2, c2) {
    var a2 = c2.fill;
    if ("string" === typeof a2) t2.fillStyle = a2;
    else {
      var e3 = a2.type,
        b3 = a2.colorStops;
      a2 = a2.position.map((b4) => Math.round(b4 * c2.size));
      if ("linear-gradient" === e3)
        var h2 = t2.createLinearGradient.apply(t2, a2);
      else if ("radial-gradient" === e3)
        h2 = t2.createRadialGradient.apply(t2, a2);
      else throw Error("Unsupported fill");
      b3.forEach(([b4, a3]) => {
        h2.addColorStop(b4, a3);
      });
      t2.fillStyle = h2;
    }
  }
  function y2(t2, c2) {
    a: {
      var a2 = c2.text,
        e3 = c2.v,
        b3 = c2.N,
        h2 = c2.K,
        r3 = c2.P;
      b3 = Math.max(1, b3 || 1);
      for (h2 = Math.min(40, h2 || 40); b3 <= h2; b3 += 1)
        try {
          var d2 = B2(a2, e3, b3, r3);
          break a;
        } catch (J2) {}
      d2 = void 0;
    }
    if (!d2) return null;
    a2 = t2.getContext("2d");
    c2.background &&
      ((a2.fillStyle = c2.background),
      a2.fillRect(c2.left, c2.top, c2.size, c2.size));
    e3 = d2.O;
    h2 = c2.size / e3;
    a2.beginPath();
    for (r3 = 0; r3 < e3; r3 += 1)
      for (b3 = 0; b3 < e3; b3 += 1) {
        var g2 = a2,
          x2 = c2.left + b3 * h2,
          u2 = c2.top + r3 * h2,
          p2 = r3,
          q2 = b3,
          f2 = d2.a,
          k3 = x2 + h2,
          m2 = u2 + h2,
          D2 = p2 - 1,
          E2 = p2 + 1,
          n3 = q2 - 1,
          l2 = q2 + 1,
          y3 = Math.floor(Math.min(0.5, Math.max(0, c2.R)) * h2),
          v3 = f2(p2, q2),
          I3 = f2(D2, n3),
          w3 = f2(D2, q2);
        D2 = f2(D2, l2);
        var F2 = f2(p2, l2);
        l2 = f2(E2, l2);
        q2 = f2(E2, q2);
        E2 = f2(E2, n3);
        p2 = f2(p2, n3);
        x2 = Math.round(x2);
        u2 = Math.round(u2);
        k3 = Math.round(k3);
        m2 = Math.round(m2);
        v3
          ? C2(
              g2,
              x2,
              u2,
              k3,
              m2,
              y3,
              !w3 && !p2,
              !w3 && !F2,
              !q2 && !F2,
              !q2 && !p2,
            )
          : z3(
              g2,
              x2,
              u2,
              k3,
              m2,
              y3,
              w3 && p2 && I3,
              w3 && F2 && D2,
              q2 && F2 && l2,
              q2 && p2 && E2,
            );
      }
    A2(a2, c2);
    a2.fill();
    return t2;
  }
  var v2 = {
    minVersion: 1,
    maxVersion: 40,
    ecLevel: "L",
    left: 0,
    top: 0,
    size: 200,
    fill: "#000",
    background: null,
    text: "no text",
    radius: 0.5,
    quiet: 0,
  };
  G = function (t2, c2) {
    var a2 = {};
    Object.assign(a2, v2, t2);
    a2.N = a2.minVersion;
    a2.K = a2.maxVersion;
    a2.v = a2.ecLevel;
    a2.left = a2.left;
    a2.top = a2.top;
    a2.size = a2.size;
    a2.fill = a2.fill;
    a2.background = a2.background;
    a2.text = a2.text;
    a2.R = a2.radius;
    a2.P = a2.quiet;
    if (c2 instanceof HTMLCanvasElement) {
      if (c2.width !== a2.size || c2.height !== a2.size)
        (c2.width = a2.size), (c2.height = a2.size);
      c2.getContext("2d").clearRect(0, 0, c2.width, c2.height);
      y2(c2, a2);
    } else
      (t2 = document.createElement("canvas")),
        (t2.width = a2.size),
        (t2.height = a2.size),
        (a2 = y2(t2, a2)),
        c2.appendChild(a2);
  };
})(
  (function () {
    function w2(c2) {
      var a2 = C2.s(c2);
      return {
        S: function () {
          return 4;
        },
        b: function () {
          return a2.length;
        },
        write: function (c3) {
          for (var b3 = 0; b3 < a2.length; b3 += 1) c3.put(a2[b3], 8);
        },
      };
    }
    function B2() {
      var c2 = [],
        a2 = 0,
        e3 = {
          B: function () {
            return c2;
          },
          c: function (b3) {
            return 1 == ((c2[Math.floor(b3 / 8)] >>> (7 - (b3 % 8))) & 1);
          },
          put: function (b3, h2) {
            for (var a3 = 0; a3 < h2; a3 += 1)
              e3.m(1 == ((b3 >>> (h2 - a3 - 1)) & 1));
          },
          f: function () {
            return a2;
          },
          m: function (b3) {
            var h2 = Math.floor(a2 / 8);
            c2.length <= h2 && c2.push(0);
            b3 && (c2[h2] |= 128 >>> a2 % 8);
            a2 += 1;
          },
        };
      return e3;
    }
    function C2(c2, a2) {
      function e3(b4, h3) {
        for (var a3 = -1; 7 >= a3; a3 += 1)
          if (!(-1 >= b4 + a3 || d2 <= b4 + a3))
            for (var c3 = -1; 7 >= c3; c3 += 1)
              -1 >= h3 + c3 ||
                d2 <= h3 + c3 ||
                (r3[b4 + a3][h3 + c3] =
                  (0 <= a3 && 6 >= a3 && (0 == c3 || 6 == c3)) ||
                  (0 <= c3 && 6 >= c3 && (0 == a3 || 6 == a3)) ||
                  (2 <= a3 && 4 >= a3 && 2 <= c3 && 4 >= c3)
                    ? true
                    : false);
      }
      function b3(b4, a3) {
        for (
          var f2 = (d2 = 4 * c2 + 17), k3 = Array(f2), m2 = 0;
          m2 < f2;
          m2 += 1
        ) {
          k3[m2] = Array(f2);
          for (var p2 = 0; p2 < f2; p2 += 1) k3[m2][p2] = null;
        }
        r3 = k3;
        e3(0, 0);
        e3(d2 - 7, 0);
        e3(0, d2 - 7);
        f2 = y2.G(c2);
        for (k3 = 0; k3 < f2.length; k3 += 1)
          for (m2 = 0; m2 < f2.length; m2 += 1) {
            p2 = f2[k3];
            var q2 = f2[m2];
            if (null == r3[p2][q2])
              for (var n3 = -2; 2 >= n3; n3 += 1)
                for (var l2 = -2; 2 >= l2; l2 += 1)
                  r3[p2 + n3][q2 + l2] =
                    -2 == n3 ||
                    2 == n3 ||
                    -2 == l2 ||
                    2 == l2 ||
                    (0 == n3 && 0 == l2);
          }
        for (f2 = 8; f2 < d2 - 8; f2 += 1)
          null == r3[f2][6] && (r3[f2][6] = 0 == f2 % 2);
        for (f2 = 8; f2 < d2 - 8; f2 += 1)
          null == r3[6][f2] && (r3[6][f2] = 0 == f2 % 2);
        f2 = y2.w((h2 << 3) | a3);
        for (k3 = 0; 15 > k3; k3 += 1)
          (m2 = !b4 && 1 == ((f2 >> k3) & 1)),
            (r3[6 > k3 ? k3 : 8 > k3 ? k3 + 1 : d2 - 15 + k3][8] = m2),
            (r3[8][8 > k3 ? d2 - k3 - 1 : 9 > k3 ? 15 - k3 : 14 - k3] = m2);
        r3[d2 - 8][8] = !b4;
        if (7 <= c2) {
          f2 = y2.A(c2);
          for (k3 = 0; 18 > k3; k3 += 1)
            (m2 = !b4 && 1 == ((f2 >> k3) & 1)),
              (r3[Math.floor(k3 / 3)][(k3 % 3) + d2 - 8 - 3] = m2);
          for (k3 = 0; 18 > k3; k3 += 1)
            (m2 = !b4 && 1 == ((f2 >> k3) & 1)),
              (r3[(k3 % 3) + d2 - 8 - 3][Math.floor(k3 / 3)] = m2);
        }
        if (null == g2) {
          b4 = t2.I(c2, h2);
          f2 = B2();
          for (k3 = 0; k3 < x2.length; k3 += 1)
            (m2 = x2[k3]),
              f2.put(4, 4),
              f2.put(m2.b(), y2.f(4, c2)),
              m2.write(f2);
          for (k3 = m2 = 0; k3 < b4.length; k3 += 1) m2 += b4[k3].j;
          if (f2.f() > 8 * m2)
            throw Error(
              "code length overflow. (" + f2.f() + ">" + 8 * m2 + ")",
            );
          for (f2.f() + 4 <= 8 * m2 && f2.put(0, 4); 0 != f2.f() % 8; )
            f2.m(false);
          for (; !(f2.f() >= 8 * m2); ) {
            f2.put(236, 8);
            if (f2.f() >= 8 * m2) break;
            f2.put(17, 8);
          }
          var u3 = 0;
          m2 = k3 = 0;
          p2 = Array(b4.length);
          q2 = Array(b4.length);
          for (n3 = 0; n3 < b4.length; n3 += 1) {
            var v3 = b4[n3].j,
              w3 = b4[n3].o - v3;
            k3 = Math.max(k3, v3);
            m2 = Math.max(m2, w3);
            p2[n3] = Array(v3);
            for (l2 = 0; l2 < p2[n3].length; l2 += 1)
              p2[n3][l2] = 255 & f2.B()[l2 + u3];
            u3 += v3;
            l2 = y2.C(w3);
            v3 = z3(p2[n3], l2.b() - 1).l(l2);
            q2[n3] = Array(l2.b() - 1);
            for (l2 = 0; l2 < q2[n3].length; l2 += 1)
              (w3 = l2 + v3.b() - q2[n3].length),
                (q2[n3][l2] = 0 <= w3 ? v3.c(w3) : 0);
          }
          for (l2 = f2 = 0; l2 < b4.length; l2 += 1) f2 += b4[l2].o;
          f2 = Array(f2);
          for (l2 = u3 = 0; l2 < k3; l2 += 1)
            for (n3 = 0; n3 < b4.length; n3 += 1)
              l2 < p2[n3].length && ((f2[u3] = p2[n3][l2]), (u3 += 1));
          for (l2 = 0; l2 < m2; l2 += 1)
            for (n3 = 0; n3 < b4.length; n3 += 1)
              l2 < q2[n3].length && ((f2[u3] = q2[n3][l2]), (u3 += 1));
          g2 = f2;
        }
        b4 = g2;
        f2 = -1;
        k3 = d2 - 1;
        m2 = 7;
        p2 = 0;
        a3 = y2.F(a3);
        for (q2 = d2 - 1; 0 < q2; q2 -= 2)
          for (6 == q2 && --q2; ; ) {
            for (n3 = 0; 2 > n3; n3 += 1)
              null == r3[k3][q2 - n3] &&
                ((l2 = false),
                p2 < b4.length && (l2 = 1 == ((b4[p2] >>> m2) & 1)),
                a3(k3, q2 - n3) && (l2 = !l2),
                (r3[k3][q2 - n3] = l2),
                --m2,
                -1 == m2 && ((p2 += 1), (m2 = 7)));
            k3 += f2;
            if (0 > k3 || d2 <= k3) {
              k3 -= f2;
              f2 = -f2;
              break;
            }
          }
      }
      var h2 = A2[a2],
        r3 = null,
        d2 = 0,
        g2 = null,
        x2 = [],
        u2 = {
          u: function (b4) {
            b4 = w2(b4);
            x2.push(b4);
            g2 = null;
          },
          a: function (b4, a3) {
            if (0 > b4 || d2 <= b4 || 0 > a3 || d2 <= a3)
              throw Error(b4 + "," + a3);
            return r3[b4][a3];
          },
          h: function () {
            return d2;
          },
          J: function () {
            for (var a3 = 0, h3 = 0, c3 = 0; 8 > c3; c3 += 1) {
              b3(true, c3);
              var d3 = y2.D(u2);
              if (0 == c3 || a3 > d3) (a3 = d3), (h3 = c3);
            }
            b3(false, h3);
          },
        };
      return u2;
    }
    function z3(c2, a2) {
      if ("undefined" == typeof c2.length) throw Error(c2.length + "/" + a2);
      var e3 = (function () {
          for (var b4 = 0; b4 < c2.length && 0 == c2[b4]; ) b4 += 1;
          for (
            var r3 = Array(c2.length - b4 + a2), d2 = 0;
            d2 < c2.length - b4;
            d2 += 1
          )
            r3[d2] = c2[d2 + b4];
          return r3;
        })(),
        b3 = {
          c: function (b4) {
            return e3[b4];
          },
          b: function () {
            return e3.length;
          },
          multiply: function (a3) {
            for (
              var h2 = Array(b3.b() + a3.b() - 1), c3 = 0;
              c3 < b3.b();
              c3 += 1
            )
              for (var g2 = 0; g2 < a3.b(); g2 += 1)
                h2[c3 + g2] ^= v2.i(v2.g(b3.c(c3)) + v2.g(a3.c(g2)));
            return z3(h2, 0);
          },
          l: function (a3) {
            if (0 > b3.b() - a3.b()) return b3;
            for (
              var c3 = v2.g(b3.c(0)) - v2.g(a3.c(0)),
                h2 = Array(b3.b()),
                g2 = 0;
              g2 < b3.b();
              g2 += 1
            )
              h2[g2] = b3.c(g2);
            for (g2 = 0; g2 < a3.b(); g2 += 1)
              h2[g2] ^= v2.i(v2.g(a3.c(g2)) + c3);
            return z3(h2, 0).l(a3);
          },
        };
      return b3;
    }
    C2.s = function (c2) {
      for (var a2 = [], e3 = 0; e3 < c2.length; e3++) {
        var b3 = c2.charCodeAt(e3);
        128 > b3
          ? a2.push(b3)
          : 2048 > b3
            ? a2.push(192 | (b3 >> 6), 128 | (b3 & 63))
            : 55296 > b3 || 57344 <= b3
              ? a2.push(
                  224 | (b3 >> 12),
                  128 | ((b3 >> 6) & 63),
                  128 | (b3 & 63),
                )
              : (e3++,
                (b3 =
                  65536 + (((b3 & 1023) << 10) | (c2.charCodeAt(e3) & 1023))),
                a2.push(
                  240 | (b3 >> 18),
                  128 | ((b3 >> 12) & 63),
                  128 | ((b3 >> 6) & 63),
                  128 | (b3 & 63),
                ));
      }
      return a2;
    };
    var A2 = { L: 1, M: 0, Q: 3, H: 2 },
      y2 = /* @__PURE__ */ (function () {
        function c2(b3) {
          for (var a3 = 0; 0 != b3; ) (a3 += 1), (b3 >>>= 1);
          return a3;
        }
        var a2 = [
            [],
            [6, 18],
            [6, 22],
            [6, 26],
            [6, 30],
            [6, 34],
            [6, 22, 38],
            [6, 24, 42],
            [6, 26, 46],
            [6, 28, 50],
            [6, 30, 54],
            [6, 32, 58],
            [6, 34, 62],
            [6, 26, 46, 66],
            [6, 26, 48, 70],
            [6, 26, 50, 74],
            [6, 30, 54, 78],
            [6, 30, 56, 82],
            [6, 30, 58, 86],
            [6, 34, 62, 90],
            [6, 28, 50, 72, 94],
            [6, 26, 50, 74, 98],
            [6, 30, 54, 78, 102],
            [6, 28, 54, 80, 106],
            [6, 32, 58, 84, 110],
            [6, 30, 58, 86, 114],
            [6, 34, 62, 90, 118],
            [6, 26, 50, 74, 98, 122],
            [6, 30, 54, 78, 102, 126],
            [6, 26, 52, 78, 104, 130],
            [6, 30, 56, 82, 108, 134],
            [6, 34, 60, 86, 112, 138],
            [6, 30, 58, 86, 114, 142],
            [6, 34, 62, 90, 118, 146],
            [6, 30, 54, 78, 102, 126, 150],
            [6, 24, 50, 76, 102, 128, 154],
            [6, 28, 54, 80, 106, 132, 158],
            [6, 32, 58, 84, 110, 136, 162],
            [6, 26, 54, 82, 110, 138, 166],
            [6, 30, 58, 86, 114, 142, 170],
          ],
          e3 = {
            w: function (b3) {
              for (var a3 = b3 << 10; 0 <= c2(a3) - c2(1335); )
                a3 ^= 1335 << (c2(a3) - c2(1335));
              return ((b3 << 10) | a3) ^ 21522;
            },
            A: function (b3) {
              for (var a3 = b3 << 12; 0 <= c2(a3) - c2(7973); )
                a3 ^= 7973 << (c2(a3) - c2(7973));
              return (b3 << 12) | a3;
            },
            G: function (b3) {
              return a2[b3 - 1];
            },
            F: function (b3) {
              switch (b3) {
                case 0:
                  return function (b4, a3) {
                    return 0 == (b4 + a3) % 2;
                  };
                case 1:
                  return function (b4) {
                    return 0 == b4 % 2;
                  };
                case 2:
                  return function (b4, a3) {
                    return 0 == a3 % 3;
                  };
                case 3:
                  return function (b4, a3) {
                    return 0 == (b4 + a3) % 3;
                  };
                case 4:
                  return function (b4, a3) {
                    return 0 == (Math.floor(b4 / 2) + Math.floor(a3 / 3)) % 2;
                  };
                case 5:
                  return function (b4, a3) {
                    return 0 == ((b4 * a3) % 2) + ((b4 * a3) % 3);
                  };
                case 6:
                  return function (b4, a3) {
                    return 0 == (((b4 * a3) % 2) + ((b4 * a3) % 3)) % 2;
                  };
                case 7:
                  return function (b4, a3) {
                    return 0 == (((b4 * a3) % 3) + ((b4 + a3) % 2)) % 2;
                  };
                default:
                  throw Error("bad maskPattern:" + b3);
              }
            },
            C: function (b3) {
              for (var a3 = z3([1], 0), c3 = 0; c3 < b3; c3 += 1)
                a3 = a3.multiply(z3([1, v2.i(c3)], 0));
              return a3;
            },
            f: function (b3, a3) {
              if (4 != b3 || 1 > a3 || 40 < a3)
                throw Error("mode: " + b3 + "; type: " + a3);
              return 10 > a3 ? 8 : 16;
            },
            D: function (b3) {
              for (var a3 = b3.h(), c3 = 0, d2 = 0; d2 < a3; d2 += 1)
                for (var g2 = 0; g2 < a3; g2 += 1) {
                  for (var e4 = 0, t3 = b3.a(d2, g2), p2 = -1; 1 >= p2; p2 += 1)
                    if (!(0 > d2 + p2 || a3 <= d2 + p2))
                      for (var q2 = -1; 1 >= q2; q2 += 1)
                        0 > g2 + q2 ||
                          a3 <= g2 + q2 ||
                          ((0 != p2 || 0 != q2) &&
                            t3 == b3.a(d2 + p2, g2 + q2) &&
                            (e4 += 1));
                  5 < e4 && (c3 += 3 + e4 - 5);
                }
              for (d2 = 0; d2 < a3 - 1; d2 += 1)
                for (g2 = 0; g2 < a3 - 1; g2 += 1)
                  if (
                    ((e4 = 0),
                    b3.a(d2, g2) && (e4 += 1),
                    b3.a(d2 + 1, g2) && (e4 += 1),
                    b3.a(d2, g2 + 1) && (e4 += 1),
                    b3.a(d2 + 1, g2 + 1) && (e4 += 1),
                    0 == e4 || 4 == e4)
                  )
                    c3 += 3;
              for (d2 = 0; d2 < a3; d2 += 1)
                for (g2 = 0; g2 < a3 - 6; g2 += 1)
                  b3.a(d2, g2) &&
                    !b3.a(d2, g2 + 1) &&
                    b3.a(d2, g2 + 2) &&
                    b3.a(d2, g2 + 3) &&
                    b3.a(d2, g2 + 4) &&
                    !b3.a(d2, g2 + 5) &&
                    b3.a(d2, g2 + 6) &&
                    (c3 += 40);
              for (g2 = 0; g2 < a3; g2 += 1)
                for (d2 = 0; d2 < a3 - 6; d2 += 1)
                  b3.a(d2, g2) &&
                    !b3.a(d2 + 1, g2) &&
                    b3.a(d2 + 2, g2) &&
                    b3.a(d2 + 3, g2) &&
                    b3.a(d2 + 4, g2) &&
                    !b3.a(d2 + 5, g2) &&
                    b3.a(d2 + 6, g2) &&
                    (c3 += 40);
              for (g2 = e4 = 0; g2 < a3; g2 += 1)
                for (d2 = 0; d2 < a3; d2 += 1) b3.a(d2, g2) && (e4 += 1);
              return (c3 += (Math.abs((100 * e4) / a3 / a3 - 50) / 5) * 10);
            },
          };
        return e3;
      })(),
      v2 = (function () {
        for (var c2 = Array(256), a2 = Array(256), e3 = 0; 8 > e3; e3 += 1)
          c2[e3] = 1 << e3;
        for (e3 = 8; 256 > e3; e3 += 1)
          c2[e3] = c2[e3 - 4] ^ c2[e3 - 5] ^ c2[e3 - 6] ^ c2[e3 - 8];
        for (e3 = 0; 255 > e3; e3 += 1) a2[c2[e3]] = e3;
        return {
          g: function (b3) {
            if (1 > b3) throw Error("glog(" + b3 + ")");
            return a2[b3];
          },
          i: function (b3) {
            for (; 0 > b3; ) b3 += 255;
            for (; 256 <= b3; ) b3 -= 255;
            return c2[b3];
          },
        };
      })(),
      t2 = /* @__PURE__ */ (function () {
        function c2(b3, c3) {
          switch (c3) {
            case A2.L:
              return a2[4 * (b3 - 1)];
            case A2.M:
              return a2[4 * (b3 - 1) + 1];
            case A2.Q:
              return a2[4 * (b3 - 1) + 2];
            case A2.H:
              return a2[4 * (b3 - 1) + 3];
          }
        }
        var a2 = [
            [1, 26, 19],
            [1, 26, 16],
            [1, 26, 13],
            [1, 26, 9],
            [1, 44, 34],
            [1, 44, 28],
            [1, 44, 22],
            [1, 44, 16],
            [1, 70, 55],
            [1, 70, 44],
            [2, 35, 17],
            [2, 35, 13],
            [1, 100, 80],
            [2, 50, 32],
            [2, 50, 24],
            [4, 25, 9],
            [1, 134, 108],
            [2, 67, 43],
            [2, 33, 15, 2, 34, 16],
            [2, 33, 11, 2, 34, 12],
            [2, 86, 68],
            [4, 43, 27],
            [4, 43, 19],
            [4, 43, 15],
            [2, 98, 78],
            [4, 49, 31],
            [2, 32, 14, 4, 33, 15],
            [4, 39, 13, 1, 40, 14],
            [2, 121, 97],
            [2, 60, 38, 2, 61, 39],
            [4, 40, 18, 2, 41, 19],
            [4, 40, 14, 2, 41, 15],
            [2, 146, 116],
            [3, 58, 36, 2, 59, 37],
            [4, 36, 16, 4, 37, 17],
            [4, 36, 12, 4, 37, 13],
            [2, 86, 68, 2, 87, 69],
            [4, 69, 43, 1, 70, 44],
            [6, 43, 19, 2, 44, 20],
            [6, 43, 15, 2, 44, 16],
            [4, 101, 81],
            [1, 80, 50, 4, 81, 51],
            [4, 50, 22, 4, 51, 23],
            [3, 36, 12, 8, 37, 13],
            [2, 116, 92, 2, 117, 93],
            [6, 58, 36, 2, 59, 37],
            [4, 46, 20, 6, 47, 21],
            [7, 42, 14, 4, 43, 15],
            [4, 133, 107],
            [8, 59, 37, 1, 60, 38],
            [8, 44, 20, 4, 45, 21],
            [12, 33, 11, 4, 34, 12],
            [3, 145, 115, 1, 146, 116],
            [4, 64, 40, 5, 65, 41],
            [11, 36, 16, 5, 37, 17],
            [11, 36, 12, 5, 37, 13],
            [5, 109, 87, 1, 110, 88],
            [5, 65, 41, 5, 66, 42],
            [5, 54, 24, 7, 55, 25],
            [11, 36, 12, 7, 37, 13],
            [5, 122, 98, 1, 123, 99],
            [7, 73, 45, 3, 74, 46],
            [15, 43, 19, 2, 44, 20],
            [3, 45, 15, 13, 46, 16],
            [1, 135, 107, 5, 136, 108],
            [10, 74, 46, 1, 75, 47],
            [1, 50, 22, 15, 51, 23],
            [2, 42, 14, 17, 43, 15],
            [5, 150, 120, 1, 151, 121],
            [9, 69, 43, 4, 70, 44],
            [17, 50, 22, 1, 51, 23],
            [2, 42, 14, 19, 43, 15],
            [3, 141, 113, 4, 142, 114],
            [3, 70, 44, 11, 71, 45],
            [17, 47, 21, 4, 48, 22],
            [9, 39, 13, 16, 40, 14],
            [3, 135, 107, 5, 136, 108],
            [3, 67, 41, 13, 68, 42],
            [15, 54, 24, 5, 55, 25],
            [15, 43, 15, 10, 44, 16],
            [4, 144, 116, 4, 145, 117],
            [17, 68, 42],
            [17, 50, 22, 6, 51, 23],
            [19, 46, 16, 6, 47, 17],
            [2, 139, 111, 7, 140, 112],
            [17, 74, 46],
            [7, 54, 24, 16, 55, 25],
            [34, 37, 13],
            [4, 151, 121, 5, 152, 122],
            [4, 75, 47, 14, 76, 48],
            [11, 54, 24, 14, 55, 25],
            [16, 45, 15, 14, 46, 16],
            [6, 147, 117, 4, 148, 118],
            [6, 73, 45, 14, 74, 46],
            [11, 54, 24, 16, 55, 25],
            [30, 46, 16, 2, 47, 17],
            [8, 132, 106, 4, 133, 107],
            [8, 75, 47, 13, 76, 48],
            [7, 54, 24, 22, 55, 25],
            [22, 45, 15, 13, 46, 16],
            [10, 142, 114, 2, 143, 115],
            [19, 74, 46, 4, 75, 47],
            [28, 50, 22, 6, 51, 23],
            [33, 46, 16, 4, 47, 17],
            [8, 152, 122, 4, 153, 123],
            [22, 73, 45, 3, 74, 46],
            [8, 53, 23, 26, 54, 24],
            [12, 45, 15, 28, 46, 16],
            [3, 147, 117, 10, 148, 118],
            [3, 73, 45, 23, 74, 46],
            [4, 54, 24, 31, 55, 25],
            [11, 45, 15, 31, 46, 16],
            [7, 146, 116, 7, 147, 117],
            [21, 73, 45, 7, 74, 46],
            [1, 53, 23, 37, 54, 24],
            [19, 45, 15, 26, 46, 16],
            [5, 145, 115, 10, 146, 116],
            [19, 75, 47, 10, 76, 48],
            [15, 54, 24, 25, 55, 25],
            [23, 45, 15, 25, 46, 16],
            [13, 145, 115, 3, 146, 116],
            [2, 74, 46, 29, 75, 47],
            [42, 54, 24, 1, 55, 25],
            [23, 45, 15, 28, 46, 16],
            [17, 145, 115],
            [10, 74, 46, 23, 75, 47],
            [10, 54, 24, 35, 55, 25],
            [19, 45, 15, 35, 46, 16],
            [17, 145, 115, 1, 146, 116],
            [14, 74, 46, 21, 75, 47],
            [29, 54, 24, 19, 55, 25],
            [11, 45, 15, 46, 46, 16],
            [13, 145, 115, 6, 146, 116],
            [14, 74, 46, 23, 75, 47],
            [44, 54, 24, 7, 55, 25],
            [59, 46, 16, 1, 47, 17],
            [12, 151, 121, 7, 152, 122],
            [12, 75, 47, 26, 76, 48],
            [39, 54, 24, 14, 55, 25],
            [22, 45, 15, 41, 46, 16],
            [6, 151, 121, 14, 152, 122],
            [6, 75, 47, 34, 76, 48],
            [46, 54, 24, 10, 55, 25],
            [2, 45, 15, 64, 46, 16],
            [17, 152, 122, 4, 153, 123],
            [29, 74, 46, 14, 75, 47],
            [49, 54, 24, 10, 55, 25],
            [24, 45, 15, 46, 46, 16],
            [4, 152, 122, 18, 153, 123],
            [13, 74, 46, 32, 75, 47],
            [48, 54, 24, 14, 55, 25],
            [42, 45, 15, 32, 46, 16],
            [20, 147, 117, 4, 148, 118],
            [40, 75, 47, 7, 76, 48],
            [43, 54, 24, 22, 55, 25],
            [10, 45, 15, 67, 46, 16],
            [19, 148, 118, 6, 149, 119],
            [18, 75, 47, 31, 76, 48],
            [34, 54, 24, 34, 55, 25],
            [20, 45, 15, 61, 46, 16],
          ],
          e3 = {
            I: function (b3, a3) {
              var e4 = c2(b3, a3);
              if ("undefined" == typeof e4)
                throw Error(
                  "bad rs block @ typeNumber:" +
                    b3 +
                    "/errorCorrectLevel:" +
                    a3,
                );
              b3 = e4.length / 3;
              a3 = [];
              for (var d2 = 0; d2 < b3; d2 += 1)
                for (
                  var g2 = e4[3 * d2],
                    h2 = e4[3 * d2 + 1],
                    t3 = e4[3 * d2 + 2],
                    p2 = 0;
                  p2 < g2;
                  p2 += 1
                ) {
                  var q2 = t3,
                    f2 = {};
                  f2.o = h2;
                  f2.j = q2;
                  a3.push(f2);
                }
              return a3;
            },
          };
        return e3;
      })();
    return C2;
  })(),
);
const QrCreator$1 = QrCreator;
var SlQrCode = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.value = "";
    this.label = "";
    this.size = 128;
    this.fill = "black";
    this.background = "white";
    this.radius = 0;
    this.errorCorrection = "H";
  }
  firstUpdated() {
    this.generate();
  }
  generate() {
    if (!this.hasUpdated) {
      return;
    }
    QrCreator$1.render(
      {
        text: this.value,
        radius: this.radius,
        ecLevel: this.errorCorrection,
        fill: this.fill,
        background: this.background,
        // We draw the canvas larger and scale its container down to avoid blurring on high-density displays
        size: this.size * 2,
      },
      this.canvas,
    );
  }
  render() {
    var _a2;
    return x$2`
      <canvas
        part="base"
        class="qr-code"
        role="img"
        aria-label=${((_a2 = this.label) == null ? void 0 : _a2.length) > 0 ? this.label : this.value}
        style=${o$4({
          width: `${this.size}px`,
          height: `${this.size}px`,
        })}
      ></canvas>
    `;
  }
};
SlQrCode.styles = [component_styles_default, qr_code_styles_default];
__decorateClass([e$8("canvas")], SlQrCode.prototype, "canvas", 2);
__decorateClass([n$6()], SlQrCode.prototype, "value", 2);
__decorateClass([n$6()], SlQrCode.prototype, "label", 2);
__decorateClass([n$6({ type: Number })], SlQrCode.prototype, "size", 2);
__decorateClass([n$6()], SlQrCode.prototype, "fill", 2);
__decorateClass([n$6()], SlQrCode.prototype, "background", 2);
__decorateClass([n$6({ type: Number })], SlQrCode.prototype, "radius", 2);
__decorateClass(
  [n$6({ attribute: "error-correction" })],
  SlQrCode.prototype,
  "errorCorrection",
  2,
);
__decorateClass(
  [watch(["background", "errorCorrection", "fill", "radius", "size", "value"])],
  SlQrCode.prototype,
  "generate",
  1,
);
var tagName$A = "sl-qr-code";
SlQrCode.define("sl-qr-code");
o$8({
  tagName: tagName$A,
  elementClass: SlQrCode,
  react: React,
  events: {},
  displayName: "SlQrCode",
});
var button_styles_default = i$8`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host([data-sl-button-group__button--first]:not([data-sl-button-group__button--last])) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host([data-sl-button-group__button--inner]) .button {
    border-radius: 0;
  }

  :host([data-sl-button-group__button--last]:not([data-sl-button-group__button--first])) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host([data-sl-button-group__button]:not([data-sl-button-group__button--first])) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      [data-sl-button-group__button]:not(
          [data-sl-button-group__button--first],
          [data-sl-button-group__button--radio],
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host([data-sl-button-group__button--hover]) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host([data-sl-button-group__button--focus]),
  :host([data-sl-button-group__button][checked]) {
    z-index: 2;
  }
`;
var radio_button_styles_default = i$8`
  ${button_styles_default}

  .button__prefix,
  .button__suffix,
  .button__label {
    display: inline-flex;
    position: relative;
    align-items: center;
  }

  /* We use a hidden input so constraint validation errors work, since they don't appear to show when used with buttons.
    We can't actually hide it, though, otherwise the messages will be suppressed by the browser. */
  .hidden-input {
    all: unset;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    outline: dotted 1px red;
    opacity: 0;
    z-index: -1;
  }
`;
var SlRadioButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(
      this,
      "[default]",
      "prefix",
      "suffix",
    );
    this.hasFocus = false;
    this.checked = false;
    this.disabled = false;
    this.size = "medium";
    this.pill = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "presentation");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleClick(e3) {
    if (this.disabled) {
      e3.preventDefault();
      e3.stopPropagation();
      return;
    }
    this.checked = true;
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  /** Sets focus on the radio button. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the radio button. */
  blur() {
    this.input.blur();
  }
  render() {
    return u`
      <div part="base" role="presentation">
        <button
          part="${`button${this.checked ? " button--checked" : ""}`}"
          role="radio"
          aria-checked="${this.checked}"
          class=${e$4({
            button: true,
            "button--default": true,
            "button--small": this.size === "small",
            "button--medium": this.size === "medium",
            "button--large": this.size === "large",
            "button--checked": this.checked,
            "button--disabled": this.disabled,
            "button--focused": this.hasFocus,
            "button--outline": true,
            "button--pill": this.pill,
            "button--has-label": this.hasSlotController.test("[default]"),
            "button--has-prefix": this.hasSlotController.test("prefix"),
            "button--has-suffix": this.hasSlotController.test("suffix"),
          })}
          aria-disabled=${this.disabled}
          type="button"
          value=${o$7(this.value)}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
          @click=${this.handleClick}
        >
          <slot name="prefix" part="prefix" class="button__prefix"></slot>
          <slot part="label" class="button__label"></slot>
          <slot name="suffix" part="suffix" class="button__suffix"></slot>
        </button>
      </div>
    `;
  }
};
SlRadioButton.styles = [component_styles_default, radio_button_styles_default];
__decorateClass([e$8(".button")], SlRadioButton.prototype, "input", 2);
__decorateClass(
  [e$8(".hidden-input")],
  SlRadioButton.prototype,
  "hiddenInput",
  2,
);
__decorateClass([r$4()], SlRadioButton.prototype, "hasFocus", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlRadioButton.prototype,
  "checked",
  2,
);
__decorateClass([n$6()], SlRadioButton.prototype, "value", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlRadioButton.prototype,
  "disabled",
  2,
);
__decorateClass([n$6({ reflect: true })], SlRadioButton.prototype, "size", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlRadioButton.prototype,
  "pill",
  2,
);
__decorateClass(
  [watch("disabled", { waitUntilFirstUpdate: true })],
  SlRadioButton.prototype,
  "handleDisabledChange",
  1,
);
var tagName$z = "sl-radio-button";
SlRadioButton.define("sl-radio-button");
o$8({
  tagName: tagName$z,
  elementClass: SlRadioButton,
  react: React,
  events: {
    onSlBlur: "sl-blur",
    onSlFocus: "sl-focus",
  },
  displayName: "SlRadioButton",
});
var radio_group_styles_default = i$8`
  :host {
    display: block;
  }

  .form-control {
    position: relative;
    border: none;
    padding: 0;
    margin: 0;
  }

  .form-control__label {
    padding: 0;
  }

  .radio-group--required .radio-group__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
`;
var button_group_styles_default = i$8`
  :host {
    display: inline-block;
  }

  .button-group {
    display: flex;
    flex-wrap: nowrap;
  }
`;
var SlButtonGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.disableRole = false;
    this.label = "";
  }
  handleFocus(event) {
    const button = findButton(event.target);
    button == null
      ? void 0
      : button.toggleAttribute("data-sl-button-group__button--focus", true);
  }
  handleBlur(event) {
    const button = findButton(event.target);
    button == null
      ? void 0
      : button.toggleAttribute("data-sl-button-group__button--focus", false);
  }
  handleMouseOver(event) {
    const button = findButton(event.target);
    button == null
      ? void 0
      : button.toggleAttribute("data-sl-button-group__button--hover", true);
  }
  handleMouseOut(event) {
    const button = findButton(event.target);
    button == null
      ? void 0
      : button.toggleAttribute("data-sl-button-group__button--hover", false);
  }
  handleSlotChange() {
    const slottedElements = [
      ...this.defaultSlot.assignedElements({ flatten: true }),
    ];
    slottedElements.forEach((el) => {
      const index = slottedElements.indexOf(el);
      const button = findButton(el);
      if (button) {
        button.toggleAttribute("data-sl-button-group__button", true);
        button.toggleAttribute(
          "data-sl-button-group__button--first",
          index === 0,
        );
        button.toggleAttribute(
          "data-sl-button-group__button--inner",
          index > 0 && index < slottedElements.length - 1,
        );
        button.toggleAttribute(
          "data-sl-button-group__button--last",
          index === slottedElements.length - 1,
        );
        button.toggleAttribute(
          "data-sl-button-group__button--radio",
          button.tagName.toLowerCase() === "sl-radio-button",
        );
      }
    });
  }
  render() {
    return x$2`
      <div
        part="base"
        class="button-group"
        role="${this.disableRole ? "presentation" : "group"}"
        aria-label=${this.label}
        @focusout=${this.handleBlur}
        @focusin=${this.handleFocus}
        @mouseover=${this.handleMouseOver}
        @mouseout=${this.handleMouseOut}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
  }
};
SlButtonGroup.styles = [component_styles_default, button_group_styles_default];
__decorateClass([e$8("slot")], SlButtonGroup.prototype, "defaultSlot", 2);
__decorateClass([r$4()], SlButtonGroup.prototype, "disableRole", 2);
__decorateClass([n$6()], SlButtonGroup.prototype, "label", 2);
function findButton(el) {
  var _a2;
  const selector = "sl-button, sl-radio-button";
  return (_a2 = el.closest(selector)) != null
    ? _a2
    : el.querySelector(selector);
}
var SlRadioGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this);
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.customValidityMessage = "";
    this.hasButtonGroup = false;
    this.errorMessage = "";
    this.defaultValue = "";
    this.label = "";
    this.helpText = "";
    this.name = "option";
    this.value = "";
    this.size = "medium";
    this.form = "";
    this.required = false;
  }
  /** Gets the validity state object */
  get validity() {
    const isRequiredAndEmpty = this.required && !this.value;
    const hasCustomValidityMessage = this.customValidityMessage !== "";
    if (hasCustomValidityMessage) {
      return customErrorValidityState;
    } else if (isRequiredAndEmpty) {
      return valueMissingValidityState;
    }
    return validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    const isRequiredAndEmpty = this.required && !this.value;
    const hasCustomValidityMessage = this.customValidityMessage !== "";
    if (hasCustomValidityMessage) {
      return this.customValidityMessage;
    } else if (isRequiredAndEmpty) {
      return this.validationInput.validationMessage;
    }
    return "";
  }
  connectedCallback() {
    super.connectedCallback();
    this.defaultValue = this.value;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  getAllRadios() {
    return [...this.querySelectorAll("sl-radio, sl-radio-button")];
  }
  handleRadioClick(event) {
    const target = event.target.closest("sl-radio, sl-radio-button");
    const radios = this.getAllRadios();
    const oldValue = this.value;
    if (!target || target.disabled) {
      return;
    }
    this.value = target.value;
    radios.forEach((radio) => (radio.checked = radio === target));
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleKeyDown(event) {
    var _a2;
    if (
      !["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(
        event.key,
      )
    ) {
      return;
    }
    const radios = this.getAllRadios().filter((radio) => !radio.disabled);
    const checkedRadio =
      (_a2 = radios.find((radio) => radio.checked)) != null ? _a2 : radios[0];
    const incr =
      event.key === " "
        ? 0
        : ["ArrowUp", "ArrowLeft"].includes(event.key)
          ? -1
          : 1;
    const oldValue = this.value;
    let index = radios.indexOf(checkedRadio) + incr;
    if (index < 0) {
      index = radios.length - 1;
    }
    if (index > radios.length - 1) {
      index = 0;
    }
    this.getAllRadios().forEach((radio) => {
      radio.checked = false;
      if (!this.hasButtonGroup) {
        radio.setAttribute("tabindex", "-1");
      }
    });
    this.value = radios[index].value;
    radios[index].checked = true;
    if (!this.hasButtonGroup) {
      radios[index].setAttribute("tabindex", "0");
      radios[index].focus();
    } else {
      radios[index].shadowRoot.querySelector("button").focus();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
    event.preventDefault();
  }
  handleLabelClick() {
    this.focus();
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  async syncRadioElements() {
    var _a2, _b2;
    const radios = this.getAllRadios();
    await Promise.all(
      // Sync the checked state and size
      radios.map(async (radio) => {
        await radio.updateComplete;
        radio.checked = radio.value === this.value;
        radio.size = this.size;
      }),
    );
    this.hasButtonGroup = radios.some(
      (radio) => radio.tagName.toLowerCase() === "sl-radio-button",
    );
    if (radios.length > 0 && !radios.some((radio) => radio.checked)) {
      if (this.hasButtonGroup) {
        const buttonRadio =
          (_a2 = radios[0].shadowRoot) == null
            ? void 0
            : _a2.querySelector("button");
        if (buttonRadio) {
          buttonRadio.setAttribute("tabindex", "0");
        }
      } else {
        radios[0].setAttribute("tabindex", "0");
      }
    }
    if (this.hasButtonGroup) {
      const buttonGroup =
        (_b2 = this.shadowRoot) == null
          ? void 0
          : _b2.querySelector("sl-button-group");
      if (buttonGroup) {
        buttonGroup.disableRole = true;
      }
    }
  }
  syncRadios() {
    if (
      customElements.get("sl-radio") &&
      customElements.get("sl-radio-button")
    ) {
      this.syncRadioElements();
      return;
    }
    if (customElements.get("sl-radio")) {
      this.syncRadioElements();
    } else {
      customElements.whenDefined("sl-radio").then(() => this.syncRadios());
    }
    if (customElements.get("sl-radio-button")) {
      this.syncRadioElements();
    } else {
      customElements
        .whenDefined("sl-radio-button")
        .then(() => this.syncRadios());
    }
  }
  updateCheckedRadio() {
    const radios = this.getAllRadios();
    radios.forEach((radio) => (radio.checked = radio.value === this.value));
    this.formControlController.setValidity(this.validity.valid);
  }
  handleSizeChange() {
    this.syncRadios();
  }
  handleValueChange() {
    if (this.hasUpdated) {
      this.updateCheckedRadio();
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    const isRequiredAndEmpty = this.required && !this.value;
    const hasCustomValidityMessage = this.customValidityMessage !== "";
    if (isRequiredAndEmpty || hasCustomValidityMessage) {
      this.formControlController.emitInvalidEvent();
      return false;
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    const isValid = this.validity.valid;
    this.errorMessage =
      this.customValidityMessage || isValid
        ? ""
        : this.validationInput.validationMessage;
    this.formControlController.setValidity(isValid);
    this.validationInput.hidden = true;
    clearTimeout(this.validationTimeout);
    if (!isValid) {
      this.validationInput.hidden = false;
      this.validationInput.reportValidity();
      this.validationTimeout = setTimeout(
        () => (this.validationInput.hidden = true),
        1e4,
      );
    }
    return isValid;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message = "") {
    this.customValidityMessage = message;
    this.errorMessage = message;
    this.validationInput.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  /** Sets focus on the radio-group. */
  focus(options) {
    const radios = this.getAllRadios();
    const checked = radios.find((radio) => radio.checked);
    const firstEnabledRadio = radios.find((radio) => !radio.disabled);
    const radioToFocus = checked || firstEnabledRadio;
    if (radioToFocus) {
      radioToFocus.focus(options);
    }
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const defaultSlot = x$2`
      <slot @slotchange=${this.syncRadios} @click=${this.handleRadioClick} @keydown=${this.handleKeyDown}></slot>
    `;
    return x$2`
      <fieldset
        part="form-control"
        class=${e$4({
          "form-control": true,
          "form-control--small": this.size === "small",
          "form-control--medium": this.size === "medium",
          "form-control--large": this.size === "large",
          "form-control--radio-group": true,
          "form-control--has-label": hasLabel,
          "form-control--has-help-text": hasHelpText,
        })}
        role="radiogroup"
        aria-labelledby="label"
        aria-describedby="help-text"
        aria-errormessage="error-message"
      >
        <label
          part="form-control-label"
          id="label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div class="visually-hidden">
            <div id="error-message" aria-live="assertive">${this.errorMessage}</div>
            <label class="radio-group__validation">
              <input
                type="text"
                class="radio-group__validation-input"
                ?required=${this.required}
                tabindex="-1"
                hidden
                @invalid=${this.handleInvalid}
              />
            </label>
          </div>

          ${
            this.hasButtonGroup
              ? x$2`
                <sl-button-group part="button-group" exportparts="base:button-group__base" role="presentation">
                  ${defaultSlot}
                </sl-button-group>
              `
              : defaultSlot
          }
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </fieldset>
    `;
  }
};
SlRadioGroup.styles = [
  component_styles_default,
  form_control_styles_default,
  radio_group_styles_default,
];
SlRadioGroup.dependencies = { "sl-button-group": SlButtonGroup };
__decorateClass(
  [e$8("slot:not([name])")],
  SlRadioGroup.prototype,
  "defaultSlot",
  2,
);
__decorateClass(
  [e$8(".radio-group__validation-input")],
  SlRadioGroup.prototype,
  "validationInput",
  2,
);
__decorateClass([r$4()], SlRadioGroup.prototype, "hasButtonGroup", 2);
__decorateClass([r$4()], SlRadioGroup.prototype, "errorMessage", 2);
__decorateClass([r$4()], SlRadioGroup.prototype, "defaultValue", 2);
__decorateClass([n$6()], SlRadioGroup.prototype, "label", 2);
__decorateClass(
  [n$6({ attribute: "help-text" })],
  SlRadioGroup.prototype,
  "helpText",
  2,
);
__decorateClass([n$6()], SlRadioGroup.prototype, "name", 2);
__decorateClass([n$6({ reflect: true })], SlRadioGroup.prototype, "value", 2);
__decorateClass([n$6({ reflect: true })], SlRadioGroup.prototype, "size", 2);
__decorateClass([n$6({ reflect: true })], SlRadioGroup.prototype, "form", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlRadioGroup.prototype,
  "required",
  2,
);
__decorateClass(
  [watch("size", { waitUntilFirstUpdate: true })],
  SlRadioGroup.prototype,
  "handleSizeChange",
  1,
);
__decorateClass(
  [watch("value")],
  SlRadioGroup.prototype,
  "handleValueChange",
  1,
);
var tagName$y = "sl-radio-group";
SlRadioGroup.define("sl-radio-group");
o$8({
  tagName: tagName$y,
  elementClass: SlRadioGroup,
  react: React,
  events: {
    onSlChange: "sl-change",
    onSlInput: "sl-input",
    onSlInvalid: "sl-invalid",
  },
  displayName: "SlRadioGroup",
});
var rating_styles_default = i$8`
  :host {
    --symbol-color: var(--sl-color-neutral-300);
    --symbol-color-active: var(--sl-color-amber-500);
    --symbol-size: 1.2rem;
    --symbol-spacing: var(--sl-spacing-3x-small);

    display: inline-flex;
  }

  .rating {
    position: relative;
    display: inline-flex;
    border-radius: var(--sl-border-radius-medium);
    vertical-align: middle;
  }

  .rating:focus {
    outline: none;
  }

  .rating:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .rating__symbols {
    display: inline-flex;
    position: relative;
    font-size: var(--symbol-size);
    line-height: 0;
    color: var(--symbol-color);
    white-space: nowrap;
    cursor: pointer;
  }

  .rating__symbols > * {
    padding: var(--symbol-spacing);
  }

  .rating__symbol--active,
  .rating__partial--filled {
    color: var(--symbol-color-active);
  }

  .rating__partial-symbol-container {
    position: relative;
  }

  .rating__partial--filled {
    position: absolute;
    top: var(--symbol-spacing);
    left: var(--symbol-spacing);
  }

  .rating__symbol {
    transition: var(--sl-transition-fast) scale;
    pointer-events: none;
  }

  .rating__symbol--hover {
    scale: 1.2;
  }

  .rating--disabled .rating__symbols,
  .rating--readonly .rating__symbols {
    cursor: default;
  }

  .rating--disabled .rating__symbol--hover,
  .rating--readonly .rating__symbol--hover {
    scale: none;
  }

  .rating--disabled {
    opacity: 0.5;
  }

  .rating--disabled .rating__symbols {
    cursor: not-allowed;
  }

  /* Forced colors mode */
  @media (forced-colors: active) {
    .rating__symbol--active {
      color: SelectedItem;
    }
  }
`;
var SlRating = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.hoverValue = 0;
    this.isHovering = false;
    this.label = "";
    this.value = 0;
    this.max = 5;
    this.precision = 1;
    this.readonly = false;
    this.disabled = false;
    this.getSymbol = () =>
      '<sl-icon name="star-fill" library="system"></sl-icon>';
  }
  getValueFromMousePosition(event) {
    return this.getValueFromXCoordinate(event.clientX);
  }
  getValueFromTouchPosition(event) {
    return this.getValueFromXCoordinate(event.touches[0].clientX);
  }
  getValueFromXCoordinate(coordinate) {
    const isRtl = this.localize.dir() === "rtl";
    const { left, right, width } = this.rating.getBoundingClientRect();
    const value = isRtl
      ? this.roundToPrecision(
          ((right - coordinate) / width) * this.max,
          this.precision,
        )
      : this.roundToPrecision(
          ((coordinate - left) / width) * this.max,
          this.precision,
        );
    return clamp(value, 0, this.max);
  }
  handleClick(event) {
    if (this.disabled) {
      return;
    }
    this.setValue(this.getValueFromMousePosition(event));
    this.emit("sl-change");
  }
  setValue(newValue) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.value = newValue === this.value ? 0 : newValue;
    this.isHovering = false;
  }
  handleKeyDown(event) {
    const isLtr = this.localize.dir() === "ltr";
    const isRtl = this.localize.dir() === "rtl";
    const oldValue = this.value;
    if (this.disabled || this.readonly) {
      return;
    }
    if (
      event.key === "ArrowDown" ||
      (isLtr && event.key === "ArrowLeft") ||
      (isRtl && event.key === "ArrowRight")
    ) {
      const decrement = event.shiftKey ? 1 : this.precision;
      this.value = Math.max(0, this.value - decrement);
      event.preventDefault();
    }
    if (
      event.key === "ArrowUp" ||
      (isLtr && event.key === "ArrowRight") ||
      (isRtl && event.key === "ArrowLeft")
    ) {
      const increment = event.shiftKey ? 1 : this.precision;
      this.value = Math.min(this.max, this.value + increment);
      event.preventDefault();
    }
    if (event.key === "Home") {
      this.value = 0;
      event.preventDefault();
    }
    if (event.key === "End") {
      this.value = this.max;
      event.preventDefault();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
    }
  }
  handleMouseEnter(event) {
    this.isHovering = true;
    this.hoverValue = this.getValueFromMousePosition(event);
  }
  handleMouseMove(event) {
    this.hoverValue = this.getValueFromMousePosition(event);
  }
  handleMouseLeave() {
    this.isHovering = false;
  }
  handleTouchStart(event) {
    this.isHovering = true;
    this.hoverValue = this.getValueFromTouchPosition(event);
    event.preventDefault();
  }
  handleTouchMove(event) {
    this.hoverValue = this.getValueFromTouchPosition(event);
  }
  handleTouchEnd(event) {
    this.isHovering = false;
    this.setValue(this.hoverValue);
    this.emit("sl-change");
    event.preventDefault();
  }
  roundToPrecision(numberToRound, precision = 0.5) {
    const multiplier = 1 / precision;
    return Math.ceil(numberToRound * multiplier) / multiplier;
  }
  handleHoverValueChange() {
    this.emit("sl-hover", {
      detail: {
        phase: "move",
        value: this.hoverValue,
      },
    });
  }
  handleIsHoveringChange() {
    this.emit("sl-hover", {
      detail: {
        phase: this.isHovering ? "start" : "end",
        value: this.hoverValue,
      },
    });
  }
  /** Sets focus on the rating. */
  focus(options) {
    this.rating.focus(options);
  }
  /** Removes focus from the rating. */
  blur() {
    this.rating.blur();
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    const counter = Array.from(Array(this.max).keys());
    let displayValue = 0;
    if (this.disabled || this.readonly) {
      displayValue = this.value;
    } else {
      displayValue = this.isHovering ? this.hoverValue : this.value;
    }
    return x$2`
      <div
        part="base"
        class=${e$4({
          rating: true,
          "rating--readonly": this.readonly,
          "rating--disabled": this.disabled,
          "rating--rtl": isRtl,
        })}
        role="slider"
        aria-label=${this.label}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-readonly=${this.readonly ? "true" : "false"}
        aria-valuenow=${this.value}
        aria-valuemin=${0}
        aria-valuemax=${this.max}
        tabindex=${this.disabled || this.readonly ? "-1" : "0"}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mouseenter=${this.handleMouseEnter}
        @touchstart=${this.handleTouchStart}
        @mouseleave=${this.handleMouseLeave}
        @touchend=${this.handleTouchEnd}
        @mousemove=${this.handleMouseMove}
        @touchmove=${this.handleTouchMove}
      >
        <span class="rating__symbols">
          ${counter.map((index) => {
            if (displayValue > index && displayValue < index + 1) {
              return x$2`
                <span
                  class=${e$4({
                    rating__symbol: true,
                    "rating__partial-symbol-container": true,
                    "rating__symbol--hover":
                      this.isHovering && Math.ceil(displayValue) === index + 1,
                  })}
                  role="presentation"
                >
                  <div
                    style=${o$4({
                      clipPath: isRtl
                        ? `inset(0 ${(displayValue - index) * 100}% 0 0)`
                        : `inset(0 0 0 ${(displayValue - index) * 100}%)`,
                    })}
                  >
                    ${o$5(this.getSymbol(index + 1))}
                  </div>
                  <div
                    class="rating__partial--filled"
                    style=${o$4({
                      clipPath: isRtl
                        ? `inset(0 0 0 ${100 - (displayValue - index) * 100}%)`
                        : `inset(0 ${100 - (displayValue - index) * 100}% 0 0)`,
                    })}
                  >
                    ${o$5(this.getSymbol(index + 1))}
                  </div>
                </span>
              `;
            }
            return x$2`
              <span
                class=${e$4({
                  rating__symbol: true,
                  "rating__symbol--hover":
                    this.isHovering && Math.ceil(displayValue) === index + 1,
                  "rating__symbol--active": displayValue >= index + 1,
                })}
                role="presentation"
              >
                ${o$5(this.getSymbol(index + 1))}
              </span>
            `;
          })}
        </span>
      </div>
    `;
  }
};
SlRating.styles = [component_styles_default, rating_styles_default];
SlRating.dependencies = { "sl-icon": SlIcon };
__decorateClass([e$8(".rating")], SlRating.prototype, "rating", 2);
__decorateClass([r$4()], SlRating.prototype, "hoverValue", 2);
__decorateClass([r$4()], SlRating.prototype, "isHovering", 2);
__decorateClass([n$6()], SlRating.prototype, "label", 2);
__decorateClass([n$6({ type: Number })], SlRating.prototype, "value", 2);
__decorateClass([n$6({ type: Number })], SlRating.prototype, "max", 2);
__decorateClass([n$6({ type: Number })], SlRating.prototype, "precision", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlRating.prototype,
  "readonly",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlRating.prototype,
  "disabled",
  2,
);
__decorateClass([n$6()], SlRating.prototype, "getSymbol", 2);
__decorateClass(
  [t$3({ passive: true })],
  SlRating.prototype,
  "handleTouchMove",
  1,
);
__decorateClass(
  [watch("hoverValue")],
  SlRating.prototype,
  "handleHoverValueChange",
  1,
);
__decorateClass(
  [watch("isHovering")],
  SlRating.prototype,
  "handleIsHoveringChange",
  1,
);
var tagName$x = "sl-rating";
SlRating.define("sl-rating");
o$8({
  tagName: tagName$x,
  elementClass: SlRating,
  react: React,
  events: {
    onSlChange: "sl-change",
    onSlHover: "sl-hover",
  },
  displayName: "SlRating",
});
var image_comparer_styles_default = i$8`
  :host {
    --divider-width: 2px;
    --handle-size: 2.5rem;

    display: inline-block;
    position: relative;
  }

  .image-comparer {
    max-width: 100%;
    max-height: 100%;
    overflow: hidden;
  }

  .image-comparer__before,
  .image-comparer__after {
    display: block;
    pointer-events: none;
  }

  .image-comparer__before::slotted(img),
  .image-comparer__after::slotted(img),
  .image-comparer__before::slotted(svg),
  .image-comparer__after::slotted(svg) {
    display: block;
    max-width: 100% !important;
    height: auto;
  }

  .image-comparer__after {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
  }

  .image-comparer__divider {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    width: var(--divider-width);
    height: 100%;
    background-color: var(--sl-color-neutral-0);
    translate: calc(var(--divider-width) / -2);
    cursor: ew-resize;
  }

  .image-comparer__handle {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: calc(50% - (var(--handle-size) / 2));
    width: var(--handle-size);
    height: var(--handle-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: var(--sl-border-radius-circle);
    font-size: calc(var(--handle-size) * 0.5);
    color: var(--sl-color-neutral-700);
    cursor: inherit;
    z-index: 10;
  }

  .image-comparer__handle:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }
`;
var SlImageComparer = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.position = 50;
  }
  handleDrag(event) {
    const { width } = this.base.getBoundingClientRect();
    const isRtl = this.localize.dir() === "rtl";
    event.preventDefault();
    drag(this.base, {
      onMove: (x2) => {
        this.position = parseFloat(
          clamp((x2 / width) * 100, 0, 100).toFixed(2),
        );
        if (isRtl) this.position = 100 - this.position;
      },
      initialEvent: event,
    });
  }
  handleKeyDown(event) {
    const isLtr = this.localize.dir() === "ltr";
    const isRtl = this.localize.dir() === "rtl";
    if (["ArrowLeft", "ArrowRight", "Home", "End"].includes(event.key)) {
      const incr = event.shiftKey ? 10 : 1;
      let newPosition = this.position;
      event.preventDefault();
      if (
        (isLtr && event.key === "ArrowLeft") ||
        (isRtl && event.key === "ArrowRight")
      ) {
        newPosition -= incr;
      }
      if (
        (isLtr && event.key === "ArrowRight") ||
        (isRtl && event.key === "ArrowLeft")
      ) {
        newPosition += incr;
      }
      if (event.key === "Home") {
        newPosition = 0;
      }
      if (event.key === "End") {
        newPosition = 100;
      }
      newPosition = clamp(newPosition, 0, 100);
      this.position = newPosition;
    }
  }
  handlePositionChange() {
    this.emit("sl-change");
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    return x$2`
      <div
        part="base"
        id="image-comparer"
        class=${e$4({
          "image-comparer": true,
          "image-comparer--rtl": isRtl,
        })}
        @keydown=${this.handleKeyDown}
      >
        <div class="image-comparer__image">
          <div part="before" class="image-comparer__before">
            <slot name="before"></slot>
          </div>

          <div
            part="after"
            class="image-comparer__after"
            style=${o$4({
              clipPath: isRtl
                ? `inset(0 0 0 ${100 - this.position}%)`
                : `inset(0 ${100 - this.position}% 0 0)`,
            })}
          >
            <slot name="after"></slot>
          </div>
        </div>

        <div
          part="divider"
          class="image-comparer__divider"
          style=${o$4({
            left: isRtl ? `${100 - this.position}%` : `${this.position}%`,
          })}
          @mousedown=${this.handleDrag}
          @touchstart=${this.handleDrag}
        >
          <div
            part="handle"
            class="image-comparer__handle"
            role="scrollbar"
            aria-valuenow=${this.position}
            aria-valuemin="0"
            aria-valuemax="100"
            aria-controls="image-comparer"
            tabindex="0"
          >
            <slot name="handle">
              <sl-icon library="system" name="grip-vertical"></sl-icon>
            </slot>
          </div>
        </div>
      </div>
    `;
  }
};
SlImageComparer.styles = [
  component_styles_default,
  image_comparer_styles_default,
];
SlImageComparer.scopedElement = { "sl-icon": SlIcon };
__decorateClass([e$8(".image-comparer")], SlImageComparer.prototype, "base", 2);
__decorateClass(
  [e$8(".image-comparer__handle")],
  SlImageComparer.prototype,
  "handle",
  2,
);
__decorateClass(
  [n$6({ type: Number, reflect: true })],
  SlImageComparer.prototype,
  "position",
  2,
);
__decorateClass(
  [watch("position", { waitUntilFirstUpdate: true })],
  SlImageComparer.prototype,
  "handlePositionChange",
  1,
);
var tagName$w = "sl-image-comparer";
SlImageComparer.define("sl-image-comparer");
o$8({
  tagName: tagName$w,
  elementClass: SlImageComparer,
  react: React,
  events: {
    onSlChange: "sl-change",
  },
  displayName: "SlImageComparer",
});
var input_styles_default = i$8`
  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: inherit;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`;
var SlInput = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"],
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.title = "";
    this.__numberInput = Object.assign(document.createElement("input"), {
      type: "number",
    });
    this.__dateInput = Object.assign(document.createElement("input"), {
      type: "date",
    });
    this.type = "text";
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.helpText = "";
    this.clearable = false;
    this.disabled = false;
    this.placeholder = "";
    this.readonly = false;
    this.passwordToggle = false;
    this.passwordVisible = false;
    this.noSpinButtons = false;
    this.form = "";
    this.required = false;
    this.spellcheck = true;
  }
  //
  // NOTE: We use an in-memory input for these getters/setters instead of the one in the template because the properties
  // can be set before the component is rendered.
  //
  /**
   * Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. This will use the native `<input type="{{type}}">` implementation and may result in an error.
   */
  get valueAsDate() {
    var _a2;
    this.__dateInput.type = this.type;
    this.__dateInput.value = this.value;
    return (
      ((_a2 = this.input) == null ? void 0 : _a2.valueAsDate) ||
      this.__dateInput.valueAsDate
    );
  }
  set valueAsDate(newValue) {
    this.__dateInput.type = this.type;
    this.__dateInput.valueAsDate = newValue;
    this.value = this.__dateInput.value;
  }
  /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
  get valueAsNumber() {
    var _a2;
    this.__numberInput.value = this.value;
    return (
      ((_a2 = this.input) == null ? void 0 : _a2.valueAsNumber) ||
      this.__numberInput.valueAsNumber
    );
  }
  set valueAsNumber(newValue) {
    this.__numberInput.valueAsNumber = newValue;
    this.value = this.__numberInput.value;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    this.emit("sl-change");
  }
  handleClearClick(event) {
    event.preventDefault();
    if (this.value !== "") {
      this.value = "";
      this.emit("sl-clear");
      this.emit("sl-input");
      this.emit("sl-change");
    }
    this.input.focus();
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    this.formControlController.updateValidity();
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleKeyDown(event) {
    const hasModifier =
      event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
    if (event.key === "Enter" && !hasModifier) {
      setTimeout(() => {
        if (!event.defaultPrevented && !event.isComposing) {
          this.formControlController.submit();
        }
      });
    }
  }
  handlePasswordToggle() {
    this.passwordVisible = !this.passwordVisible;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStepChange() {
    this.input.step = String(this.step);
    this.formControlController.updateValidity();
  }
  async handleValueChange() {
    await this.updateComplete;
    this.formControlController.updateValidity();
  }
  /** Sets focus on the input. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the input. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the input. */
  select() {
    this.input.select();
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(
      selectionStart,
      selectionEnd,
      selectionDirection,
    );
  }
  /** Replaces a range of text with a new string. */
  setRangeText(replacement, start, end, selectMode = "preserve") {
    const selectionStart = start != null ? start : this.input.selectionStart;
    const selectionEnd = end != null ? end : this.input.selectionEnd;
    this.input.setRangeText(
      replacement,
      selectionStart,
      selectionEnd,
      selectMode,
    );
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
  showPicker() {
    if ("showPicker" in HTMLInputElement.prototype) {
      this.input.showPicker();
    }
  }
  /** Increments the value of a numeric input type by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Decrements the value of a numeric input type by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && !this.readonly;
    const isClearIconVisible =
      hasClearIcon && (typeof this.value === "number" || this.value.length > 0);
    return x$2`
      <div
        part="form-control"
        class=${e$4({
          "form-control": true,
          "form-control--small": this.size === "small",
          "form-control--medium": this.size === "medium",
          "form-control--large": this.size === "large",
          "form-control--has-label": hasLabel,
          "form-control--has-help-text": hasHelpText,
        })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e$4({
              input: true,
              // Sizes
              "input--small": this.size === "small",
              "input--medium": this.size === "medium",
              "input--large": this.size === "large",
              // States
              "input--pill": this.pill,
              "input--standard": !this.filled,
              "input--filled": this.filled,
              "input--disabled": this.disabled,
              "input--focused": this.hasFocus,
              "input--empty": !this.value,
              "input--no-spin-buttons": this.noSpinButtons,
            })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.passwordVisible ? "text" : this.type}
              title=${this.title}
              name=${o$7(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${o$7(this.placeholder)}
              minlength=${o$7(this.minlength)}
              maxlength=${o$7(this.maxlength)}
              min=${o$7(this.min)}
              max=${o$7(this.max)}
              step=${o$7(this.step)}
              .value=${l$1(this.value)}
              autocapitalize=${o$7(this.autocapitalize)}
              autocomplete=${o$7(this.autocomplete)}
              autocorrect=${o$7(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${o$7(this.pattern)}
              enterkeyhint=${o$7(this.enterkeyhint)}
              inputmode=${o$7(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${
              isClearIconVisible
                ? x$2`
                  <button
                    part="clear-button"
                    class="input__clear"
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                `
                : ""
            }
            ${
              this.passwordToggle && !this.disabled
                ? x$2`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(this.passwordVisible ? "hidePassword" : "showPassword")}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${
                      this.passwordVisible
                        ? x$2`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        `
                        : x$2`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `
                    }
                  </button>
                `
                : ""
            }

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlInput.styles = [
  component_styles_default,
  form_control_styles_default,
  input_styles_default,
];
SlInput.dependencies = { "sl-icon": SlIcon };
__decorateClass([e$8(".input__control")], SlInput.prototype, "input", 2);
__decorateClass([r$4()], SlInput.prototype, "hasFocus", 2);
__decorateClass([n$6()], SlInput.prototype, "title", 2);
__decorateClass([n$6({ reflect: true })], SlInput.prototype, "type", 2);
__decorateClass([n$6()], SlInput.prototype, "name", 2);
__decorateClass([n$6()], SlInput.prototype, "value", 2);
__decorateClass([defaultValue()], SlInput.prototype, "defaultValue", 2);
__decorateClass([n$6({ reflect: true })], SlInput.prototype, "size", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlInput.prototype,
  "filled",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlInput.prototype,
  "pill",
  2,
);
__decorateClass([n$6()], SlInput.prototype, "label", 2);
__decorateClass(
  [n$6({ attribute: "help-text" })],
  SlInput.prototype,
  "helpText",
  2,
);
__decorateClass([n$6({ type: Boolean })], SlInput.prototype, "clearable", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlInput.prototype,
  "disabled",
  2,
);
__decorateClass([n$6()], SlInput.prototype, "placeholder", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlInput.prototype,
  "readonly",
  2,
);
__decorateClass(
  [n$6({ attribute: "password-toggle", type: Boolean })],
  SlInput.prototype,
  "passwordToggle",
  2,
);
__decorateClass(
  [n$6({ attribute: "password-visible", type: Boolean })],
  SlInput.prototype,
  "passwordVisible",
  2,
);
__decorateClass(
  [n$6({ attribute: "no-spin-buttons", type: Boolean })],
  SlInput.prototype,
  "noSpinButtons",
  2,
);
__decorateClass([n$6({ reflect: true })], SlInput.prototype, "form", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlInput.prototype,
  "required",
  2,
);
__decorateClass([n$6()], SlInput.prototype, "pattern", 2);
__decorateClass([n$6({ type: Number })], SlInput.prototype, "minlength", 2);
__decorateClass([n$6({ type: Number })], SlInput.prototype, "maxlength", 2);
__decorateClass([n$6()], SlInput.prototype, "min", 2);
__decorateClass([n$6()], SlInput.prototype, "max", 2);
__decorateClass([n$6()], SlInput.prototype, "step", 2);
__decorateClass([n$6()], SlInput.prototype, "autocapitalize", 2);
__decorateClass([n$6()], SlInput.prototype, "autocorrect", 2);
__decorateClass([n$6()], SlInput.prototype, "autocomplete", 2);
__decorateClass([n$6({ type: Boolean })], SlInput.prototype, "autofocus", 2);
__decorateClass([n$6()], SlInput.prototype, "enterkeyhint", 2);
__decorateClass(
  [
    n$6({
      type: Boolean,
      converter: {
        // Allow "true|false" attribute values but keep the property boolean
        fromAttribute: (value) => (!value || value === "false" ? false : true),
        toAttribute: (value) => (value ? "true" : "false"),
      },
    }),
  ],
  SlInput.prototype,
  "spellcheck",
  2,
);
__decorateClass([n$6()], SlInput.prototype, "inputmode", 2);
__decorateClass(
  [watch("disabled", { waitUntilFirstUpdate: true })],
  SlInput.prototype,
  "handleDisabledChange",
  1,
);
__decorateClass(
  [watch("step", { waitUntilFirstUpdate: true })],
  SlInput.prototype,
  "handleStepChange",
  1,
);
__decorateClass(
  [watch("value", { waitUntilFirstUpdate: true })],
  SlInput.prototype,
  "handleValueChange",
  1,
);
var tagName$v = "sl-input";
SlInput.define("sl-input");
var reactWrapper$e = o$8({
  tagName: tagName$v,
  elementClass: SlInput,
  react: React,
  events: {
    onSlBlur: "sl-blur",
    onSlChange: "sl-change",
    onSlClear: "sl-clear",
    onSlFocus: "sl-focus",
    onSlInput: "sl-input",
    onSlInvalid: "sl-invalid",
  },
  displayName: "SlInput",
});
var input_default = reactWrapper$e;
var tagName$u = "sl-icon";
SlIcon.define("sl-icon");
var reactWrapper$d = o$8({
  tagName: tagName$u,
  elementClass: SlIcon,
  react: React,
  events: {
    onSlLoad: "sl-load",
    onSlError: "sl-error",
  },
  displayName: "SlIcon",
});
var icon_default = reactWrapper$d;
var menu_styles_default = i$8`
  :host {
    display: block;
    position: relative;
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding: var(--sl-spacing-x-small) 0;
    overflow: auto;
    overscroll-behavior: none;
  }

  ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }
`;
var SlMenu = class extends ShoelaceElement {
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "menu");
  }
  handleClick(event) {
    const menuItemTypes = ["menuitem", "menuitemcheckbox"];
    const composedPath = event.composedPath();
    const target = composedPath.find((el) => {
      var _a2;
      return menuItemTypes.includes(
        ((_a2 = el == null ? void 0 : el.getAttribute) == null
          ? void 0
          : _a2.call(el, "role")) || "",
      );
    });
    if (!target) return;
    const closestMenu = composedPath.find((el) => {
      var _a2;
      return (
        ((_a2 = el == null ? void 0 : el.getAttribute) == null
          ? void 0
          : _a2.call(el, "role")) === "menu"
      );
    });
    const clickHasSubmenu = closestMenu !== this;
    if (clickHasSubmenu) return;
    const item = target;
    if (item.type === "checkbox") {
      item.checked = !item.checked;
    }
    this.emit("sl-select", { detail: { item } });
  }
  handleKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      const item = this.getCurrentItem();
      event.preventDefault();
      event.stopPropagation();
      item == null ? void 0 : item.click();
    } else if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
      const items = this.getAllItems();
      const activeItem = this.getCurrentItem();
      let index = activeItem ? items.indexOf(activeItem) : 0;
      if (items.length > 0) {
        event.preventDefault();
        event.stopPropagation();
        if (event.key === "ArrowDown") {
          index++;
        } else if (event.key === "ArrowUp") {
          index--;
        } else if (event.key === "Home") {
          index = 0;
        } else if (event.key === "End") {
          index = items.length - 1;
        }
        if (index < 0) {
          index = items.length - 1;
        }
        if (index > items.length - 1) {
          index = 0;
        }
        this.setCurrentItem(items[index]);
        items[index].focus();
      }
    }
  }
  handleMouseDown(event) {
    const target = event.target;
    if (this.isMenuItem(target)) {
      this.setCurrentItem(target);
    }
  }
  handleSlotChange() {
    const items = this.getAllItems();
    if (items.length > 0) {
      this.setCurrentItem(items[0]);
    }
  }
  isMenuItem(item) {
    var _a2;
    return (
      item.tagName.toLowerCase() === "sl-menu-item" ||
      ["menuitem", "menuitemcheckbox", "menuitemradio"].includes(
        (_a2 = item.getAttribute("role")) != null ? _a2 : "",
      )
    );
  }
  /** @internal Gets all slotted menu items, ignoring dividers, headers, and other elements. */
  getAllItems() {
    return [...this.defaultSlot.assignedElements({ flatten: true })].filter(
      (el) => {
        if (el.inert || !this.isMenuItem(el)) {
          return false;
        }
        return true;
      },
    );
  }
  /**
   * @internal Gets the current menu item, which is the menu item that has `tabindex="0"` within the roving tab index.
   * The menu item may or may not have focus, but for keyboard interaction purposes it's considered the "active" item.
   */
  getCurrentItem() {
    return this.getAllItems().find((i3) => i3.getAttribute("tabindex") === "0");
  }
  /**
   * @internal Sets the current menu item to the specified element. This sets `tabindex="0"` on the target element and
   * `tabindex="-1"` to all other items. This method must be called prior to setting focus on a menu item.
   */
  setCurrentItem(item) {
    const items = this.getAllItems();
    items.forEach((i3) => {
      i3.setAttribute("tabindex", i3 === item ? "0" : "-1");
    });
  }
  render() {
    return x$2`
      <slot
        @slotchange=${this.handleSlotChange}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      ></slot>
    `;
  }
};
SlMenu.styles = [component_styles_default, menu_styles_default];
__decorateClass([e$8("slot")], SlMenu.prototype, "defaultSlot", 2);
var tagName$t = "sl-menu";
SlMenu.define("sl-menu");
var reactWrapper$c = o$8({
  tagName: tagName$t,
  elementClass: SlMenu,
  react: React,
  events: {
    onSlSelect: "sl-select",
  },
  displayName: "SlMenu",
});
var menu_default = reactWrapper$c;
var menu_item_styles_default = i$8`
  :host {
    --submenu-offset: -2px;

    display: block;
  }

  :host([inert]) {
    display: none;
  }

  .menu-item {
    position: relative;
    display: flex;
    align-items: stretch;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-2x-small);
    transition: var(--sl-transition-fast) fill;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    cursor: pointer;
  }

  .menu-item.menu-item--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .menu-item.menu-item--loading {
    outline: none;
    cursor: wait;
  }

  .menu-item.menu-item--loading *:not(sl-spinner) {
    opacity: 0.5;
  }

  .menu-item--loading sl-spinner {
    --indicator-color: currentColor;
    --track-width: 1px;
    position: absolute;
    font-size: 0.75em;
    top: calc(50% - 0.5em);
    left: 0.65rem;
    opacity: 1;
  }

  .menu-item .menu-item__label {
    flex: 1 1 auto;
    display: inline-block;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  .menu-item .menu-item__prefix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .menu-item .menu-item__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /* Safe triangle */
  .menu-item--submenu-expanded::after {
    content: '';
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--safe-triangle-cursor-x, 0) var(--safe-triangle-cursor-y, 0),
      var(--safe-triangle-submenu-start-x, 0) var(--safe-triangle-submenu-start-y, 0),
      var(--safe-triangle-submenu-end-x, 0) var(--safe-triangle-submenu-end-y, 0)
    );
  }

  :host(:focus-visible) {
    outline: none;
  }

  :host(:hover:not([aria-disabled='true'], :focus-visible)) .menu-item,
  .menu-item--submenu-expanded {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  :host(:focus-visible) .menu-item {
    outline: none;
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .menu-item .menu-item__check,
  .menu-item .menu-item__chevron {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5em;
    visibility: hidden;
  }

  .menu-item--checked .menu-item__check,
  .menu-item--has-submenu .menu-item__chevron {
    visibility: visible;
  }

  /* Add elevation and z-index to submenus */
  sl-popup::part(popup) {
    box-shadow: var(--sl-shadow-large);
    z-index: var(--sl-z-index-dropdown);
    margin-left: var(--submenu-offset);
  }

  .menu-item--rtl sl-popup::part(popup) {
    margin-left: calc(-1 * var(--submenu-offset));
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .menu-item,
    :host(:focus-visible) .menu-item {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }

  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s = (i3, t2) => {
    var _a2;
    const e3 = i3._$AN;
    if (void 0 === e3) return false;
    for (const i4 of e3)
      (_a2 = i4._$AO) == null ? void 0 : _a2.call(i4, t2, false), s(i4, t2);
    return true;
  },
  o$3 = (i3) => {
    let t2, e3;
    do {
      if (void 0 === (t2 = i3._$AM)) break;
      (e3 = t2._$AN), e3.delete(i3), (i3 = t2);
    } while (0 === (e3 == null ? void 0 : e3.size));
  },
  r2 = (i3) => {
    for (let t2; (t2 = i3._$AM); i3 = t2) {
      let e3 = t2._$AN;
      if (void 0 === e3) t2._$AN = e3 = /* @__PURE__ */ new Set();
      else if (e3.has(i3)) break;
      e3.add(i3), c(t2);
    }
  };
function h$1(i3) {
  void 0 !== this._$AN
    ? (o$3(this), (this._$AM = i3), r2(this))
    : (this._$AM = i3);
}
function n$1(i3, t2 = false, e3 = 0) {
  const r3 = this._$AH,
    h2 = this._$AN;
  if (void 0 !== h2 && 0 !== h2.size)
    if (t2)
      if (Array.isArray(r3))
        for (let i4 = e3; i4 < r3.length; i4++) s(r3[i4], false), o$3(r3[i4]);
      else null != r3 && (s(r3, false), o$3(r3));
    else s(this, i3);
}
const c = (i3) => {
  i3.type == t.CHILD &&
    (i3._$AP ?? (i3._$AP = n$1), i3._$AQ ?? (i3._$AQ = h$1));
};
class f extends i$3 {
  constructor() {
    super(...arguments), (this._$AN = void 0);
  }
  _$AT(i3, t2, e3) {
    super._$AT(i3, t2, e3), r2(this), (this.isConnected = i3._$AU);
  }
  _$AO(i3, t2 = true) {
    var _a2, _b2;
    i3 !== this.isConnected &&
      ((this.isConnected = i3),
      i3
        ? (_a2 = this.reconnected) == null
          ? void 0
          : _a2.call(this)
        : (_b2 = this.disconnected) == null
          ? void 0
          : _b2.call(this)),
      t2 && (s(this, i3), o$3(this));
  }
  setValue(t2) {
    if (f$1(this._$Ct)) this._$Ct._$AI(t2, this);
    else {
      const i3 = [...this._$Ct._$AH];
      (i3[this._$Ci] = t2), this._$Ct._$AI(i3, this, 0);
    }
  }
  disconnected() {}
  reconnected() {}
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e2 = () => new h();
class h {}
const o$2 = /* @__PURE__ */ new WeakMap(),
  n2 = e$5(
    class extends f {
      render(i3) {
        return E$1;
      }
      update(i3, [s2]) {
        var _a2;
        const e3 = s2 !== this.Y;
        return (
          e3 && void 0 !== this.Y && this.rt(void 0),
          (e3 || this.lt !== this.ct) &&
            ((this.Y = s2),
            (this.ht = (_a2 = i3.options) == null ? void 0 : _a2.host),
            this.rt((this.ct = i3.element))),
          E$1
        );
      }
      rt(t2) {
        if ((this.isConnected || (t2 = void 0), "function" == typeof this.Y)) {
          const i3 = this.ht ?? globalThis;
          let s2 = o$2.get(i3);
          void 0 === s2 &&
            ((s2 = /* @__PURE__ */ new WeakMap()), o$2.set(i3, s2)),
            void 0 !== s2.get(this.Y) && this.Y.call(this.ht, void 0),
            s2.set(this.Y, t2),
            void 0 !== t2 && this.Y.call(this.ht, t2);
        } else this.Y.value = t2;
      }
      get lt() {
        var _a2, _b2;
        return "function" == typeof this.Y
          ? (_a2 = o$2.get(this.ht ?? globalThis)) == null
            ? void 0
            : _a2.get(this.Y)
          : (_b2 = this.Y) == null
            ? void 0
            : _b2.value;
      }
      disconnected() {
        this.lt === this.ct && this.rt(void 0);
      }
      reconnected() {
        this.rt(this.ct);
      }
    },
  );
var SubmenuController = class {
  constructor(host, hasSlotController) {
    this.popupRef = e2();
    this.enableSubmenuTimer = -1;
    this.isConnected = false;
    this.isPopupConnected = false;
    this.skidding = 0;
    this.submenuOpenDelay = 100;
    this.handleMouseMove = (event) => {
      this.host.style.setProperty(
        "--safe-triangle-cursor-x",
        `${event.clientX}px`,
      );
      this.host.style.setProperty(
        "--safe-triangle-cursor-y",
        `${event.clientY}px`,
      );
    };
    this.handleMouseOver = () => {
      if (this.hasSlotController.test("submenu")) {
        this.enableSubmenu();
      }
    };
    this.handleKeyDown = (event) => {
      switch (event.key) {
        case "Escape":
        case "Tab":
          this.disableSubmenu();
          break;
        case "ArrowLeft":
          if (event.target !== this.host) {
            event.preventDefault();
            event.stopPropagation();
            this.host.focus();
            this.disableSubmenu();
          }
          break;
        case "ArrowRight":
        case "Enter":
        case " ":
          this.handleSubmenuEntry(event);
          break;
      }
    };
    this.handleClick = (event) => {
      var _a2;
      if (event.target === this.host) {
        event.preventDefault();
        event.stopPropagation();
      } else if (
        event.target instanceof Element &&
        (event.target.tagName === "sl-menu-item" ||
          ((_a2 = event.target.role) == null
            ? void 0
            : _a2.startsWith("menuitem")))
      ) {
        this.disableSubmenu();
      }
    };
    this.handleFocusOut = (event) => {
      if (
        event.relatedTarget &&
        event.relatedTarget instanceof Element &&
        this.host.contains(event.relatedTarget)
      ) {
        return;
      }
      this.disableSubmenu();
    };
    this.handlePopupMouseover = (event) => {
      event.stopPropagation();
    };
    this.handlePopupReposition = () => {
      const submenuSlot = this.host.renderRoot.querySelector(
        "slot[name='submenu']",
      );
      const menu =
        submenuSlot == null
          ? void 0
          : submenuSlot
              .assignedElements({ flatten: true })
              .filter((el) => el.localName === "sl-menu")[0];
      const isRtl = getComputedStyle(this.host).direction === "rtl";
      if (!menu) {
        return;
      }
      const { left, top, width, height } = menu.getBoundingClientRect();
      this.host.style.setProperty(
        "--safe-triangle-submenu-start-x",
        `${isRtl ? left + width : left}px`,
      );
      this.host.style.setProperty(
        "--safe-triangle-submenu-start-y",
        `${top}px`,
      );
      this.host.style.setProperty(
        "--safe-triangle-submenu-end-x",
        `${isRtl ? left + width : left}px`,
      );
      this.host.style.setProperty(
        "--safe-triangle-submenu-end-y",
        `${top + height}px`,
      );
    };
    (this.host = host).addController(this);
    this.hasSlotController = hasSlotController;
  }
  hostConnected() {
    if (this.hasSlotController.test("submenu") && !this.host.disabled) {
      this.addListeners();
    }
  }
  hostDisconnected() {
    this.removeListeners();
  }
  hostUpdated() {
    if (this.hasSlotController.test("submenu") && !this.host.disabled) {
      this.addListeners();
      this.updateSkidding();
    } else {
      this.removeListeners();
    }
  }
  addListeners() {
    if (!this.isConnected) {
      this.host.addEventListener("mousemove", this.handleMouseMove);
      this.host.addEventListener("mouseover", this.handleMouseOver);
      this.host.addEventListener("keydown", this.handleKeyDown);
      this.host.addEventListener("click", this.handleClick);
      this.host.addEventListener("focusout", this.handleFocusOut);
      this.isConnected = true;
    }
    if (!this.isPopupConnected) {
      if (this.popupRef.value) {
        this.popupRef.value.addEventListener(
          "mouseover",
          this.handlePopupMouseover,
        );
        this.popupRef.value.addEventListener(
          "sl-reposition",
          this.handlePopupReposition,
        );
        this.isPopupConnected = true;
      }
    }
  }
  removeListeners() {
    if (this.isConnected) {
      this.host.removeEventListener("mousemove", this.handleMouseMove);
      this.host.removeEventListener("mouseover", this.handleMouseOver);
      this.host.removeEventListener("keydown", this.handleKeyDown);
      this.host.removeEventListener("click", this.handleClick);
      this.host.removeEventListener("focusout", this.handleFocusOut);
      this.isConnected = false;
    }
    if (this.isPopupConnected) {
      if (this.popupRef.value) {
        this.popupRef.value.removeEventListener(
          "mouseover",
          this.handlePopupMouseover,
        );
        this.popupRef.value.removeEventListener(
          "sl-reposition",
          this.handlePopupReposition,
        );
        this.isPopupConnected = false;
      }
    }
  }
  handleSubmenuEntry(event) {
    const submenuSlot = this.host.renderRoot.querySelector(
      "slot[name='submenu']",
    );
    if (!submenuSlot) {
      console.error(
        "Cannot activate a submenu if no corresponding menuitem can be found.",
        this,
      );
      return;
    }
    let menuItems = null;
    for (const elt of submenuSlot.assignedElements()) {
      menuItems = elt.querySelectorAll("sl-menu-item, [role^='menuitem']");
      if (menuItems.length !== 0) {
        break;
      }
    }
    if (!menuItems || menuItems.length === 0) {
      return;
    }
    menuItems[0].setAttribute("tabindex", "0");
    for (let i3 = 1; i3 !== menuItems.length; ++i3) {
      menuItems[i3].setAttribute("tabindex", "-1");
    }
    if (this.popupRef.value) {
      event.preventDefault();
      event.stopPropagation();
      if (this.popupRef.value.active) {
        if (menuItems[0] instanceof HTMLElement) {
          menuItems[0].focus();
        }
      } else {
        this.enableSubmenu(false);
        this.host.updateComplete.then(() => {
          if (menuItems[0] instanceof HTMLElement) {
            menuItems[0].focus();
          }
        });
        this.host.requestUpdate();
      }
    }
  }
  setSubmenuState(state) {
    if (this.popupRef.value) {
      if (this.popupRef.value.active !== state) {
        this.popupRef.value.active = state;
        this.host.requestUpdate();
      }
    }
  }
  // Shows the submenu. Supports disabling the opening delay, e.g. for keyboard events that want to set the focus to the
  // newly opened menu.
  enableSubmenu(delay = true) {
    if (delay) {
      window.clearTimeout(this.enableSubmenuTimer);
      this.enableSubmenuTimer = window.setTimeout(() => {
        this.setSubmenuState(true);
      }, this.submenuOpenDelay);
    } else {
      this.setSubmenuState(true);
    }
  }
  disableSubmenu() {
    window.clearTimeout(this.enableSubmenuTimer);
    this.setSubmenuState(false);
  }
  // Calculate the space the top of a menu takes-up, for aligning the popup menu-item with the activating element.
  updateSkidding() {
    var _a2;
    if (
      !((_a2 = this.host.parentElement) == null ? void 0 : _a2.computedStyleMap)
    ) {
      return;
    }
    const styleMap = this.host.parentElement.computedStyleMap();
    const attrs = ["padding-top", "border-top-width", "margin-top"];
    const skidding = attrs.reduce((accumulator, attr) => {
      var _a22;
      const styleValue =
        (_a22 = styleMap.get(attr)) != null ? _a22 : new CSSUnitValue(0, "px");
      const unitValue =
        styleValue instanceof CSSUnitValue
          ? styleValue
          : new CSSUnitValue(0, "px");
      const pxValue = unitValue.to("px");
      return accumulator - pxValue.value;
    }, 0);
    this.skidding = skidding;
  }
  isExpanded() {
    return this.popupRef.value ? this.popupRef.value.active : false;
  }
  renderSubmenu() {
    const isRtl = getComputedStyle(this.host).direction === "rtl";
    if (!this.isConnected) {
      return x$2` <slot name="submenu" hidden></slot> `;
    }
    return x$2`
      <sl-popup
        ${n2(this.popupRef)}
        placement=${isRtl ? "left-start" : "right-start"}
        anchor="anchor"
        flip
        flip-fallback-strategy="best-fit"
        skidding="${this.skidding}"
        strategy="fixed"
        auto-size="vertical"
        auto-size-padding="10"
      >
        <slot name="submenu"></slot>
      </sl-popup>
    `;
  }
};
var SlMenuItem = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.type = "normal";
    this.checked = false;
    this.value = "";
    this.loading = false;
    this.disabled = false;
    this.hasSlotController = new HasSlotController(this, "submenu");
    this.submenuController = new SubmenuController(
      this,
      this.hasSlotController,
    );
    this.handleHostClick = (event) => {
      if (this.disabled) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleMouseOver = (event) => {
      this.focus();
      event.stopPropagation();
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("click", this.handleHostClick);
    this.addEventListener("mouseover", this.handleMouseOver);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("click", this.handleHostClick);
    this.removeEventListener("mouseover", this.handleMouseOver);
  }
  handleDefaultSlotChange() {
    const textLabel = this.getTextLabel();
    if (typeof this.cachedTextLabel === "undefined") {
      this.cachedTextLabel = textLabel;
      return;
    }
    if (textLabel !== this.cachedTextLabel) {
      this.cachedTextLabel = textLabel;
      this.emit("slotchange", {
        bubbles: true,
        composed: false,
        cancelable: false,
      });
    }
  }
  handleCheckedChange() {
    if (this.checked && this.type !== "checkbox") {
      this.checked = false;
      console.error(
        'The checked attribute can only be used on menu items with type="checkbox"',
        this,
      );
      return;
    }
    if (this.type === "checkbox") {
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.removeAttribute("aria-checked");
    }
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleTypeChange() {
    if (this.type === "checkbox") {
      this.setAttribute("role", "menuitemcheckbox");
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.setAttribute("role", "menuitem");
      this.removeAttribute("aria-checked");
    }
  }
  /** Returns a text label based on the contents of the menu item's default slot. */
  getTextLabel() {
    return getTextContent(this.defaultSlot);
  }
  isSubmenu() {
    return this.hasSlotController.test("submenu");
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    const isSubmenuExpanded = this.submenuController.isExpanded();
    return x$2`
      <div
        id="anchor"
        part="base"
        class=${e$4({
          "menu-item": true,
          "menu-item--rtl": isRtl,
          "menu-item--checked": this.checked,
          "menu-item--disabled": this.disabled,
          "menu-item--loading": this.loading,
          "menu-item--has-submenu": this.isSubmenu(),
          "menu-item--submenu-expanded": isSubmenuExpanded,
        })}
        ?aria-haspopup="${this.isSubmenu()}"
        ?aria-expanded="${isSubmenuExpanded ? true : false}"
      >
        <span part="checked-icon" class="menu-item__check">
          <sl-icon name="check" library="system" aria-hidden="true"></sl-icon>
        </span>

        <slot name="prefix" part="prefix" class="menu-item__prefix"></slot>

        <slot part="label" class="menu-item__label" @slotchange=${this.handleDefaultSlotChange}></slot>

        <slot name="suffix" part="suffix" class="menu-item__suffix"></slot>

        <span part="submenu-icon" class="menu-item__chevron">
          <sl-icon name=${isRtl ? "chevron-left" : "chevron-right"} library="system" aria-hidden="true"></sl-icon>
        </span>

        ${this.submenuController.renderSubmenu()}
        ${this.loading ? x$2` <sl-spinner part="spinner" exportparts="base:spinner__base"></sl-spinner> ` : ""}
      </div>
    `;
  }
};
SlMenuItem.styles = [component_styles_default, menu_item_styles_default];
SlMenuItem.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-spinner": SlSpinner,
};
__decorateClass(
  [e$8("slot:not([name])")],
  SlMenuItem.prototype,
  "defaultSlot",
  2,
);
__decorateClass([e$8(".menu-item")], SlMenuItem.prototype, "menuItem", 2);
__decorateClass([n$6()], SlMenuItem.prototype, "type", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlMenuItem.prototype,
  "checked",
  2,
);
__decorateClass([n$6()], SlMenuItem.prototype, "value", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlMenuItem.prototype,
  "loading",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlMenuItem.prototype,
  "disabled",
  2,
);
__decorateClass(
  [watch("checked")],
  SlMenuItem.prototype,
  "handleCheckedChange",
  1,
);
__decorateClass(
  [watch("disabled")],
  SlMenuItem.prototype,
  "handleDisabledChange",
  1,
);
__decorateClass([watch("type")], SlMenuItem.prototype, "handleTypeChange", 1);
var tagName$s = "sl-menu-item";
SlMenuItem.define("sl-menu-item");
var reactWrapper$b = o$8({
  tagName: tagName$s,
  elementClass: SlMenuItem,
  react: React,
  events: {},
  displayName: "SlMenuItem",
});
var menu_item_default = reactWrapper$b;
var menu_label_styles_default = i$8`
  :host {
    display: block;
  }

  .menu-label {
    display: inline-block;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-500);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-large);
    user-select: none;
    -webkit-user-select: none;
  }
`;
var SlMenuLabel = class extends ShoelaceElement {
  render() {
    return x$2` <slot part="base" class="menu-label"></slot> `;
  }
};
SlMenuLabel.styles = [component_styles_default, menu_label_styles_default];
var tagName$r = "sl-menu-label";
SlMenuLabel.define("sl-menu-label");
var reactWrapper$a = o$8({
  tagName: tagName$r,
  elementClass: SlMenuLabel,
  react: React,
  events: {},
  displayName: "SlMenuLabel",
});
var menu_label_default = reactWrapper$a;
var option_styles_default = i$8`
  :host {
    display: block;
    user-select: none;
    -webkit-user-select: none;
  }

  :host(:focus) {
    outline: none;
  }

  .option {
    position: relative;
    display: flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-x-small) var(--sl-spacing-medium) var(--sl-spacing-x-small) var(--sl-spacing-x-small);
    transition: var(--sl-transition-fast) fill;
    cursor: pointer;
  }

  .option--hover:not(.option--current):not(.option--disabled) {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  .option--current,
  .option--current.option--disabled {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .option--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .option__label {
    flex: 1 1 auto;
    display: inline-block;
    line-height: var(--sl-line-height-dense);
  }

  .option .option__check {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    visibility: hidden;
    padding-inline-end: var(--sl-spacing-2x-small);
  }

  .option--selected .option__check {
    visibility: visible;
  }

  .option__prefix,
  .option__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .option__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .option__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .option {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;
var SlOption = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.isInitialized = false;
    this.current = false;
    this.selected = false;
    this.hasHover = false;
    this.value = "";
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "option");
    this.setAttribute("aria-selected", "false");
  }
  handleDefaultSlotChange() {
    if (this.isInitialized) {
      customElements.whenDefined("sl-select").then(() => {
        const controller = this.closest("sl-select");
        if (controller) {
          controller.handleDefaultSlotChange();
        }
      });
    } else {
      this.isInitialized = true;
    }
  }
  handleMouseEnter() {
    this.hasHover = true;
  }
  handleMouseLeave() {
    this.hasHover = false;
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleValueChange() {
    if (typeof this.value !== "string") {
      this.value = String(this.value);
    }
    if (this.value.includes(" ")) {
      console.error(
        `Option values cannot include a space. All spaces have been replaced with underscores.`,
        this,
      );
      this.value = this.value.replace(/ /g, "_");
    }
  }
  /** Returns a plain text label based on the option's content. */
  getTextLabel() {
    const nodes = this.childNodes;
    let label = "";
    [...nodes].forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (!node.hasAttribute("slot")) {
          label += node.textContent;
        }
      }
      if (node.nodeType === Node.TEXT_NODE) {
        label += node.textContent;
      }
    });
    return label.trim();
  }
  render() {
    return x$2`
      <div
        part="base"
        class=${e$4({
          option: true,
          "option--current": this.current,
          "option--disabled": this.disabled,
          "option--selected": this.selected,
          "option--hover": this.hasHover,
        })}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
      >
        <sl-icon part="checked-icon" class="option__check" name="check" library="system" aria-hidden="true"></sl-icon>
        <slot part="prefix" name="prefix" class="option__prefix"></slot>
        <slot part="label" class="option__label" @slotchange=${this.handleDefaultSlotChange}></slot>
        <slot part="suffix" name="suffix" class="option__suffix"></slot>
      </div>
    `;
  }
};
SlOption.styles = [component_styles_default, option_styles_default];
SlOption.dependencies = { "sl-icon": SlIcon };
__decorateClass([e$8(".option__label")], SlOption.prototype, "defaultSlot", 2);
__decorateClass([r$4()], SlOption.prototype, "current", 2);
__decorateClass([r$4()], SlOption.prototype, "selected", 2);
__decorateClass([r$4()], SlOption.prototype, "hasHover", 2);
__decorateClass([n$6({ reflect: true })], SlOption.prototype, "value", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlOption.prototype,
  "disabled",
  2,
);
__decorateClass(
  [watch("disabled")],
  SlOption.prototype,
  "handleDisabledChange",
  1,
);
__decorateClass(
  [watch("selected")],
  SlOption.prototype,
  "handleSelectedChange",
  1,
);
__decorateClass([watch("value")], SlOption.prototype, "handleValueChange", 1);
var tagName$q = "sl-option";
SlOption.define("sl-option");
o$8({
  tagName: tagName$q,
  elementClass: SlOption,
  react: React,
  events: {},
  displayName: "SlOption",
});
var progress_bar_styles_default = i$8`
  :host {
    --height: 1rem;
    --track-color: var(--sl-color-neutral-200);
    --indicator-color: var(--sl-color-primary-600);
    --label-color: var(--sl-color-neutral-0);

    display: block;
  }

  .progress-bar {
    position: relative;
    background-color: var(--track-color);
    height: var(--height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset var(--sl-shadow-small);
    overflow: hidden;
  }

  .progress-bar__indicator {
    height: 100%;
    font-family: var(--sl-font-sans);
    font-size: 12px;
    font-weight: var(--sl-font-weight-normal);
    background-color: var(--indicator-color);
    color: var(--label-color);
    text-align: center;
    line-height: var(--height);
    white-space: nowrap;
    overflow: hidden;
    transition:
      400ms width,
      400ms background-color;
    user-select: none;
    -webkit-user-select: none;
  }

  /* Indeterminate */
  .progress-bar--indeterminate .progress-bar__indicator {
    position: absolute;
    animation: indeterminate 2.5s infinite cubic-bezier(0.37, 0, 0.63, 1);
  }

  .progress-bar--indeterminate.progress-bar--rtl .progress-bar__indicator {
    animation-name: indeterminate-rtl;
  }

  @media (forced-colors: active) {
    .progress-bar {
      outline: solid 1px SelectedItem;
      background-color: var(--sl-color-neutral-0);
    }

    .progress-bar__indicator {
      outline: solid 1px SelectedItem;
      background-color: SelectedItem;
    }
  }

  @keyframes indeterminate {
    0% {
      left: -50%;
      width: 50%;
    }
    75%,
    100% {
      left: 100%;
      width: 50%;
    }
  }

  @keyframes indeterminate-rtl {
    0% {
      right: -50%;
      width: 50%;
    }
    75%,
    100% {
      right: 100%;
      width: 50%;
    }
  }
`;
var SlProgressBar = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.value = 0;
    this.indeterminate = false;
    this.label = "";
  }
  render() {
    return x$2`
      <div
        part="base"
        class=${e$4({
          "progress-bar": true,
          "progress-bar--indeterminate": this.indeterminate,
          "progress-bar--rtl": this.localize.dir() === "rtl",
        })}
        role="progressbar"
        title=${o$7(this.title)}
        aria-label=${this.label.length > 0 ? this.label : this.localize.term("progress")}
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow=${this.indeterminate ? 0 : this.value}
      >
        <div part="indicator" class="progress-bar__indicator" style=${o$4({ width: `${this.value}%` })}>
          ${!this.indeterminate ? x$2` <slot part="label" class="progress-bar__label"></slot> ` : ""}
        </div>
      </div>
    `;
  }
};
SlProgressBar.styles = [component_styles_default, progress_bar_styles_default];
__decorateClass(
  [n$6({ type: Number, reflect: true })],
  SlProgressBar.prototype,
  "value",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlProgressBar.prototype,
  "indeterminate",
  2,
);
__decorateClass([n$6()], SlProgressBar.prototype, "label", 2);
var tagName$p = "sl-progress-bar";
SlProgressBar.define("sl-progress-bar");
o$8({
  tagName: tagName$p,
  elementClass: SlProgressBar,
  react: React,
  events: {},
  displayName: "SlProgressBar",
});
var divider_styles_default = i$8`
  :host {
    --color: var(--sl-panel-border-color);
    --width: var(--sl-panel-border-width);
    --spacing: var(--sl-spacing-medium);
  }

  :host(:not([vertical])) {
    display: block;
    border-top: solid var(--width) var(--color);
    margin: var(--spacing) 0;
  }

  :host([vertical]) {
    display: inline-block;
    height: 100%;
    border-left: solid var(--width) var(--color);
    margin: 0 var(--spacing);
  }
`;
var SlDivider = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.vertical = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "separator");
  }
  handleVerticalChange() {
    this.setAttribute(
      "aria-orientation",
      this.vertical ? "vertical" : "horizontal",
    );
  }
};
SlDivider.styles = [component_styles_default, divider_styles_default];
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlDivider.prototype,
  "vertical",
  2,
);
__decorateClass(
  [watch("vertical")],
  SlDivider.prototype,
  "handleVerticalChange",
  1,
);
var tagName$o = "sl-divider";
SlDivider.define("sl-divider");
o$8({
  tagName: tagName$o,
  elementClass: SlDivider,
  react: React,
  events: {},
  displayName: "SlDivider",
});
var drawer_styles_default = i$8`
  :host {
    --size: 25rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .drawer {
    top: 0;
    inset-inline-start: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
  }

  .drawer--contained {
    position: absolute;
    z-index: initial;
  }

  .drawer--fixed {
    position: fixed;
    z-index: var(--sl-z-index-drawer);
  }

  .drawer__panel {
    position: absolute;
    display: flex;
    flex-direction: column;
    z-index: 2;
    max-width: 100%;
    max-height: 100%;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-large);
    overflow: auto;
    pointer-events: all;
  }

  .drawer__panel:focus {
    outline: none;
  }

  .drawer--top .drawer__panel {
    top: 0;
    inset-inline-end: auto;
    bottom: auto;
    inset-inline-start: 0;
    width: 100%;
    height: var(--size);
  }

  .drawer--end .drawer__panel {
    top: 0;
    inset-inline-end: 0;
    bottom: auto;
    inset-inline-start: auto;
    width: var(--size);
    height: 100%;
  }

  .drawer--bottom .drawer__panel {
    top: auto;
    inset-inline-end: auto;
    bottom: 0;
    inset-inline-start: 0;
    width: 100%;
    height: var(--size);
  }

  .drawer--start .drawer__panel {
    top: 0;
    inset-inline-end: auto;
    bottom: auto;
    inset-inline-start: 0;
    width: var(--size);
    height: 100%;
  }

  .drawer__header {
    display: flex;
  }

  .drawer__title {
    flex: 1 1 auto;
    font: inherit;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
    margin: 0;
  }

  .drawer__header-actions {
    flex-shrink: 0;
    display: flex;
    flex-wrap: wrap;
    justify-content: end;
    gap: var(--sl-spacing-2x-small);
    padding: 0 var(--header-spacing);
  }

  .drawer__header-actions sl-icon-button,
  .drawer__header-actions ::slotted(sl-icon-button) {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
  }

  .drawer__body {
    flex: 1 1 auto;
    display: block;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .drawer__footer {
    text-align: right;
    padding: var(--footer-spacing);
  }

  .drawer__footer ::slotted(sl-button:not(:last-of-type)) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .drawer:not(.drawer--has-footer) .drawer__footer {
    display: none;
  }

  .drawer__overlay {
    display: block;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
    pointer-events: all;
  }

  .drawer--contained .drawer__overlay {
    display: none;
  }

  @media (forced-colors: active) {
    .drawer__panel {
      border: solid 1px var(--sl-color-neutral-0);
    }
  }
`;
var computedStyleMap = /* @__PURE__ */ new WeakMap();
function getCachedComputedStyle(el) {
  let computedStyle = computedStyleMap.get(el);
  if (!computedStyle) {
    computedStyle = window.getComputedStyle(el, null);
    computedStyleMap.set(el, computedStyle);
  }
  return computedStyle;
}
function isVisible(el) {
  if (typeof el.checkVisibility === "function") {
    return el.checkVisibility({
      checkOpacity: false,
      checkVisibilityCSS: true,
    });
  }
  const computedStyle = getCachedComputedStyle(el);
  return (
    computedStyle.visibility !== "hidden" && computedStyle.display !== "none"
  );
}
function isOverflowingAndTabbable(el) {
  const computedStyle = getCachedComputedStyle(el);
  const { overflowY, overflowX } = computedStyle;
  if (overflowY === "scroll" || overflowX === "scroll") {
    return true;
  }
  if (overflowY !== "auto" || overflowX !== "auto") {
    return false;
  }
  const isOverflowingY = el.scrollHeight > el.clientHeight;
  if (isOverflowingY && overflowY === "auto") {
    return true;
  }
  const isOverflowingX = el.scrollWidth > el.clientWidth;
  if (isOverflowingX && overflowX === "auto") {
    return true;
  }
  return false;
}
function isTabbable(el) {
  const tag = el.tagName.toLowerCase();
  const tabindex = Number(el.getAttribute("tabindex"));
  const hasTabindex = el.hasAttribute("tabindex");
  if (hasTabindex && (isNaN(tabindex) || tabindex <= -1)) {
    return false;
  }
  if (el.hasAttribute("disabled")) {
    return false;
  }
  if (el.closest("[inert]")) {
    return false;
  }
  if (tag === "input" && el.getAttribute("type") === "radio") {
    const rootNode = el.getRootNode();
    const findRadios = `input[type='radio'][name="${el.getAttribute("name")}"]`;
    const firstChecked = rootNode.querySelector(`${findRadios}:checked`);
    if (firstChecked) {
      return firstChecked === el;
    }
    const firstRadio = rootNode.querySelector(findRadios);
    return firstRadio === el;
  }
  if (!isVisible(el)) {
    return false;
  }
  if ((tag === "audio" || tag === "video") && el.hasAttribute("controls")) {
    return true;
  }
  if (el.hasAttribute("tabindex")) {
    return true;
  }
  if (
    el.hasAttribute("contenteditable") &&
    el.getAttribute("contenteditable") !== "false"
  ) {
    return true;
  }
  const isNativelyTabbable = [
    "button",
    "input",
    "select",
    "textarea",
    "a",
    "audio",
    "video",
    "summary",
    "iframe",
  ].includes(tag);
  if (isNativelyTabbable) {
    return true;
  }
  return isOverflowingAndTabbable(el);
}
function getTabbableBoundary(root) {
  var _a2, _b2;
  const tabbableElements = getTabbableElements(root);
  const start = (_a2 = tabbableElements[0]) != null ? _a2 : null;
  const end =
    (_b2 = tabbableElements[tabbableElements.length - 1]) != null ? _b2 : null;
  return { start, end };
}
function getSlottedChildrenOutsideRootElement(slotElement, root) {
  var _a2;
  return (
    ((_a2 = slotElement.getRootNode({ composed: true })) == null
      ? void 0
      : _a2.host) !== root
  );
}
function getTabbableElements(root) {
  const walkedEls = /* @__PURE__ */ new WeakMap();
  const tabbableElements = [];
  function walk(el) {
    if (el instanceof Element) {
      if (el.hasAttribute("inert") || el.closest("[inert]")) {
        return;
      }
      if (walkedEls.has(el)) {
        return;
      }
      walkedEls.set(el, true);
      if (!tabbableElements.includes(el) && isTabbable(el)) {
        tabbableElements.push(el);
      }
      if (
        el instanceof HTMLSlotElement &&
        getSlottedChildrenOutsideRootElement(el, root)
      ) {
        el.assignedElements({ flatten: true }).forEach((assignedEl) => {
          walk(assignedEl);
        });
      }
      if (el.shadowRoot !== null && el.shadowRoot.mode === "open") {
        walk(el.shadowRoot);
      }
    }
    for (const e3 of el.children) {
      walk(e3);
    }
  }
  walk(root);
  return tabbableElements.sort((a2, b3) => {
    const aTabindex = Number(a2.getAttribute("tabindex")) || 0;
    const bTabindex = Number(b3.getAttribute("tabindex")) || 0;
    return bTabindex - aTabindex;
  });
}
function* activeElements(activeElement = document.activeElement) {
  if (activeElement === null || activeElement === void 0) return;
  yield activeElement;
  if (
    "shadowRoot" in activeElement &&
    activeElement.shadowRoot &&
    activeElement.shadowRoot.mode !== "closed"
  ) {
    yield* __yieldStar(activeElements(activeElement.shadowRoot.activeElement));
  }
}
function getDeepestActiveElement() {
  return [...activeElements()].pop();
}
var activeModals = [];
var Modal = class {
  constructor(element) {
    this.tabDirection = "forward";
    this.handleFocusIn = () => {
      if (!this.isActive()) return;
      this.checkFocus();
    };
    this.handleKeyDown = (event) => {
      var _a2;
      if (event.key !== "Tab" || this.isExternalActivated) return;
      if (!this.isActive()) return;
      const currentActiveElement = getDeepestActiveElement();
      this.previousFocus = currentActiveElement;
      if (
        this.previousFocus &&
        this.possiblyHasTabbableChildren(this.previousFocus)
      ) {
        return;
      }
      if (event.shiftKey) {
        this.tabDirection = "backward";
      } else {
        this.tabDirection = "forward";
      }
      const tabbableElements = getTabbableElements(this.element);
      let currentFocusIndex = tabbableElements.findIndex(
        (el) => el === currentActiveElement,
      );
      this.previousFocus = this.currentFocus;
      const addition = this.tabDirection === "forward" ? 1 : -1;
      while (true) {
        if (currentFocusIndex + addition >= tabbableElements.length) {
          currentFocusIndex = 0;
        } else if (currentFocusIndex + addition < 0) {
          currentFocusIndex = tabbableElements.length - 1;
        } else {
          currentFocusIndex += addition;
        }
        this.previousFocus = this.currentFocus;
        const nextFocus =
          /** @type {HTMLElement} */
          tabbableElements[currentFocusIndex];
        if (this.tabDirection === "backward") {
          if (
            this.previousFocus &&
            this.possiblyHasTabbableChildren(this.previousFocus)
          ) {
            return;
          }
        }
        if (nextFocus && this.possiblyHasTabbableChildren(nextFocus)) {
          return;
        }
        event.preventDefault();
        this.currentFocus = nextFocus;
        (_a2 = this.currentFocus) == null
          ? void 0
          : _a2.focus({ preventScroll: false });
        const allActiveElements = [...activeElements()];
        if (
          allActiveElements.includes(this.currentFocus) ||
          !allActiveElements.includes(this.previousFocus)
        ) {
          break;
        }
      }
      setTimeout(() => this.checkFocus());
    };
    this.handleKeyUp = () => {
      this.tabDirection = "forward";
    };
    this.element = element;
    this.elementsWithTabbableControls = ["iframe"];
  }
  /** Activates focus trapping. */
  activate() {
    activeModals.push(this.element);
    document.addEventListener("focusin", this.handleFocusIn);
    document.addEventListener("keydown", this.handleKeyDown);
    document.addEventListener("keyup", this.handleKeyUp);
  }
  /** Deactivates focus trapping. */
  deactivate() {
    activeModals = activeModals.filter((modal) => modal !== this.element);
    this.currentFocus = null;
    document.removeEventListener("focusin", this.handleFocusIn);
    document.removeEventListener("keydown", this.handleKeyDown);
    document.removeEventListener("keyup", this.handleKeyUp);
  }
  /** Determines if this modal element is currently active or not. */
  isActive() {
    return activeModals[activeModals.length - 1] === this.element;
  }
  /** Activates external modal behavior and temporarily disables focus trapping. */
  activateExternal() {
    this.isExternalActivated = true;
  }
  /** Deactivates external modal behavior and re-enables focus trapping. */
  deactivateExternal() {
    this.isExternalActivated = false;
  }
  checkFocus() {
    if (this.isActive() && !this.isExternalActivated) {
      const tabbableElements = getTabbableElements(this.element);
      if (!this.element.matches(":focus-within")) {
        const start = tabbableElements[0];
        const end = tabbableElements[tabbableElements.length - 1];
        const target = this.tabDirection === "forward" ? start : end;
        if (typeof (target == null ? void 0 : target.focus) === "function") {
          this.currentFocus = target;
          target.focus({ preventScroll: false });
        }
      }
    }
  }
  possiblyHasTabbableChildren(element) {
    return (
      this.elementsWithTabbableControls.includes(
        element.tagName.toLowerCase(),
      ) || element.hasAttribute("controls")
    );
  }
};
function uppercaseFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var SlDrawer = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "footer");
    this.localize = new LocalizeController2(this);
    this.modal = new Modal(this);
    this.open = false;
    this.label = "";
    this.placement = "end";
    this.contained = false;
    this.noHeader = false;
    this.handleDocumentKeyDown = (event) => {
      if (this.contained) {
        return;
      }
      if (event.key === "Escape" && this.modal.isActive() && this.open) {
        event.stopImmediatePropagation();
        this.requestClose("keyboard");
      }
    };
  }
  firstUpdated() {
    this.drawer.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      if (!this.contained) {
        this.modal.activate();
        lockBodyScrolling(this);
      }
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unlockBodyScrolling(this);
    this.removeOpenListeners();
  }
  requestClose(source) {
    const slRequestClose = this.emit("sl-request-close", {
      cancelable: true,
      detail: { source },
    });
    if (slRequestClose.defaultPrevented) {
      const animation = getAnimation(this, "drawer.denyClose", {
        dir: this.localize.dir(),
      });
      animateTo(this.panel, animation.keyframes, animation.options);
      return;
    }
    this.hide();
  }
  addOpenListeners() {
    var _a2;
    if ("CloseWatcher" in window) {
      (_a2 = this.closeWatcher) == null ? void 0 : _a2.destroy();
      if (!this.contained) {
        this.closeWatcher = new CloseWatcher();
        this.closeWatcher.onclose = () => this.requestClose("keyboard");
      }
    } else {
      document.addEventListener("keydown", this.handleDocumentKeyDown);
    }
  }
  removeOpenListeners() {
    var _a2;
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    (_a2 = this.closeWatcher) == null ? void 0 : _a2.destroy();
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      this.originalTrigger = document.activeElement;
      if (!this.contained) {
        this.modal.activate();
        lockBodyScrolling(this);
      }
      const autoFocusTarget = this.querySelector("[autofocus]");
      if (autoFocusTarget) {
        autoFocusTarget.removeAttribute("autofocus");
      }
      await Promise.all([
        stopAnimations(this.drawer),
        stopAnimations(this.overlay),
      ]);
      this.drawer.hidden = false;
      requestAnimationFrame(() => {
        const slInitialFocus = this.emit("sl-initial-focus", {
          cancelable: true,
        });
        if (!slInitialFocus.defaultPrevented) {
          if (autoFocusTarget) {
            autoFocusTarget.focus({ preventScroll: true });
          } else {
            this.panel.focus({ preventScroll: true });
          }
        }
        if (autoFocusTarget) {
          autoFocusTarget.setAttribute("autofocus", "");
        }
      });
      const panelAnimation = getAnimation(
        this,
        `drawer.show${uppercaseFirstLetter(this.placement)}`,
        {
          dir: this.localize.dir(),
        },
      );
      const overlayAnimation = getAnimation(this, "drawer.overlay.show", {
        dir: this.localize.dir(),
      });
      await Promise.all([
        animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options),
        animateTo(
          this.overlay,
          overlayAnimation.keyframes,
          overlayAnimation.options,
        ),
      ]);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      if (!this.contained) {
        this.modal.deactivate();
        unlockBodyScrolling(this);
      }
      await Promise.all([
        stopAnimations(this.drawer),
        stopAnimations(this.overlay),
      ]);
      const panelAnimation = getAnimation(
        this,
        `drawer.hide${uppercaseFirstLetter(this.placement)}`,
        {
          dir: this.localize.dir(),
        },
      );
      const overlayAnimation = getAnimation(this, "drawer.overlay.hide", {
        dir: this.localize.dir(),
      });
      await Promise.all([
        animateTo(
          this.overlay,
          overlayAnimation.keyframes,
          overlayAnimation.options,
        ).then(() => {
          this.overlay.hidden = true;
        }),
        animateTo(
          this.panel,
          panelAnimation.keyframes,
          panelAnimation.options,
        ).then(() => {
          this.panel.hidden = true;
        }),
      ]);
      this.drawer.hidden = true;
      this.overlay.hidden = false;
      this.panel.hidden = false;
      const trigger = this.originalTrigger;
      if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
        setTimeout(() => trigger.focus());
      }
      this.emit("sl-after-hide");
    }
  }
  handleNoModalChange() {
    if (this.open && !this.contained) {
      this.modal.activate();
      lockBodyScrolling(this);
    }
    if (this.open && this.contained) {
      this.modal.deactivate();
      unlockBodyScrolling(this);
    }
  }
  /** Shows the drawer. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the drawer */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  render() {
    return x$2`
      <div
        part="base"
        class=${e$4({
          drawer: true,
          "drawer--open": this.open,
          "drawer--top": this.placement === "top",
          "drawer--end": this.placement === "end",
          "drawer--bottom": this.placement === "bottom",
          "drawer--start": this.placement === "start",
          "drawer--contained": this.contained,
          "drawer--fixed": !this.contained,
          "drawer--rtl": this.localize.dir() === "rtl",
          "drawer--has-footer": this.hasSlotController.test("footer"),
        })}
      >
        <div part="overlay" class="drawer__overlay" @click=${() => this.requestClose("overlay")} tabindex="-1"></div>

        <div
          part="panel"
          class="drawer__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${o$7(this.noHeader ? this.label : void 0)}
          aria-labelledby=${o$7(!this.noHeader ? "title" : void 0)}
          tabindex="0"
        >
          ${
            !this.noHeader
              ? x$2`
                <header part="header" class="drawer__header">
                  <h2 part="title" class="drawer__title" id="title">
                    <!-- If there's no label, use an invisible character to prevent the header from collapsing -->
                    <slot name="label"> ${this.label.length > 0 ? this.label : String.fromCharCode(65279)} </slot>
                  </h2>
                  <div part="header-actions" class="drawer__header-actions">
                    <slot name="header-actions"></slot>
                    <sl-icon-button
                      part="close-button"
                      exportparts="base:close-button__base"
                      class="drawer__close"
                      name="x-lg"
                      label=${this.localize.term("close")}
                      library="system"
                      @click=${() => this.requestClose("close-button")}
                    ></sl-icon-button>
                  </div>
                </header>
              `
              : ""
          }

          <slot part="body" class="drawer__body"></slot>

          <footer part="footer" class="drawer__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
  }
};
SlDrawer.styles = [component_styles_default, drawer_styles_default];
SlDrawer.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([e$8(".drawer")], SlDrawer.prototype, "drawer", 2);
__decorateClass([e$8(".drawer__panel")], SlDrawer.prototype, "panel", 2);
__decorateClass([e$8(".drawer__overlay")], SlDrawer.prototype, "overlay", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlDrawer.prototype,
  "open",
  2,
);
__decorateClass([n$6({ reflect: true })], SlDrawer.prototype, "label", 2);
__decorateClass([n$6({ reflect: true })], SlDrawer.prototype, "placement", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlDrawer.prototype,
  "contained",
  2,
);
__decorateClass(
  [n$6({ attribute: "no-header", type: Boolean, reflect: true })],
  SlDrawer.prototype,
  "noHeader",
  2,
);
__decorateClass(
  [watch("open", { waitUntilFirstUpdate: true })],
  SlDrawer.prototype,
  "handleOpenChange",
  1,
);
__decorateClass(
  [watch("contained", { waitUntilFirstUpdate: true })],
  SlDrawer.prototype,
  "handleNoModalChange",
  1,
);
setDefaultAnimation("drawer.showTop", {
  keyframes: [
    { opacity: 0, translate: "0 -100%" },
    { opacity: 1, translate: "0 0" },
  ],
  options: { duration: 250, easing: "ease" },
});
setDefaultAnimation("drawer.hideTop", {
  keyframes: [
    { opacity: 1, translate: "0 0" },
    { opacity: 0, translate: "0 -100%" },
  ],
  options: { duration: 250, easing: "ease" },
});
setDefaultAnimation("drawer.showEnd", {
  keyframes: [
    { opacity: 0, translate: "100%" },
    { opacity: 1, translate: "0" },
  ],
  rtlKeyframes: [
    { opacity: 0, translate: "-100%" },
    { opacity: 1, translate: "0" },
  ],
  options: { duration: 250, easing: "ease" },
});
setDefaultAnimation("drawer.hideEnd", {
  keyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "100%" },
  ],
  rtlKeyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "-100%" },
  ],
  options: { duration: 250, easing: "ease" },
});
setDefaultAnimation("drawer.showBottom", {
  keyframes: [
    { opacity: 0, translate: "0 100%" },
    { opacity: 1, translate: "0 0" },
  ],
  options: { duration: 250, easing: "ease" },
});
setDefaultAnimation("drawer.hideBottom", {
  keyframes: [
    { opacity: 1, translate: "0 0" },
    { opacity: 0, translate: "0 100%" },
  ],
  options: { duration: 250, easing: "ease" },
});
setDefaultAnimation("drawer.showStart", {
  keyframes: [
    { opacity: 0, translate: "-100%" },
    { opacity: 1, translate: "0" },
  ],
  rtlKeyframes: [
    { opacity: 0, translate: "100%" },
    { opacity: 1, translate: "0" },
  ],
  options: { duration: 250, easing: "ease" },
});
setDefaultAnimation("drawer.hideStart", {
  keyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "-100%" },
  ],
  rtlKeyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "100%" },
  ],
  options: { duration: 250, easing: "ease" },
});
setDefaultAnimation("drawer.denyClose", {
  keyframes: [{ scale: 1 }, { scale: 1.01 }, { scale: 1 }],
  options: { duration: 250 },
});
setDefaultAnimation("drawer.overlay.show", {
  keyframes: [{ opacity: 0 }, { opacity: 1 }],
  options: { duration: 250 },
});
setDefaultAnimation("drawer.overlay.hide", {
  keyframes: [{ opacity: 1 }, { opacity: 0 }],
  options: { duration: 250 },
});
var tagName$n = "sl-drawer";
SlDrawer.define("sl-drawer");
var reactWrapper$9 = o$8({
  tagName: tagName$n,
  elementClass: SlDrawer,
  react: React,
  events: {
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide",
    onSlInitialFocus: "sl-initial-focus",
    onSlRequestClose: "sl-request-close",
  },
  displayName: "SlDrawer",
});
var drawer_default = reactWrapper$9;
var dropdown_styles_default = i$8`
  :host {
    display: inline-block;
  }

  .dropdown::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .dropdown[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .dropdown[data-current-placement^='left']::part(popup) {
    transform-origin: right;
  }

  .dropdown[data-current-placement^='right']::part(popup) {
    transform-origin: left;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    border-radius: var(--sl-border-radius-medium);
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    display: block;
    pointer-events: all;
  }

  /* When users slot a menu, make sure it conforms to the popup's auto-size */
  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;
var SlDropdown = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.open = false;
    this.placement = "bottom-start";
    this.disabled = false;
    this.stayOpenOnSelect = false;
    this.distance = 0;
    this.skidding = 0;
    this.hoist = false;
    this.sync = void 0;
    this.handleKeyDown = (event) => {
      if (this.open && event.key === "Escape") {
        event.stopPropagation();
        this.hide();
        this.focusOnTrigger();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      var _a2;
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.stopPropagation();
        this.focusOnTrigger();
        this.hide();
        return;
      }
      if (event.key === "Tab") {
        if (
          this.open &&
          ((_a2 = document.activeElement) == null
            ? void 0
            : _a2.tagName.toLowerCase()) === "sl-menu-item"
        ) {
          event.preventDefault();
          this.hide();
          this.focusOnTrigger();
          return;
        }
        setTimeout(() => {
          var _a22, _b2, _c2;
          const activeElement =
            ((_a22 = this.containingElement) == null
              ? void 0
              : _a22.getRootNode()) instanceof ShadowRoot
              ? (_c2 =
                  (_b2 = document.activeElement) == null
                    ? void 0
                    : _b2.shadowRoot) == null
                ? void 0
                : _c2.activeElement
              : document.activeElement;
          if (
            !this.containingElement ||
            (activeElement == null
              ? void 0
              : activeElement.closest(
                  this.containingElement.tagName.toLowerCase(),
                )) !== this.containingElement
          ) {
            this.hide();
          }
        });
      }
    };
    this.handleDocumentMouseDown = (event) => {
      const path = event.composedPath();
      if (this.containingElement && !path.includes(this.containingElement)) {
        this.hide();
      }
    };
    this.handlePanelSelect = (event) => {
      const target = event.target;
      if (
        !this.stayOpenOnSelect &&
        target.tagName.toLowerCase() === "sl-menu"
      ) {
        this.hide();
        this.focusOnTrigger();
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.containingElement) {
      this.containingElement = this;
    }
  }
  firstUpdated() {
    this.panel.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      this.popup.active = true;
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeOpenListeners();
    this.hide();
  }
  focusOnTrigger() {
    const trigger = this.trigger.assignedElements({ flatten: true })[0];
    if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
      trigger.focus();
    }
  }
  getMenu() {
    return this.panel
      .assignedElements({ flatten: true })
      .find((el) => el.tagName.toLowerCase() === "sl-menu");
  }
  handleTriggerClick() {
    if (this.open) {
      this.hide();
    } else {
      this.show();
      this.focusOnTrigger();
    }
  }
  async handleTriggerKeyDown(event) {
    if ([" ", "Enter"].includes(event.key)) {
      event.preventDefault();
      this.handleTriggerClick();
      return;
    }
    const menu = this.getMenu();
    if (menu) {
      const menuItems = menu.getAllItems();
      const firstMenuItem = menuItems[0];
      const lastMenuItem = menuItems[menuItems.length - 1];
      if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
        event.preventDefault();
        if (!this.open) {
          this.show();
          await this.updateComplete;
        }
        if (menuItems.length > 0) {
          this.updateComplete.then(() => {
            if (event.key === "ArrowDown" || event.key === "Home") {
              menu.setCurrentItem(firstMenuItem);
              firstMenuItem.focus();
            }
            if (event.key === "ArrowUp" || event.key === "End") {
              menu.setCurrentItem(lastMenuItem);
              lastMenuItem.focus();
            }
          });
        }
      }
    }
  }
  handleTriggerKeyUp(event) {
    if (event.key === " ") {
      event.preventDefault();
    }
  }
  handleTriggerSlotChange() {
    this.updateAccessibleTrigger();
  }
  //
  // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and
  // `aria-expanded`. These must be applied to the "accessible trigger" (the tabbable portion of the trigger element
  // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,
  // a child of the slotted element, or an element in the slotted element's shadow root.
  //
  // For example, the accessible trigger of an <sl-button> is a <button> located inside its shadow root.
  //
  // To determine this, we assume the first tabbable element in the trigger slot is the "accessible trigger."
  //
  updateAccessibleTrigger() {
    const assignedElements = this.trigger.assignedElements({ flatten: true });
    const accessibleTrigger = assignedElements.find(
      (el) => getTabbableBoundary(el).start,
    );
    let target;
    if (accessibleTrigger) {
      switch (accessibleTrigger.tagName.toLowerCase()) {
        // Shoelace buttons have to update the internal button so it's announced correctly by screen readers
        case "sl-button":
        case "sl-icon-button":
          target = accessibleTrigger.button;
          break;
        default:
          target = accessibleTrigger;
      }
      target.setAttribute("aria-haspopup", "true");
      target.setAttribute("aria-expanded", this.open ? "true" : "false");
    }
  }
  /** Shows the dropdown panel. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the dropdown panel */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /**
   * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu
   * is activated.
   */
  reposition() {
    this.popup.reposition();
  }
  addOpenListeners() {
    var _a2;
    this.panel.addEventListener("sl-select", this.handlePanelSelect);
    if ("CloseWatcher" in window) {
      (_a2 = this.closeWatcher) == null ? void 0 : _a2.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        this.hide();
        this.focusOnTrigger();
      };
    } else {
      this.panel.addEventListener("keydown", this.handleKeyDown);
    }
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    var _a2;
    if (this.panel) {
      this.panel.removeEventListener("sl-select", this.handlePanelSelect);
      this.panel.removeEventListener("keydown", this.handleKeyDown);
    }
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    (_a2 = this.closeWatcher) == null ? void 0 : _a2.destroy();
  }
  async handleOpenChange() {
    if (this.disabled) {
      this.open = false;
      return;
    }
    this.updateAccessibleTrigger();
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.panel.hidden = false;
      this.popup.active = true;
      const { keyframes, options } = getAnimation(this, "dropdown.show", {
        dir: this.localize.dir(),
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "dropdown.hide", {
        dir: this.localize.dir(),
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.panel.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  render() {
    return x$2`
      <sl-popup
        part="base"
        exportparts="popup:base__popup"
        id="dropdown"
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        auto-size="vertical"
        auto-size-padding="10"
        sync=${o$7(this.sync ? this.sync : void 0)}
        class=${e$4({
          dropdown: true,
          "dropdown--open": this.open,
        })}
      >
        <slot
          name="trigger"
          slot="anchor"
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
          @slotchange=${this.handleTriggerSlotChange}
        ></slot>

        <div aria-hidden=${this.open ? "false" : "true"} aria-labelledby="dropdown">
          <slot part="panel" class="dropdown__panel"></slot>
        </div>
      </sl-popup>
    `;
  }
};
SlDropdown.styles = [component_styles_default, dropdown_styles_default];
SlDropdown.dependencies = { "sl-popup": SlPopup };
__decorateClass([e$8(".dropdown")], SlDropdown.prototype, "popup", 2);
__decorateClass(
  [e$8(".dropdown__trigger")],
  SlDropdown.prototype,
  "trigger",
  2,
);
__decorateClass([e$8(".dropdown__panel")], SlDropdown.prototype, "panel", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlDropdown.prototype,
  "open",
  2,
);
__decorateClass([n$6({ reflect: true })], SlDropdown.prototype, "placement", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlDropdown.prototype,
  "disabled",
  2,
);
__decorateClass(
  [n$6({ attribute: "stay-open-on-select", type: Boolean, reflect: true })],
  SlDropdown.prototype,
  "stayOpenOnSelect",
  2,
);
__decorateClass(
  [n$6({ attribute: false })],
  SlDropdown.prototype,
  "containingElement",
  2,
);
__decorateClass([n$6({ type: Number })], SlDropdown.prototype, "distance", 2);
__decorateClass([n$6({ type: Number })], SlDropdown.prototype, "skidding", 2);
__decorateClass([n$6({ type: Boolean })], SlDropdown.prototype, "hoist", 2);
__decorateClass([n$6({ reflect: true })], SlDropdown.prototype, "sync", 2);
__decorateClass(
  [watch("open", { waitUntilFirstUpdate: true })],
  SlDropdown.prototype,
  "handleOpenChange",
  1,
);
setDefaultAnimation("dropdown.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 },
  ],
  options: { duration: 100, easing: "ease" },
});
setDefaultAnimation("dropdown.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 },
  ],
  options: { duration: 100, easing: "ease" },
});
var tagName$m = "sl-dropdown";
SlDropdown.define("sl-dropdown");
var reactWrapper$8 = o$8({
  tagName: tagName$m,
  elementClass: SlDropdown,
  react: React,
  events: {
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide",
  },
  displayName: "SlDropdown",
});
var dropdown_default = reactWrapper$8;
var SlFormatDate = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.date = /* @__PURE__ */ new Date();
    this.hourFormat = "auto";
  }
  render() {
    const date = new Date(this.date);
    const hour12 =
      this.hourFormat === "auto" ? void 0 : this.hourFormat === "12";
    if (isNaN(date.getMilliseconds())) {
      return void 0;
    }
    return x$2`
      <time datetime=${date.toISOString()}>
        ${this.localize.date(date, {
          weekday: this.weekday,
          era: this.era,
          year: this.year,
          month: this.month,
          day: this.day,
          hour: this.hour,
          minute: this.minute,
          second: this.second,
          timeZoneName: this.timeZoneName,
          timeZone: this.timeZone,
          hour12,
        })}
      </time>
    `;
  }
};
__decorateClass([n$6()], SlFormatDate.prototype, "date", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "weekday", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "era", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "year", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "month", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "day", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "hour", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "minute", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "second", 2);
__decorateClass(
  [n$6({ attribute: "time-zone-name" })],
  SlFormatDate.prototype,
  "timeZoneName",
  2,
);
__decorateClass(
  [n$6({ attribute: "time-zone" })],
  SlFormatDate.prototype,
  "timeZone",
  2,
);
__decorateClass(
  [n$6({ attribute: "hour-format" })],
  SlFormatDate.prototype,
  "hourFormat",
  2,
);
var tagName$l = "sl-format-date";
SlFormatDate.define("sl-format-date");
o$8({
  tagName: tagName$l,
  elementClass: SlFormatDate,
  react: React,
  events: {},
  displayName: "SlFormatDate",
});
var SlFormatBytes = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.value = 0;
    this.unit = "byte";
    this.display = "short";
  }
  render() {
    if (isNaN(this.value)) {
      return "";
    }
    const bitPrefixes = ["", "kilo", "mega", "giga", "tera"];
    const bytePrefixes = ["", "kilo", "mega", "giga", "tera", "peta"];
    const prefix = this.unit === "bit" ? bitPrefixes : bytePrefixes;
    const index = Math.max(
      0,
      Math.min(Math.floor(Math.log10(this.value) / 3), prefix.length - 1),
    );
    const unit = prefix[index] + this.unit;
    const valueToFormat = parseFloat(
      (this.value / Math.pow(1e3, index)).toPrecision(3),
    );
    return this.localize.number(valueToFormat, {
      style: "unit",
      unit,
      unitDisplay: this.display,
    });
  }
};
__decorateClass([n$6({ type: Number })], SlFormatBytes.prototype, "value", 2);
__decorateClass([n$6()], SlFormatBytes.prototype, "unit", 2);
__decorateClass([n$6()], SlFormatBytes.prototype, "display", 2);
var tagName$k = "sl-format-bytes";
SlFormatBytes.define("sl-format-bytes");
o$8({
  tagName: tagName$k,
  elementClass: SlFormatBytes,
  react: React,
  events: {},
  displayName: "SlFormatBytes",
});
var SlFormatNumber = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.value = 0;
    this.type = "decimal";
    this.noGrouping = false;
    this.currency = "USD";
    this.currencyDisplay = "symbol";
  }
  render() {
    if (isNaN(this.value)) {
      return "";
    }
    return this.localize.number(this.value, {
      style: this.type,
      currency: this.currency,
      currencyDisplay: this.currencyDisplay,
      useGrouping: !this.noGrouping,
      minimumIntegerDigits: this.minimumIntegerDigits,
      minimumFractionDigits: this.minimumFractionDigits,
      maximumFractionDigits: this.maximumFractionDigits,
      minimumSignificantDigits: this.minimumSignificantDigits,
      maximumSignificantDigits: this.maximumSignificantDigits,
    });
  }
};
__decorateClass([n$6({ type: Number })], SlFormatNumber.prototype, "value", 2);
__decorateClass([n$6()], SlFormatNumber.prototype, "type", 2);
__decorateClass(
  [n$6({ attribute: "no-grouping", type: Boolean })],
  SlFormatNumber.prototype,
  "noGrouping",
  2,
);
__decorateClass([n$6()], SlFormatNumber.prototype, "currency", 2);
__decorateClass(
  [n$6({ attribute: "currency-display" })],
  SlFormatNumber.prototype,
  "currencyDisplay",
  2,
);
__decorateClass(
  [n$6({ attribute: "minimum-integer-digits", type: Number })],
  SlFormatNumber.prototype,
  "minimumIntegerDigits",
  2,
);
__decorateClass(
  [n$6({ attribute: "minimum-fraction-digits", type: Number })],
  SlFormatNumber.prototype,
  "minimumFractionDigits",
  2,
);
__decorateClass(
  [n$6({ attribute: "maximum-fraction-digits", type: Number })],
  SlFormatNumber.prototype,
  "maximumFractionDigits",
  2,
);
__decorateClass(
  [n$6({ attribute: "minimum-significant-digits", type: Number })],
  SlFormatNumber.prototype,
  "minimumSignificantDigits",
  2,
);
__decorateClass(
  [n$6({ attribute: "maximum-significant-digits", type: Number })],
  SlFormatNumber.prototype,
  "maximumSignificantDigits",
  2,
);
var tagName$j = "sl-format-number";
SlFormatNumber.define("sl-format-number");
o$8({
  tagName: tagName$j,
  elementClass: SlFormatNumber,
  react: React,
  events: {},
  displayName: "SlFormatNumber",
});
var tagName$i = "sl-icon-button";
SlIconButton.define("sl-icon-button");
var reactWrapper$7 = o$8({
  tagName: tagName$i,
  elementClass: SlIconButton,
  react: React,
  events: {
    onSlBlur: "sl-blur",
    onSlFocus: "sl-focus",
  },
  displayName: "SlIconButton",
});
var icon_button_default = reactWrapper$7;
var include_styles_default = i$8`
  :host {
    display: block;
  }
`;
var includeFiles = /* @__PURE__ */ new Map();
function requestInclude(src, mode = "cors") {
  const prev = includeFiles.get(src);
  if (prev !== void 0) {
    return Promise.resolve(prev);
  }
  const fileDataPromise = fetch(src, { mode }).then(async (response) => {
    const res = {
      ok: response.ok,
      status: response.status,
      html: await response.text(),
    };
    includeFiles.set(src, res);
    return res;
  });
  includeFiles.set(src, fileDataPromise);
  return fileDataPromise;
}
var SlInclude = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.mode = "cors";
    this.allowScripts = false;
  }
  executeScript(script) {
    const newScript = document.createElement("script");
    [...script.attributes].forEach((attr) =>
      newScript.setAttribute(attr.name, attr.value),
    );
    newScript.textContent = script.textContent;
    script.parentNode.replaceChild(newScript, script);
  }
  async handleSrcChange() {
    try {
      const src = this.src;
      const file = await requestInclude(src, this.mode);
      if (src !== this.src) {
        return;
      }
      if (!file.ok) {
        this.emit("sl-error", { detail: { status: file.status } });
        return;
      }
      this.innerHTML = file.html;
      if (this.allowScripts) {
        [...this.querySelectorAll("script")].forEach((script) =>
          this.executeScript(script),
        );
      }
      this.emit("sl-load");
    } catch (e3) {
      this.emit("sl-error", { detail: { status: -1 } });
    }
  }
  render() {
    return x$2`<slot></slot>`;
  }
};
SlInclude.styles = [component_styles_default, include_styles_default];
__decorateClass([n$6()], SlInclude.prototype, "src", 2);
__decorateClass([n$6()], SlInclude.prototype, "mode", 2);
__decorateClass(
  [n$6({ attribute: "allow-scripts", type: Boolean })],
  SlInclude.prototype,
  "allowScripts",
  2,
);
__decorateClass([watch("src")], SlInclude.prototype, "handleSrcChange", 1);
var tagName$h = "sl-include";
SlInclude.define("sl-include");
o$8({
  tagName: tagName$h,
  elementClass: SlInclude,
  react: React,
  events: {
    onSlLoad: "sl-load",
    onSlError: "sl-error",
  },
  displayName: "SlInclude",
});
var card_styles_default = i$8`
  :host {
    --border-color: var(--sl-color-neutral-200);
    --border-radius: var(--sl-border-radius-medium);
    --border-width: 1px;
    --padding: var(--sl-spacing-large);

    display: inline-block;
  }

  .card {
    display: flex;
    flex-direction: column;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-small);
    border: solid var(--border-width) var(--border-color);
    border-radius: var(--border-radius);
  }

  .card__image {
    display: flex;
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
    margin: calc(-1 * var(--border-width));
    overflow: hidden;
  }

  .card__image::slotted(img) {
    display: block;
    width: 100%;
  }

  .card:not(.card--has-image) .card__image {
    display: none;
  }

  .card__header {
    display: block;
    border-bottom: solid var(--border-width) var(--border-color);
    padding: calc(var(--padding) / 2) var(--padding);
  }

  .card:not(.card--has-header) .card__header {
    display: none;
  }

  .card:not(.card--has-image) .card__header {
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
  }

  .card__body {
    display: block;
    padding: var(--padding);
  }

  .card--has-footer .card__footer {
    display: block;
    border-top: solid var(--border-width) var(--border-color);
    padding: var(--padding);
  }

  .card:not(.card--has-footer) .card__footer {
    display: none;
  }
`;
var SlCard = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(
      this,
      "footer",
      "header",
      "image",
    );
  }
  render() {
    return x$2`
      <div
        part="base"
        class=${e$4({
          card: true,
          "card--has-footer": this.hasSlotController.test("footer"),
          "card--has-image": this.hasSlotController.test("image"),
          "card--has-header": this.hasSlotController.test("header"),
        })}
      >
        <slot name="image" part="image" class="card__image"></slot>
        <slot name="header" part="header" class="card__header"></slot>
        <slot part="body" class="card__body"></slot>
        <slot name="footer" part="footer" class="card__footer"></slot>
      </div>
    `;
  }
};
SlCard.styles = [component_styles_default, card_styles_default];
var tagName$g = "sl-card";
SlCard.define("sl-card");
var reactWrapper$6 = o$8({
  tagName: tagName$g,
  elementClass: SlCard,
  react: React,
  events: {},
  displayName: "SlCard",
});
var card_default = reactWrapper$6;
var AutoplayController = class {
  constructor(host, tickCallback) {
    this.timerId = 0;
    this.activeInteractions = 0;
    this.paused = false;
    this.stopped = true;
    this.pause = () => {
      if (!this.activeInteractions++) {
        this.paused = true;
        this.host.requestUpdate();
      }
    };
    this.resume = () => {
      if (!--this.activeInteractions) {
        this.paused = false;
        this.host.requestUpdate();
      }
    };
    host.addController(this);
    this.host = host;
    this.tickCallback = tickCallback;
  }
  hostConnected() {
    this.host.addEventListener("mouseenter", this.pause);
    this.host.addEventListener("mouseleave", this.resume);
    this.host.addEventListener("focusin", this.pause);
    this.host.addEventListener("focusout", this.resume);
    this.host.addEventListener("touchstart", this.pause, { passive: true });
    this.host.addEventListener("touchend", this.resume);
  }
  hostDisconnected() {
    this.stop();
    this.host.removeEventListener("mouseenter", this.pause);
    this.host.removeEventListener("mouseleave", this.resume);
    this.host.removeEventListener("focusin", this.pause);
    this.host.removeEventListener("focusout", this.resume);
    this.host.removeEventListener("touchstart", this.pause);
    this.host.removeEventListener("touchend", this.resume);
  }
  start(interval) {
    this.stop();
    this.stopped = false;
    this.timerId = window.setInterval(() => {
      if (!this.paused) {
        this.tickCallback();
      }
    }, interval);
  }
  stop() {
    clearInterval(this.timerId);
    this.stopped = true;
    this.host.requestUpdate();
  }
};
var carousel_styles_default = i$8`
  :host {
    --slide-gap: var(--sl-spacing-medium, 1rem);
    --aspect-ratio: 16 / 9;
    --scroll-hint: 0px;

    display: flex;
  }

  .carousel {
    display: grid;
    grid-template-columns: min-content 1fr min-content;
    grid-template-rows: 1fr min-content;
    grid-template-areas:
      '. slides .'
      '. pagination .';
    gap: var(--sl-spacing-medium);
    align-items: center;
    min-height: 100%;
    min-width: 100%;
    position: relative;
  }

  .carousel__pagination {
    grid-area: pagination;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: var(--sl-spacing-small);
  }

  .carousel__slides {
    grid-area: slides;

    display: grid;
    height: 100%;
    width: 100%;
    align-items: center;
    justify-items: center;
    overflow: auto;
    overscroll-behavior-x: contain;
    scrollbar-width: none;
    aspect-ratio: calc(var(--aspect-ratio) * var(--slides-per-page));
    border-radius: var(--sl-border-radius-small);

    --slide-size: calc((100% - (var(--slides-per-page) - 1) * var(--slide-gap)) / var(--slides-per-page));
  }

  @media (prefers-reduced-motion) {
    :where(.carousel__slides) {
      scroll-behavior: auto;
    }
  }

  .carousel__slides--horizontal {
    grid-auto-flow: column;
    grid-auto-columns: var(--slide-size);
    grid-auto-rows: 100%;
    column-gap: var(--slide-gap);
    scroll-snap-type: x mandatory;
    scroll-padding-inline: var(--scroll-hint);
    padding-inline: var(--scroll-hint);
    overflow-y: hidden;
  }

  .carousel__slides--vertical {
    grid-auto-flow: row;
    grid-auto-columns: 100%;
    grid-auto-rows: var(--slide-size);
    row-gap: var(--slide-gap);
    scroll-snap-type: y mandatory;
    scroll-padding-block: var(--scroll-hint);
    padding-block: var(--scroll-hint);
    overflow-x: hidden;
  }

  .carousel__slides--dragging {
  }

  :host([vertical]) ::slotted(sl-carousel-item) {
    height: 100%;
  }

  .carousel__slides::-webkit-scrollbar {
    display: none;
  }

  .carousel__navigation {
    grid-area: navigation;
    display: contents;
    font-size: var(--sl-font-size-x-large);
  }

  .carousel__navigation-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-small);
    font-size: inherit;
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-medium) color;
    appearance: none;
  }

  .carousel__navigation-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .carousel__navigation-button--disabled::part(base) {
    pointer-events: none;
  }

  .carousel__navigation-button--previous {
    grid-column: 1;
    grid-row: 1;
  }

  .carousel__navigation-button--next {
    grid-column: 3;
    grid-row: 1;
  }

  .carousel__pagination-item {
    display: block;
    cursor: pointer;
    background: none;
    border: 0;
    border-radius: var(--sl-border-radius-circle);
    width: var(--sl-spacing-small);
    height: var(--sl-spacing-small);
    background-color: var(--sl-color-neutral-300);
    padding: 0;
    margin: 0;
  }

  .carousel__pagination-item--active {
    background-color: var(--sl-color-neutral-700);
    transform: scale(1.2);
  }

  /* Focus styles */
  .carousel__slides:focus-visible,
  .carousel__navigation-button:focus-visible,
  .carousel__pagination-item:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* o$1(o2, f2) {
  if (void 0 !== o2) {
    let i3 = 0;
    for (const t2 of o2) yield f2(t2, i3++);
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* o(o2, t2, e3 = 1) {
  const i3 = void 0 === t2 ? 0 : o2;
  t2 ?? (t2 = o2);
  for (let o3 = i3; e3 > 0 ? o3 < t2 : t2 < o3; o3 += e3) yield o3;
}
var SlCarousel = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.loop = false;
    this.navigation = false;
    this.pagination = false;
    this.autoplay = false;
    this.autoplayInterval = 3e3;
    this.slidesPerPage = 1;
    this.slidesPerMove = 1;
    this.orientation = "horizontal";
    this.mouseDragging = false;
    this.activeSlide = 0;
    this.scrolling = false;
    this.dragging = false;
    this.autoplayController = new AutoplayController(this, () => this.next());
    this.dragStartPosition = [-1, -1];
    this.localize = new LocalizeController2(this);
    this.pendingSlideChange = false;
    this.handleMouseDrag = (event) => {
      if (!this.dragging) {
        this.scrollContainer.style.setProperty("scroll-snap-type", "none");
        this.dragging = true;
        this.dragStartPosition = [event.clientX, event.clientY];
      }
      this.scrollContainer.scrollBy({
        left: -event.movementX,
        top: -event.movementY,
        behavior: "instant",
      });
    };
    this.handleMouseDragEnd = () => {
      const scrollContainer = this.scrollContainer;
      document.removeEventListener("pointermove", this.handleMouseDrag, {
        capture: true,
      });
      const startLeft = scrollContainer.scrollLeft;
      const startTop = scrollContainer.scrollTop;
      scrollContainer.style.removeProperty("scroll-snap-type");
      scrollContainer.style.setProperty("overflow", "hidden");
      const finalLeft = scrollContainer.scrollLeft;
      const finalTop = scrollContainer.scrollTop;
      scrollContainer.style.removeProperty("overflow");
      scrollContainer.style.setProperty("scroll-snap-type", "none");
      scrollContainer.scrollTo({
        left: startLeft,
        top: startTop,
        behavior: "instant",
      });
      requestAnimationFrame(async () => {
        if (startLeft !== finalLeft || startTop !== finalTop) {
          scrollContainer.scrollTo({
            left: finalLeft,
            top: finalTop,
            behavior: prefersReducedMotion() ? "auto" : "smooth",
          });
          await waitForEvent(scrollContainer, "scrollend");
        }
        scrollContainer.style.removeProperty("scroll-snap-type");
        this.dragging = false;
        this.dragStartPosition = [-1, -1];
        this.handleScrollEnd();
      });
    };
    this.handleSlotChange = (mutations) => {
      const needsInitialization = mutations.some((mutation) =>
        [...mutation.addedNodes, ...mutation.removedNodes].some(
          (el) => this.isCarouselItem(el) && !el.hasAttribute("data-clone"),
        ),
      );
      if (needsInitialization) {
        this.initializeSlides();
      }
      this.requestUpdate();
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "region");
    this.setAttribute("aria-label", this.localize.term("carousel"));
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback();
    (_a2 = this.mutationObserver) == null ? void 0 : _a2.disconnect();
  }
  firstUpdated() {
    this.initializeSlides();
    this.mutationObserver = new MutationObserver(this.handleSlotChange);
    this.mutationObserver.observe(this, {
      childList: true,
      subtree: true,
    });
  }
  willUpdate(changedProperties) {
    if (
      changedProperties.has("slidesPerMove") ||
      changedProperties.has("slidesPerPage")
    ) {
      this.slidesPerMove = Math.min(this.slidesPerMove, this.slidesPerPage);
    }
  }
  getPageCount() {
    const slidesCount = this.getSlides().length;
    const { slidesPerPage, slidesPerMove, loop } = this;
    const pages = loop
      ? slidesCount / slidesPerMove
      : (slidesCount - slidesPerPage) / slidesPerMove + 1;
    return Math.ceil(pages);
  }
  getCurrentPage() {
    return Math.ceil(this.activeSlide / this.slidesPerMove);
  }
  canScrollNext() {
    return this.loop || this.getCurrentPage() < this.getPageCount() - 1;
  }
  canScrollPrev() {
    return this.loop || this.getCurrentPage() > 0;
  }
  /** @internal Gets all carousel items. */
  getSlides({ excludeClones = true } = {}) {
    return [...this.children].filter(
      (el) =>
        this.isCarouselItem(el) &&
        (!excludeClones || !el.hasAttribute("data-clone")),
    );
  }
  handleClick(event) {
    if (
      this.dragging &&
      this.dragStartPosition[0] > 0 &&
      this.dragStartPosition[1] > 0
    ) {
      const deltaX = Math.abs(this.dragStartPosition[0] - event.clientX);
      const deltaY = Math.abs(this.dragStartPosition[1] - event.clientY);
      const delta = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      if (delta >= 10) {
        event.preventDefault();
      }
    }
  }
  handleKeyDown(event) {
    if (
      [
        "ArrowLeft",
        "ArrowRight",
        "ArrowUp",
        "ArrowDown",
        "Home",
        "End",
      ].includes(event.key)
    ) {
      const target = event.target;
      const isRtl = this.localize.dir() === "rtl";
      const isFocusInPagination =
        target.closest('[part~="pagination-item"]') !== null;
      const isNext =
        event.key === "ArrowDown" ||
        (!isRtl && event.key === "ArrowRight") ||
        (isRtl && event.key === "ArrowLeft");
      const isPrevious =
        event.key === "ArrowUp" ||
        (!isRtl && event.key === "ArrowLeft") ||
        (isRtl && event.key === "ArrowRight");
      event.preventDefault();
      if (isPrevious) {
        this.previous();
      }
      if (isNext) {
        this.next();
      }
      if (event.key === "Home") {
        this.goToSlide(0);
      }
      if (event.key === "End") {
        this.goToSlide(this.getSlides().length - 1);
      }
      if (isFocusInPagination) {
        this.updateComplete.then(() => {
          var _a2;
          const activePaginationItem =
            (_a2 = this.shadowRoot) == null
              ? void 0
              : _a2.querySelector('[part~="pagination-item--active"]');
          if (activePaginationItem) {
            activePaginationItem.focus();
          }
        });
      }
    }
  }
  handleMouseDragStart(event) {
    const canDrag = this.mouseDragging && event.button === 0;
    if (canDrag) {
      event.preventDefault();
      document.addEventListener("pointermove", this.handleMouseDrag, {
        capture: true,
        passive: true,
      });
      document.addEventListener("pointerup", this.handleMouseDragEnd, {
        capture: true,
        once: true,
      });
    }
  }
  handleScroll() {
    this.scrolling = true;
    if (!this.pendingSlideChange) {
      this.synchronizeSlides();
    }
  }
  /** @internal Synchronizes the slides with the IntersectionObserver API. */
  synchronizeSlides() {
    const io = new IntersectionObserver(
      (entries) => {
        io.disconnect();
        for (const entry of entries) {
          const slide = entry.target;
          slide.toggleAttribute("inert", !entry.isIntersecting);
          slide.classList.toggle("--in-view", entry.isIntersecting);
          slide.setAttribute(
            "aria-hidden",
            entry.isIntersecting ? "false" : "true",
          );
        }
        const firstIntersecting = entries.find((entry) => entry.isIntersecting);
        if (!firstIntersecting) {
          return;
        }
        const slidesWithClones = this.getSlides({ excludeClones: false });
        const slidesCount = this.getSlides().length;
        const slideIndex = slidesWithClones.indexOf(firstIntersecting.target);
        const normalizedIndex = this.loop
          ? slideIndex - this.slidesPerPage
          : slideIndex;
        this.activeSlide =
          (Math.ceil(normalizedIndex / this.slidesPerMove) *
            this.slidesPerMove +
            slidesCount) %
          slidesCount;
        if (!this.scrolling) {
          if (
            this.loop &&
            firstIntersecting.target.hasAttribute("data-clone")
          ) {
            const clonePosition = Number(
              firstIntersecting.target.getAttribute("data-clone"),
            );
            this.goToSlide(clonePosition, "instant");
          }
        }
      },
      {
        root: this.scrollContainer,
        threshold: 0.6,
      },
    );
    this.getSlides({ excludeClones: false }).forEach((slide) => {
      io.observe(slide);
    });
  }
  handleScrollEnd() {
    if (!this.scrolling || this.dragging) return;
    this.scrolling = false;
    this.pendingSlideChange = false;
    this.synchronizeSlides();
  }
  isCarouselItem(node) {
    return (
      node instanceof Element &&
      node.tagName.toLowerCase() === "sl-carousel-item"
    );
  }
  initializeSlides() {
    this.getSlides({ excludeClones: false }).forEach((slide, index) => {
      slide.classList.remove("--in-view");
      slide.classList.remove("--is-active");
      slide.setAttribute(
        "aria-label",
        this.localize.term("slideNum", index + 1),
      );
      if (slide.hasAttribute("data-clone")) {
        slide.remove();
      }
    });
    this.updateSlidesSnap();
    if (this.loop) {
      this.createClones();
    }
    this.goToSlide(this.activeSlide, "auto");
    this.synchronizeSlides();
  }
  createClones() {
    const slides = this.getSlides();
    const slidesPerPage = this.slidesPerPage;
    const lastSlides = slides.slice(-slidesPerPage);
    const firstSlides = slides.slice(0, slidesPerPage);
    lastSlides.reverse().forEach((slide, i3) => {
      const clone = slide.cloneNode(true);
      clone.setAttribute("data-clone", String(slides.length - i3 - 1));
      this.prepend(clone);
    });
    firstSlides.forEach((slide, i3) => {
      const clone = slide.cloneNode(true);
      clone.setAttribute("data-clone", String(i3));
      this.append(clone);
    });
  }
  handleSlideChange() {
    const slides = this.getSlides();
    slides.forEach((slide, i3) => {
      slide.classList.toggle("--is-active", i3 === this.activeSlide);
    });
    if (this.hasUpdated) {
      this.emit("sl-slide-change", {
        detail: {
          index: this.activeSlide,
          slide: slides[this.activeSlide],
        },
      });
    }
  }
  updateSlidesSnap() {
    const slides = this.getSlides();
    const slidesPerMove = this.slidesPerMove;
    slides.forEach((slide, i3) => {
      const shouldSnap = (i3 + slidesPerMove) % slidesPerMove === 0;
      if (shouldSnap) {
        slide.style.removeProperty("scroll-snap-align");
      } else {
        slide.style.setProperty("scroll-snap-align", "none");
      }
    });
  }
  handleAutoplayChange() {
    this.autoplayController.stop();
    if (this.autoplay) {
      this.autoplayController.start(this.autoplayInterval);
    }
  }
  /**
   * Move the carousel backward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  previous(behavior = "smooth") {
    this.goToSlide(this.activeSlide - this.slidesPerMove, behavior);
  }
  /**
   * Move the carousel forward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  next(behavior = "smooth") {
    this.goToSlide(this.activeSlide + this.slidesPerMove, behavior);
  }
  /**
   * Scrolls the carousel to the slide specified by `index`.
   *
   * @param index - The slide index.
   * @param behavior - The behavior used for scrolling.
   */
  goToSlide(index, behavior = "smooth") {
    const { slidesPerPage, loop } = this;
    const slides = this.getSlides();
    const slidesWithClones = this.getSlides({ excludeClones: false });
    if (!slides.length) {
      return;
    }
    const newActiveSlide = loop
      ? (index + slides.length) % slides.length
      : clamp(index, 0, slides.length - slidesPerPage);
    this.activeSlide = newActiveSlide;
    const isRtl = this.localize.dir() === "rtl";
    const nextSlideIndex = clamp(
      index + (loop ? slidesPerPage : 0) + (isRtl ? slidesPerPage - 1 : 0),
      0,
      slidesWithClones.length - 1,
    );
    const nextSlide = slidesWithClones[nextSlideIndex];
    this.scrollToSlide(nextSlide, prefersReducedMotion() ? "auto" : behavior);
  }
  scrollToSlide(slide, behavior = "smooth") {
    this.pendingSlideChange = true;
    window.requestAnimationFrame(() => {
      if (!this.scrollContainer) {
        return;
      }
      const scrollContainer = this.scrollContainer;
      const scrollContainerRect = scrollContainer.getBoundingClientRect();
      const nextSlideRect = slide.getBoundingClientRect();
      const nextLeft = nextSlideRect.left - scrollContainerRect.left;
      const nextTop = nextSlideRect.top - scrollContainerRect.top;
      if (nextLeft || nextTop) {
        this.pendingSlideChange = true;
        scrollContainer.scrollTo({
          left: nextLeft + scrollContainer.scrollLeft,
          top: nextTop + scrollContainer.scrollTop,
          behavior,
        });
      } else {
        this.pendingSlideChange = false;
      }
    });
  }
  render() {
    const { slidesPerMove, scrolling } = this;
    const pagesCount = this.getPageCount();
    const currentPage = this.getCurrentPage();
    const prevEnabled = this.canScrollPrev();
    const nextEnabled = this.canScrollNext();
    const isLtr = this.localize.dir() === "ltr";
    return x$2`
      <div part="base" class="carousel">
        <div
          id="scroll-container"
          part="scroll-container"
          class="${e$4({
            carousel__slides: true,
            "carousel__slides--horizontal": this.orientation === "horizontal",
            "carousel__slides--vertical": this.orientation === "vertical",
            "carousel__slides--dragging": this.dragging,
          })}"
          style="--slides-per-page: ${this.slidesPerPage};"
          aria-busy="${scrolling ? "true" : "false"}"
          aria-atomic="true"
          tabindex="0"
          @keydown=${this.handleKeyDown}
          @mousedown="${this.handleMouseDragStart}"
          @scroll="${this.handleScroll}"
          @scrollend=${this.handleScrollEnd}
          @click=${this.handleClick}
        >
          <slot></slot>
        </div>

        ${
          this.navigation
            ? x$2`
              <div part="navigation" class="carousel__navigation">
                <button
                  part="navigation-button navigation-button--previous"
                  class="${e$4({
                    "carousel__navigation-button": true,
                    "carousel__navigation-button--previous": true,
                    "carousel__navigation-button--disabled": !prevEnabled,
                  })}"
                  aria-label="${this.localize.term("previousSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${prevEnabled ? "false" : "true"}"
                  @click=${prevEnabled ? () => this.previous() : null}
                >
                  <slot name="previous-icon">
                    <sl-icon library="system" name="${isLtr ? "chevron-left" : "chevron-right"}"></sl-icon>
                  </slot>
                </button>

                <button
                  part="navigation-button navigation-button--next"
                  class=${e$4({
                    "carousel__navigation-button": true,
                    "carousel__navigation-button--next": true,
                    "carousel__navigation-button--disabled": !nextEnabled,
                  })}
                  aria-label="${this.localize.term("nextSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${nextEnabled ? "false" : "true"}"
                  @click=${nextEnabled ? () => this.next() : null}
                >
                  <slot name="next-icon">
                    <sl-icon library="system" name="${isLtr ? "chevron-right" : "chevron-left"}"></sl-icon>
                  </slot>
                </button>
              </div>
            `
            : ""
        }
        ${
          this.pagination
            ? x$2`
              <div part="pagination" role="tablist" class="carousel__pagination" aria-controls="scroll-container">
                ${o$1(o(pagesCount), (index) => {
                  const isActive = index === currentPage;
                  return x$2`
                    <button
                      part="pagination-item ${isActive ? "pagination-item--active" : ""}"
                      class="${e$4({
                        "carousel__pagination-item": true,
                        "carousel__pagination-item--active": isActive,
                      })}"
                      role="tab"
                      aria-selected="${isActive ? "true" : "false"}"
                      aria-label="${this.localize.term("goToSlide", index + 1, pagesCount)}"
                      tabindex=${isActive ? "0" : "-1"}
                      @click=${() => this.goToSlide(index * slidesPerMove)}
                      @keydown=${this.handleKeyDown}
                    ></button>
                  `;
                })}
              </div>
            `
            : ""
        }
      </div>
    `;
  }
};
SlCarousel.styles = [component_styles_default, carousel_styles_default];
SlCarousel.dependencies = { "sl-icon": SlIcon };
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlCarousel.prototype,
  "loop",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlCarousel.prototype,
  "navigation",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlCarousel.prototype,
  "pagination",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlCarousel.prototype,
  "autoplay",
  2,
);
__decorateClass(
  [n$6({ type: Number, attribute: "autoplay-interval" })],
  SlCarousel.prototype,
  "autoplayInterval",
  2,
);
__decorateClass(
  [n$6({ type: Number, attribute: "slides-per-page" })],
  SlCarousel.prototype,
  "slidesPerPage",
  2,
);
__decorateClass(
  [n$6({ type: Number, attribute: "slides-per-move" })],
  SlCarousel.prototype,
  "slidesPerMove",
  2,
);
__decorateClass([n$6()], SlCarousel.prototype, "orientation", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true, attribute: "mouse-dragging" })],
  SlCarousel.prototype,
  "mouseDragging",
  2,
);
__decorateClass(
  [e$8(".carousel__slides")],
  SlCarousel.prototype,
  "scrollContainer",
  2,
);
__decorateClass(
  [e$8(".carousel__pagination")],
  SlCarousel.prototype,
  "paginationContainer",
  2,
);
__decorateClass([r$4()], SlCarousel.prototype, "activeSlide", 2);
__decorateClass([r$4()], SlCarousel.prototype, "scrolling", 2);
__decorateClass([r$4()], SlCarousel.prototype, "dragging", 2);
__decorateClass(
  [t$3({ passive: true })],
  SlCarousel.prototype,
  "handleScroll",
  1,
);
__decorateClass(
  [
    watch("loop", { waitUntilFirstUpdate: true }),
    watch("slidesPerPage", { waitUntilFirstUpdate: true }),
  ],
  SlCarousel.prototype,
  "initializeSlides",
  1,
);
__decorateClass(
  [watch("activeSlide")],
  SlCarousel.prototype,
  "handleSlideChange",
  1,
);
__decorateClass(
  [watch("slidesPerMove")],
  SlCarousel.prototype,
  "updateSlidesSnap",
  1,
);
__decorateClass(
  [watch("autoplay")],
  SlCarousel.prototype,
  "handleAutoplayChange",
  1,
);
var tagName$f = "sl-carousel";
SlCarousel.define("sl-carousel");
o$8({
  tagName: tagName$f,
  elementClass: SlCarousel,
  react: React,
  events: {
    onSlSlideChange: "sl-slide-change",
  },
  displayName: "SlCarousel",
});
var carousel_item_styles_default = i$8`
  :host {
    --aspect-ratio: inherit;

    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    width: 100%;
    max-height: 100%;
    aspect-ratio: var(--aspect-ratio);
    scroll-snap-align: start;
    scroll-snap-stop: always;
  }

  ::slotted(img) {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover;
  }
`;
var SlCarouselItem = class extends ShoelaceElement {
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "group");
  }
  render() {
    return x$2` <slot></slot> `;
  }
};
SlCarouselItem.styles = [
  component_styles_default,
  carousel_item_styles_default,
];
var tagName$e = "sl-carousel-item";
SlCarouselItem.define("sl-carousel-item");
o$8({
  tagName: tagName$e,
  elementClass: SlCarouselItem,
  react: React,
  events: {},
  displayName: "SlCarouselItem",
});
var color_picker_styles_default = i$8`
  :host {
    --grid-width: 280px;
    --grid-height: 200px;
    --grid-handle-size: 16px;
    --slider-height: 15px;
    --slider-handle-size: 17px;
    --swatch-size: 25px;

    display: inline-block;
  }

  .color-picker {
    width: var(--grid-width);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    color: var(--color);
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    user-select: none;
    -webkit-user-select: none;
  }

  .color-picker--inline {
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
  }

  .color-picker--inline:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__grid {
    position: relative;
    height: var(--grid-height);
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 100%),
      linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);
    border-top-left-radius: var(--sl-border-radius-medium);
    border-top-right-radius: var(--sl-border-radius-medium);
    cursor: crosshair;
    forced-color-adjust: none;
  }

  .color-picker__grid-handle {
    position: absolute;
    width: var(--grid-handle-size);
    height: var(--grid-handle-size);
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    border: solid 2px white;
    margin-top: calc(var(--grid-handle-size) / -2);
    margin-left: calc(var(--grid-handle-size) / -2);
    transition: var(--sl-transition-fast) scale;
  }

  .color-picker__grid-handle--dragging {
    cursor: none;
    scale: 1.5;
  }

  .color-picker__grid-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__controls {
    padding: var(--sl-spacing-small);
    display: flex;
    align-items: center;
  }

  .color-picker__sliders {
    flex: 1 1 auto;
  }

  .color-picker__slider {
    position: relative;
    height: var(--slider-height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);
    forced-color-adjust: none;
  }

  .color-picker__slider:not(:last-of-type) {
    margin-bottom: var(--sl-spacing-small);
  }

  .color-picker__slider-handle {
    position: absolute;
    top: calc(50% - var(--slider-handle-size) / 2);
    width: var(--slider-handle-size);
    height: var(--slider-handle-size);
    background-color: white;
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    margin-left: calc(var(--slider-handle-size) / -2);
  }

  .color-picker__slider-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__hue {
    background-image: linear-gradient(
      to right,
      rgb(255, 0, 0) 0%,
      rgb(255, 255, 0) 17%,
      rgb(0, 255, 0) 33%,
      rgb(0, 255, 255) 50%,
      rgb(0, 0, 255) 67%,
      rgb(255, 0, 255) 83%,
      rgb(255, 0, 0) 100%
    );
  }

  .color-picker__alpha .color-picker__alpha-gradient {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
  }

  .color-picker__preview {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: 2.25rem;
    height: 2.25rem;
    border: none;
    border-radius: var(--sl-border-radius-circle);
    background: none;
    margin-left: var(--sl-spacing-small);
    cursor: copy;
    forced-color-adjust: none;
  }

  .color-picker__preview:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);

    /* We use a custom property in lieu of currentColor because of https://bugs.webkit.org/show_bug.cgi?id=216780 */
    background-color: var(--preview-color);
  }

  .color-picker__preview:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__preview-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
  }

  .color-picker__preview-color--copied {
    animation: pulse 0.75s;
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--sl-color-primary-500);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }

  .color-picker__user-input {
    display: flex;
    padding: 0 var(--sl-spacing-small) var(--sl-spacing-small) var(--sl-spacing-small);
  }

  .color-picker__user-input sl-input {
    min-width: 0; /* fix input width in Safari */
    flex: 1 1 auto;
  }

  .color-picker__user-input sl-button-group {
    margin-left: var(--sl-spacing-small);
  }

  .color-picker__user-input sl-button {
    min-width: 3.25rem;
    max-width: 3.25rem;
    font-size: 1rem;
  }

  .color-picker__swatches {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-gap: 0.5rem;
    justify-items: center;
    border-top: solid 1px var(--sl-color-neutral-200);
    padding: var(--sl-spacing-small);
    forced-color-adjust: none;
  }

  .color-picker__swatch {
    position: relative;
    width: var(--swatch-size);
    height: var(--swatch-size);
    border-radius: var(--sl-border-radius-small);
  }

  .color-picker__swatch .color-picker__swatch-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
    border-radius: inherit;
    cursor: pointer;
  }

  .color-picker__swatch:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__transparent-bg {
    background-image: linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%);
    background-size: 10px 10px;
    background-position:
      0 0,
      0 0,
      -5px -5px,
      5px 5px;
  }

  .color-picker--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .color-picker--disabled .color-picker__grid,
  .color-picker--disabled .color-picker__grid-handle,
  .color-picker--disabled .color-picker__slider,
  .color-picker--disabled .color-picker__slider-handle,
  .color-picker--disabled .color-picker__preview,
  .color-picker--disabled .color-picker__swatch,
  .color-picker--disabled .color-picker__swatch-color {
    pointer-events: none;
  }

  /*
   * Color dropdown
   */

  .color-dropdown::part(panel) {
    max-height: none;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    overflow: visible;
  }

  .color-dropdown__trigger {
    display: inline-block;
    position: relative;
    background-color: transparent;
    border: none;
    cursor: pointer;
    forced-color-adjust: none;
  }

  .color-dropdown__trigger.color-dropdown__trigger--small {
    width: var(--sl-input-height-small);
    height: var(--sl-input-height-small);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--medium {
    width: var(--sl-input-height-medium);
    height: var(--sl-input-height-medium);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--large {
    width: var(--sl-input-height-large);
    height: var(--sl-input-height-large);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    background-color: currentColor;
    box-shadow:
      inset 0 0 0 2px var(--sl-input-border-color),
      inset 0 0 0 4px var(--sl-color-neutral-0);
  }

  .color-dropdown__trigger--empty:before {
    background-color: transparent;
  }

  .color-dropdown__trigger:focus-visible {
    outline: none;
  }

  .color-dropdown__trigger:focus-visible:not(.color-dropdown__trigger--disabled) {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-dropdown__trigger.color-dropdown__trigger--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;
var SlButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["click"],
    });
    this.hasSlotController = new HasSlotController(
      this,
      "[default]",
      "prefix",
      "suffix",
    );
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.invalid = false;
    this.title = "";
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
    this.name = "";
    this.value = "";
    this.href = "";
    this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    if (this.isButton()) {
      return this.button.validity;
    }
    return validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    if (this.isButton()) {
      return this.button.validationMessage;
    }
    return "";
  }
  firstUpdated() {
    if (this.isButton()) {
      this.formControlController.updateValidity();
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick() {
    if (this.type === "submit") {
      this.formControlController.submit(this);
    }
    if (this.type === "reset") {
      this.formControlController.reset(this);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  isButton() {
    return this.href ? false : true;
  }
  isLink() {
    return this.href ? true : false;
  }
  handleDisabledChange() {
    if (this.isButton()) {
      this.formControlController.setValidity(this.disabled);
    }
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    if (this.isButton()) {
      return this.button.checkValidity();
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (this.isButton()) {
      return this.button.reportValidity();
    }
    return true;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    if (this.isButton()) {
      this.button.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
  }
  render() {
    const isLink = this.isLink();
    const tag = isLink ? i$2`a` : i$2`button`;
    return u`
      <${tag}
        part="base"
        class=${e$4({
          button: true,
          "button--default": this.variant === "default",
          "button--primary": this.variant === "primary",
          "button--success": this.variant === "success",
          "button--neutral": this.variant === "neutral",
          "button--warning": this.variant === "warning",
          "button--danger": this.variant === "danger",
          "button--text": this.variant === "text",
          "button--small": this.size === "small",
          "button--medium": this.size === "medium",
          "button--large": this.size === "large",
          "button--caret": this.caret,
          "button--circle": this.circle,
          "button--disabled": this.disabled,
          "button--focused": this.hasFocus,
          "button--loading": this.loading,
          "button--standard": !this.outline,
          "button--outline": this.outline,
          "button--pill": this.pill,
          "button--rtl": this.localize.dir() === "rtl",
          "button--has-label": this.hasSlotController.test("[default]"),
          "button--has-prefix": this.hasSlotController.test("prefix"),
          "button--has-suffix": this.hasSlotController.test("suffix"),
        })}
        ?disabled=${o$7(isLink ? void 0 : this.disabled)}
        type=${o$7(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${o$7(isLink ? void 0 : this.name)}
        value=${o$7(isLink ? void 0 : this.value)}
        href=${o$7(isLink && !this.disabled ? this.href : void 0)}
        target=${o$7(isLink ? this.target : void 0)}
        download=${o$7(isLink ? this.download : void 0)}
        rel=${o$7(isLink ? this.rel : void 0)}
        role=${o$7(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? u` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? u`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${tag}>
    `;
  }
};
SlButton.styles = [component_styles_default, button_styles_default];
SlButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner,
};
__decorateClass([e$8(".button")], SlButton.prototype, "button", 2);
__decorateClass([r$4()], SlButton.prototype, "hasFocus", 2);
__decorateClass([r$4()], SlButton.prototype, "invalid", 2);
__decorateClass([n$6()], SlButton.prototype, "title", 2);
__decorateClass([n$6({ reflect: true })], SlButton.prototype, "variant", 2);
__decorateClass([n$6({ reflect: true })], SlButton.prototype, "size", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlButton.prototype,
  "caret",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlButton.prototype,
  "disabled",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlButton.prototype,
  "loading",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlButton.prototype,
  "outline",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlButton.prototype,
  "pill",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlButton.prototype,
  "circle",
  2,
);
__decorateClass([n$6()], SlButton.prototype, "type", 2);
__decorateClass([n$6()], SlButton.prototype, "name", 2);
__decorateClass([n$6()], SlButton.prototype, "value", 2);
__decorateClass([n$6()], SlButton.prototype, "href", 2);
__decorateClass([n$6()], SlButton.prototype, "target", 2);
__decorateClass([n$6()], SlButton.prototype, "rel", 2);
__decorateClass([n$6()], SlButton.prototype, "download", 2);
__decorateClass([n$6()], SlButton.prototype, "form", 2);
__decorateClass(
  [n$6({ attribute: "formaction" })],
  SlButton.prototype,
  "formAction",
  2,
);
__decorateClass(
  [n$6({ attribute: "formenctype" })],
  SlButton.prototype,
  "formEnctype",
  2,
);
__decorateClass(
  [n$6({ attribute: "formmethod" })],
  SlButton.prototype,
  "formMethod",
  2,
);
__decorateClass(
  [n$6({ attribute: "formnovalidate", type: Boolean })],
  SlButton.prototype,
  "formNoValidate",
  2,
);
__decorateClass(
  [n$6({ attribute: "formtarget" })],
  SlButton.prototype,
  "formTarget",
  2,
);
__decorateClass(
  [watch("disabled", { waitUntilFirstUpdate: true })],
  SlButton.prototype,
  "handleDisabledChange",
  1,
);
function bound01(n3, max2) {
  if (isOnePointZero(n3)) {
    n3 = "100%";
  }
  const isPercent = isPercentage(n3);
  n3 = max2 === 360 ? n3 : Math.min(max2, Math.max(0, parseFloat(n3)));
  if (isPercent) {
    n3 = parseInt(String(n3 * max2), 10) / 100;
  }
  if (Math.abs(n3 - max2) < 1e-6) {
    return 1;
  }
  if (max2 === 360) {
    n3 = (n3 < 0 ? (n3 % max2) + max2 : n3 % max2) / parseFloat(String(max2));
  } else {
    n3 = (n3 % max2) / parseFloat(String(max2));
  }
  return n3;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n3) {
  return (
    typeof n3 === "string" && n3.indexOf(".") !== -1 && parseFloat(n3) === 1
  );
}
function isPercentage(n3) {
  return typeof n3 === "string" && n3.indexOf("%") !== -1;
}
function boundAlpha(a2) {
  a2 = parseFloat(a2);
  if (isNaN(a2) || a2 < 0 || a2 > 1) {
    a2 = 1;
  }
  return a2;
}
function convertToPercentage(n3) {
  if (Number(n3) <= 1) {
    return `${Number(n3) * 100}%`;
  }
  return n3;
}
function pad2(c2) {
  return c2.length === 1 ? "0" + c2 : String(c2);
}
function rgbToRgb(r3, g2, b3) {
  return {
    r: bound01(r3, 255) * 255,
    g: bound01(g2, 255) * 255,
    b: bound01(b3, 255) * 255,
  };
}
function rgbToHsl(r3, g2, b3) {
  r3 = bound01(r3, 255);
  g2 = bound01(g2, 255);
  b3 = bound01(b3, 255);
  const max2 = Math.max(r3, g2, b3);
  const min2 = Math.min(r3, g2, b3);
  let h2 = 0;
  let s2 = 0;
  const l2 = (max2 + min2) / 2;
  if (max2 === min2) {
    s2 = 0;
    h2 = 0;
  } else {
    const d2 = max2 - min2;
    s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
    switch (max2) {
      case r3:
        h2 = (g2 - b3) / d2 + (g2 < b3 ? 6 : 0);
        break;
      case g2:
        h2 = (b3 - r3) / d2 + 2;
        break;
      case b3:
        h2 = (r3 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, l: l2 };
}
function hue2rgb(p2, q2, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p2 + (q2 - p2) * (6 * t2);
  }
  if (t2 < 1 / 2) {
    return q2;
  }
  if (t2 < 2 / 3) {
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  }
  return p2;
}
function hslToRgb(h2, s2, l2) {
  let r3;
  let g2;
  let b3;
  h2 = bound01(h2, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  if (s2 === 0) {
    g2 = l2;
    b3 = l2;
    r3 = l2;
  } else {
    const q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    const p2 = 2 * l2 - q2;
    r3 = hue2rgb(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb(p2, q2, h2);
    b3 = hue2rgb(p2, q2, h2 - 1 / 3);
  }
  return { r: r3 * 255, g: g2 * 255, b: b3 * 255 };
}
function rgbToHsv(r3, g2, b3) {
  r3 = bound01(r3, 255);
  g2 = bound01(g2, 255);
  b3 = bound01(b3, 255);
  const max2 = Math.max(r3, g2, b3);
  const min2 = Math.min(r3, g2, b3);
  let h2 = 0;
  const v2 = max2;
  const d2 = max2 - min2;
  const s2 = max2 === 0 ? 0 : d2 / max2;
  if (max2 === min2) {
    h2 = 0;
  } else {
    switch (max2) {
      case r3:
        h2 = (g2 - b3) / d2 + (g2 < b3 ? 6 : 0);
        break;
      case g2:
        h2 = (b3 - r3) / d2 + 2;
        break;
      case b3:
        h2 = (r3 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, v: v2 };
}
function hsvToRgb(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  const i3 = Math.floor(h2);
  const f2 = h2 - i3;
  const p2 = v2 * (1 - s2);
  const q2 = v2 * (1 - f2 * s2);
  const t2 = v2 * (1 - (1 - f2) * s2);
  const mod = i3 % 6;
  const r3 = [v2, q2, p2, p2, t2, v2][mod];
  const g2 = [t2, v2, v2, q2, p2, p2][mod];
  const b3 = [p2, p2, t2, v2, v2, q2][mod];
  return { r: r3 * 255, g: g2 * 255, b: b3 * 255 };
}
function rgbToHex(r3, g2, b3, allow3Char) {
  const hex = [
    pad2(Math.round(r3).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b3).toString(16)),
  ];
  if (
    allow3Char &&
    hex[0].startsWith(hex[0].charAt(1)) &&
    hex[1].startsWith(hex[1].charAt(1)) &&
    hex[2].startsWith(hex[2].charAt(1))
  ) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r3, g2, b3, a2, allow4Char) {
  const hex = [
    pad2(Math.round(r3).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b3).toString(16)),
    pad2(convertDecimalToHex(a2)),
  ];
  if (
    allow4Char &&
    hex[0].startsWith(hex[0].charAt(1)) &&
    hex[1].startsWith(hex[1].charAt(1)) &&
    hex[2].startsWith(hex[2].charAt(1)) &&
    hex[3].startsWith(hex[3].charAt(1))
  ) {
    return (
      hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0)
    );
  }
  return hex.join("");
}
function cmykToRgb(c2, m2, y2, k3) {
  const cConv = c2 / 100;
  const mConv = m2 / 100;
  const yConv = y2 / 100;
  const kConv = k3 / 100;
  const r3 = 255 * (1 - cConv) * (1 - kConv);
  const g2 = 255 * (1 - mConv) * (1 - kConv);
  const b3 = 255 * (1 - yConv) * (1 - kConv);
  return { r: r3, g: g2, b: b3 };
}
function rgbToCmyk(r3, g2, b3) {
  let c2 = 1 - r3 / 255;
  let m2 = 1 - g2 / 255;
  let y2 = 1 - b3 / 255;
  let k3 = Math.min(c2, m2, y2);
  if (k3 === 1) {
    c2 = 0;
    m2 = 0;
    y2 = 0;
  } else {
    c2 = ((c2 - k3) / (1 - k3)) * 100;
    m2 = ((m2 - k3) / (1 - k3)) * 100;
    y2 = ((y2 - k3) / (1 - k3)) * 100;
  }
  k3 *= 100;
  return {
    c: Math.round(c2),
    m: Math.round(m2),
    y: Math.round(y2),
    k: Math.round(k3),
  };
}
function convertDecimalToHex(d2) {
  return Math.round(parseFloat(d2) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255,
  };
}
const names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32",
};
function inputToRGB(color) {
  let rgb = { r: 0, g: 0, b: 0 };
  let a2 = 1;
  let s2 = null;
  let v2 = null;
  let l2 = null;
  let ok = false;
  let format = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (
      isValidCSSUnit(color.r) &&
      isValidCSSUnit(color.g) &&
      isValidCSSUnit(color.b)
    ) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (
      isValidCSSUnit(color.h) &&
      isValidCSSUnit(color.s) &&
      isValidCSSUnit(color.v)
    ) {
      s2 = convertToPercentage(color.s);
      v2 = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s2, v2);
      ok = true;
      format = "hsv";
    } else if (
      isValidCSSUnit(color.h) &&
      isValidCSSUnit(color.s) &&
      isValidCSSUnit(color.l)
    ) {
      s2 = convertToPercentage(color.s);
      l2 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s2, l2);
      ok = true;
      format = "hsl";
    } else if (
      isValidCSSUnit(color.c) &&
      isValidCSSUnit(color.m) &&
      isValidCSSUnit(color.y) &&
      isValidCSSUnit(color.k)
    ) {
      rgb = cmykToRgb(color.c, color.m, color.y, color.k);
      ok = true;
      format = "cmyk";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a2 = color.a;
    }
  }
  a2 = boundAlpha(a2);
  return {
    ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a2,
  };
}
const CSS_INTEGER = "[-\\+]?\\d+%?";
const CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
const CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
const PERMISSIVE_MATCH3 =
  "[\\s|\\(]+(" +
  CSS_UNIT +
  ")[,|\\s]+(" +
  CSS_UNIT +
  ")[,|\\s]+(" +
  CSS_UNIT +
  ")\\s*\\)?";
const PERMISSIVE_MATCH4 =
  // eslint-disable-next-line prettier/prettier
  "[\\s|\\(]+(" +
  CSS_UNIT +
  ")[,|\\s]+(" +
  CSS_UNIT +
  ")[,|\\s]+(" +
  CSS_UNIT +
  ")[,|\\s]+(" +
  CSS_UNIT +
  ")\\s*\\)?";
const matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  cmyk: new RegExp("cmyk" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
};
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  let named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  let match = matchers.rgb.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3] };
  }
  match = matchers.rgba.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3], a: match[4] };
  }
  match = matchers.hsl.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3] };
  }
  match = matchers.hsla.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3], a: match[4] };
  }
  match = matchers.hsv.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3] };
  }
  match = matchers.hsva.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3], a: match[4] };
  }
  match = matchers.cmyk.exec(color);
  if (match) {
    return {
      c: match[1],
      m: match[2],
      y: match[3],
      k: match[4],
    };
  }
  match = matchers.hex8.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8",
    };
  }
  match = matchers.hex6.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex",
    };
  }
  match = matchers.hex4.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? "name" : "hex8",
    };
  }
  match = matchers.hex3.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? "name" : "hex",
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  if (typeof color === "number") {
    return !Number.isNaN(color);
  }
  return matchers.CSS_UNIT.test(color);
}
class TinyColor {
  constructor(color = "", opts = {}) {
    if (color instanceof TinyColor) {
      return color;
    }
    if (typeof color === "number") {
      color = numberInputToObject(color);
    }
    this.originalInput = color;
    const rgb = inputToRGB(color);
    this.originalInput = color;
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = rgb.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = opts.format ?? rgb.format;
    this.gradientType = opts.gradientType;
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
    this.isValid = rgb.ok;
  }
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return !this.isDark();
  }
  /**
   * Returns the perceived brightness of the color, from 0-255.
   */
  getBrightness() {
    const rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  }
  /**
   * Returns the perceived luminance of a color, from 0-1.
   */
  getLuminance() {
    const rgb = this.toRgb();
    let R3;
    let G2;
    let B2;
    const RsRGB = rgb.r / 255;
    const GsRGB = rgb.g / 255;
    const BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) {
      R3 = RsRGB / 12.92;
    } else {
      R3 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G2 = GsRGB / 12.92;
    } else {
      G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B2 = BsRGB / 12.92;
    } else {
      B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R3 + 0.7152 * G2 + 0.0722 * B2;
  }
  /**
   * Returns the alpha value of a color, from 0-1.
   */
  getAlpha() {
    return this.a;
  }
  /**
   * Sets the alpha value on the current color.
   *
   * @param alpha - The new alpha value. The accepted range is 0-1.
   */
  setAlpha(alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  }
  /**
   * Returns whether the color is monochrome.
   */
  isMonochrome() {
    const { s: s2 } = this.toHsl();
    return s2 === 0;
  }
  /**
   * Returns the object as a HSVA object.
   */
  toHsv() {
    const hsv = rgbToHsv(this.r, this.g, this.b);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
  }
  /**
   * Returns the hsva values interpolated into a string with the following format:
   * "hsva(xxx, xxx, xxx, xx)".
   */
  toHsvString() {
    const hsv = rgbToHsv(this.r, this.g, this.b);
    const h2 = Math.round(hsv.h * 360);
    const s2 = Math.round(hsv.s * 100);
    const v2 = Math.round(hsv.v * 100);
    return this.a === 1
      ? `hsv(${h2}, ${s2}%, ${v2}%)`
      : `hsva(${h2}, ${s2}%, ${v2}%, ${this.roundA})`;
  }
  /**
   * Returns the object as a HSLA object.
   */
  toHsl() {
    const hsl = rgbToHsl(this.r, this.g, this.b);
    return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
  }
  /**
   * Returns the hsla values interpolated into a string with the following format:
   * "hsla(xxx, xxx, xxx, xx)".
   */
  toHslString() {
    const hsl = rgbToHsl(this.r, this.g, this.b);
    const h2 = Math.round(hsl.h * 360);
    const s2 = Math.round(hsl.s * 100);
    const l2 = Math.round(hsl.l * 100);
    return this.a === 1
      ? `hsl(${h2}, ${s2}%, ${l2}%)`
      : `hsla(${h2}, ${s2}%, ${l2}%, ${this.roundA})`;
  }
  /**
   * Returns the hex value of the color.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHex(allow3Char = false) {
    return rgbToHex(this.r, this.g, this.b, allow3Char);
  }
  /**
   * Returns the hex value of the color -with a # prefixed.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHexString(allow3Char = false) {
    return "#" + this.toHex(allow3Char);
  }
  /**
   * Returns the hex 8 value of the color.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8(allow4Char = false) {
    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  }
  /**
   * Returns the hex 8 value of the color -with a # prefixed.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8String(allow4Char = false) {
    return "#" + this.toHex8(allow4Char);
  }
  /**
   * Returns the shorter hex value of the color depends on its alpha -with a # prefixed.
   * @param allowShortChar will shorten hex value to 3 or 4 char if possible
   */
  toHexShortString(allowShortChar = false) {
    return this.a === 1
      ? this.toHexString(allowShortChar)
      : this.toHex8String(allowShortChar);
  }
  /**
   * Returns the object as a RGBA object.
   */
  toRgb() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a,
    };
  }
  /**
   * Returns the RGBA values interpolated into a string with the following format:
   * "RGBA(xxx, xxx, xxx, xx)".
   */
  toRgbString() {
    const r3 = Math.round(this.r);
    const g2 = Math.round(this.g);
    const b3 = Math.round(this.b);
    return this.a === 1
      ? `rgb(${r3}, ${g2}, ${b3})`
      : `rgba(${r3}, ${g2}, ${b3}, ${this.roundA})`;
  }
  /**
   * Returns the object as a RGBA object.
   */
  toPercentageRgb() {
    const fmt = (x2) => `${Math.round(bound01(x2, 255) * 100)}%`;
    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a,
    };
  }
  /**
   * Returns the RGBA relative values interpolated into a string
   */
  toPercentageRgbString() {
    const rnd = (x2) => Math.round(bound01(x2, 255) * 100);
    return this.a === 1
      ? `rgb(${rnd(this.r)}%, ${rnd(this.g)}%, ${rnd(this.b)}%)`
      : `rgba(${rnd(this.r)}%, ${rnd(this.g)}%, ${rnd(this.b)}%, ${this.roundA})`;
  }
  toCmyk() {
    return {
      ...rgbToCmyk(this.r, this.g, this.b),
    };
  }
  toCmykString() {
    const { c: c2, m: m2, y: y2, k: k3 } = rgbToCmyk(this.r, this.g, this.b);
    return `cmyk(${c2}, ${m2}, ${y2}, ${k3})`;
  }
  /**
   * The 'real' name of the color -if there is one.
   */
  toName() {
    if (this.a === 0) {
      return "transparent";
    }
    if (this.a < 1) {
      return false;
    }
    const hex = "#" + rgbToHex(this.r, this.g, this.b, false);
    for (const [key, value] of Object.entries(names)) {
      if (hex === value) {
        return key;
      }
    }
    return false;
  }
  toString(format) {
    const formatSet = Boolean(format);
    format = format ?? this.format;
    let formattedString = false;
    const hasAlpha = this.a < 1 && this.a >= 0;
    const needsAlphaFormat =
      !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
    if (needsAlphaFormat) {
      if (format === "name" && this.a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    if (format === "cmyk") {
      formattedString = this.toCmykString();
    }
    return formattedString || this.toHexString();
  }
  toNumber() {
    return (
      (Math.round(this.r) << 16) +
      (Math.round(this.g) << 8) +
      Math.round(this.b)
    );
  }
  clone() {
    return new TinyColor(this.toString());
  }
  /**
   * Lighten the color a given amount. Providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  lighten(amount = 10) {
    const hsl = this.toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor(hsl);
  }
  /**
   * Brighten the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  brighten(amount = 10) {
    const rgb = this.toRgb();
    rgb.r = Math.max(
      0,
      Math.min(255, rgb.r - Math.round(255 * -(amount / 100))),
    );
    rgb.g = Math.max(
      0,
      Math.min(255, rgb.g - Math.round(255 * -(amount / 100))),
    );
    rgb.b = Math.max(
      0,
      Math.min(255, rgb.b - Math.round(255 * -(amount / 100))),
    );
    return new TinyColor(rgb);
  }
  /**
   * Darken the color a given amount, from 0 to 100.
   * Providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  darken(amount = 10) {
    const hsl = this.toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor(hsl);
  }
  /**
   * Mix the color with pure white, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  tint(amount = 10) {
    return this.mix("white", amount);
  }
  /**
   * Mix the color with pure black, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  shade(amount = 10) {
    return this.mix("black", amount);
  }
  /**
   * Desaturate the color a given amount, from 0 to 100.
   * Providing 100 will is the same as calling greyscale
   * @param amount - valid between 1-100
   */
  desaturate(amount = 10) {
    const hsl = this.toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor(hsl);
  }
  /**
   * Saturate the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  saturate(amount = 10) {
    const hsl = this.toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor(hsl);
  }
  /**
   * Completely desaturates a color into greyscale.
   * Same as calling `desaturate(100)`
   */
  greyscale() {
    return this.desaturate(100);
  }
  /**
   * Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
   * Values outside of this range will be wrapped into this range.
   */
  spin(amount) {
    const hsl = this.toHsl();
    const hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return new TinyColor(hsl);
  }
  /**
   * Mix the current color a given amount with another color, from 0 to 100.
   * 0 means no mixing (return current color).
   */
  mix(color, amount = 50) {
    const rgb1 = this.toRgb();
    const rgb2 = new TinyColor(color).toRgb();
    const p2 = amount / 100;
    const rgba = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
      a: (rgb2.a - rgb1.a) * p2 + rgb1.a,
    };
    return new TinyColor(rgba);
  }
  analogous(results = 6, slices = 30) {
    const hsl = this.toHsl();
    const part = 360 / slices;
    const ret = [this];
    for (hsl.h = (hsl.h - ((part * results) >> 1) + 720) % 360; --results; ) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(new TinyColor(hsl));
    }
    return ret;
  }
  /**
   * taken from https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js
   */
  complement() {
    const hsl = this.toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return new TinyColor(hsl);
  }
  monochromatic(results = 6) {
    const hsv = this.toHsv();
    const { h: h2 } = hsv;
    const { s: s2 } = hsv;
    let { v: v2 } = hsv;
    const res = [];
    const modification = 1 / results;
    while (results--) {
      res.push(new TinyColor({ h: h2, s: s2, v: v2 }));
      v2 = (v2 + modification) % 1;
    }
    return res;
  }
  splitcomplement() {
    const hsl = this.toHsl();
    const { h: h2 } = hsl;
    return [
      this,
      new TinyColor({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
      new TinyColor({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l }),
    ];
  }
  /**
   * Compute how the color would appear on a background
   */
  onBackground(background) {
    const fg = this.toRgb();
    const bg = new TinyColor(background).toRgb();
    const alpha = fg.a + bg.a * (1 - fg.a);
    return new TinyColor({
      r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
      g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
      b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
      a: alpha,
    });
  }
  /**
   * Alias for `polyad(3)`
   */
  triad() {
    return this.polyad(3);
  }
  /**
   * Alias for `polyad(4)`
   */
  tetrad() {
    return this.polyad(4);
  }
  /**
   * Get polyad colors, like (for 1, 2, 3, 4, 5, 6, 7, 8, etc...)
   * monad, dyad, triad, tetrad, pentad, hexad, heptad, octad, etc...
   */
  polyad(n3) {
    const hsl = this.toHsl();
    const { h: h2 } = hsl;
    const result = [this];
    const increment = 360 / n3;
    for (let i3 = 1; i3 < n3; i3++) {
      result.push(
        new TinyColor({ h: (h2 + i3 * increment) % 360, s: hsl.s, l: hsl.l }),
      );
    }
    return result;
  }
  /**
   * compare color vs current color
   */
  equals(color) {
    const comparedColor = new TinyColor(color);
    if (this.format === "cmyk" || comparedColor.format === "cmyk") {
      return this.toCmykString() === comparedColor.toCmykString();
    }
    return this.toRgbString() === comparedColor.toRgbString();
  }
}
var hasEyeDropper = "EyeDropper" in window;
var SlColorPicker = class extends ShoelaceElement {
  constructor() {
    super();
    this.formControlController = new FormControlController(this);
    this.isSafeValue = false;
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.isDraggingGridHandle = false;
    this.isEmpty = false;
    this.inputValue = "";
    this.hue = 0;
    this.saturation = 100;
    this.brightness = 100;
    this.alpha = 100;
    this.value = "";
    this.defaultValue = "";
    this.label = "";
    this.format = "hex";
    this.inline = false;
    this.size = "medium";
    this.noFormatToggle = false;
    this.name = "";
    this.disabled = false;
    this.hoist = false;
    this.opacity = false;
    this.uppercase = false;
    this.swatches = "";
    this.form = "";
    this.required = false;
    this.handleFocusIn = () => {
      this.hasFocus = true;
      this.emit("sl-focus");
    };
    this.handleFocusOut = () => {
      this.hasFocus = false;
      this.emit("sl-blur");
    };
    this.addEventListener("focusin", this.handleFocusIn);
    this.addEventListener("focusout", this.handleFocusOut);
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.input.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  handleCopy() {
    this.input.select();
    document.execCommand("copy");
    this.previewButton.focus();
    this.previewButton.classList.add("color-picker__preview-color--copied");
    this.previewButton.addEventListener("animationend", () => {
      this.previewButton.classList.remove(
        "color-picker__preview-color--copied",
      );
    });
  }
  handleFormatToggle() {
    const formats = ["hex", "rgb", "hsl", "hsv"];
    const nextIndex = (formats.indexOf(this.format) + 1) % formats.length;
    this.format = formats[nextIndex];
    this.setColor(this.value);
    this.emit("sl-change");
    this.emit("sl-input");
  }
  handleAlphaDrag(event) {
    const container = this.shadowRoot.querySelector(
      ".color-picker__slider.color-picker__alpha",
    );
    const handle = container.querySelector(".color-picker__slider-handle");
    const { width } = container.getBoundingClientRect();
    let initialValue = this.value;
    let currentValue = this.value;
    handle.focus();
    event.preventDefault();
    drag(container, {
      onMove: (x2) => {
        this.alpha = clamp((x2 / width) * 100, 0, 100);
        this.syncValues();
        if (this.value !== currentValue) {
          currentValue = this.value;
          this.emit("sl-input");
        }
      },
      onStop: () => {
        if (this.value !== initialValue) {
          initialValue = this.value;
          this.emit("sl-change");
        }
      },
      initialEvent: event,
    });
  }
  handleHueDrag(event) {
    const container = this.shadowRoot.querySelector(
      ".color-picker__slider.color-picker__hue",
    );
    const handle = container.querySelector(".color-picker__slider-handle");
    const { width } = container.getBoundingClientRect();
    let initialValue = this.value;
    let currentValue = this.value;
    handle.focus();
    event.preventDefault();
    drag(container, {
      onMove: (x2) => {
        this.hue = clamp((x2 / width) * 360, 0, 360);
        this.syncValues();
        if (this.value !== currentValue) {
          currentValue = this.value;
          this.emit("sl-input");
        }
      },
      onStop: () => {
        if (this.value !== initialValue) {
          initialValue = this.value;
          this.emit("sl-change");
        }
      },
      initialEvent: event,
    });
  }
  handleGridDrag(event) {
    const grid = this.shadowRoot.querySelector(".color-picker__grid");
    const handle = grid.querySelector(".color-picker__grid-handle");
    const { width, height } = grid.getBoundingClientRect();
    let initialValue = this.value;
    let currentValue = this.value;
    handle.focus();
    event.preventDefault();
    this.isDraggingGridHandle = true;
    drag(grid, {
      onMove: (x2, y2) => {
        this.saturation = clamp((x2 / width) * 100, 0, 100);
        this.brightness = clamp(100 - (y2 / height) * 100, 0, 100);
        this.syncValues();
        if (this.value !== currentValue) {
          currentValue = this.value;
          this.emit("sl-input");
        }
      },
      onStop: () => {
        this.isDraggingGridHandle = false;
        if (this.value !== initialValue) {
          initialValue = this.value;
          this.emit("sl-change");
        }
      },
      initialEvent: event,
    });
  }
  handleAlphaKeyDown(event) {
    const increment = event.shiftKey ? 10 : 1;
    const oldValue = this.value;
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.alpha = clamp(this.alpha - increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.alpha = clamp(this.alpha + increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "Home") {
      event.preventDefault();
      this.alpha = 0;
      this.syncValues();
    }
    if (event.key === "End") {
      event.preventDefault();
      this.alpha = 100;
      this.syncValues();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleHueKeyDown(event) {
    const increment = event.shiftKey ? 10 : 1;
    const oldValue = this.value;
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.hue = clamp(this.hue - increment, 0, 360);
      this.syncValues();
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.hue = clamp(this.hue + increment, 0, 360);
      this.syncValues();
    }
    if (event.key === "Home") {
      event.preventDefault();
      this.hue = 0;
      this.syncValues();
    }
    if (event.key === "End") {
      event.preventDefault();
      this.hue = 360;
      this.syncValues();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleGridKeyDown(event) {
    const increment = event.shiftKey ? 10 : 1;
    const oldValue = this.value;
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.saturation = clamp(this.saturation - increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.saturation = clamp(this.saturation + increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      this.brightness = clamp(this.brightness + increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      this.brightness = clamp(this.brightness - increment, 0, 100);
      this.syncValues();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleInputChange(event) {
    const target = event.target;
    const oldValue = this.value;
    event.stopPropagation();
    if (this.input.value) {
      this.setColor(target.value);
      target.value = this.value;
    } else {
      this.value = "";
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleInputInput(event) {
    this.formControlController.updateValidity();
    event.stopPropagation();
  }
  handleInputKeyDown(event) {
    if (event.key === "Enter") {
      const oldValue = this.value;
      if (this.input.value) {
        this.setColor(this.input.value);
        this.input.value = this.value;
        if (this.value !== oldValue) {
          this.emit("sl-change");
          this.emit("sl-input");
        }
        setTimeout(() => this.input.select());
      } else {
        this.hue = 0;
      }
    }
  }
  handleInputInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleTouchMove(event) {
    event.preventDefault();
  }
  parseColor(colorString) {
    const color = new TinyColor(colorString);
    if (!color.isValid) {
      return null;
    }
    const hslColor = color.toHsl();
    const hsl = {
      h: hslColor.h,
      s: hslColor.s * 100,
      l: hslColor.l * 100,
      a: hslColor.a,
    };
    const rgb = color.toRgb();
    const hex = color.toHexString();
    const hexa = color.toHex8String();
    const hsvColor = color.toHsv();
    const hsv = {
      h: hsvColor.h,
      s: hsvColor.s * 100,
      v: hsvColor.v * 100,
      a: hsvColor.a,
    };
    return {
      hsl: {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        string: this.setLetterCase(
          `hsl(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%)`,
        ),
      },
      hsla: {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        string: this.setLetterCase(
          `hsla(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%, ${hsl.a.toFixed(2).toString()})`,
        ),
      },
      hsv: {
        h: hsv.h,
        s: hsv.s,
        v: hsv.v,
        string: this.setLetterCase(
          `hsv(${Math.round(hsv.h)}, ${Math.round(hsv.s)}%, ${Math.round(hsv.v)}%)`,
        ),
      },
      hsva: {
        h: hsv.h,
        s: hsv.s,
        v: hsv.v,
        a: hsv.a,
        string: this.setLetterCase(
          `hsva(${Math.round(hsv.h)}, ${Math.round(hsv.s)}%, ${Math.round(hsv.v)}%, ${hsv.a.toFixed(2).toString()})`,
        ),
      },
      rgb: {
        r: rgb.r,
        g: rgb.g,
        b: rgb.b,
        string: this.setLetterCase(
          `rgb(${Math.round(rgb.r)}, ${Math.round(rgb.g)}, ${Math.round(rgb.b)})`,
        ),
      },
      rgba: {
        r: rgb.r,
        g: rgb.g,
        b: rgb.b,
        a: rgb.a,
        string: this.setLetterCase(
          `rgba(${Math.round(rgb.r)}, ${Math.round(rgb.g)}, ${Math.round(rgb.b)}, ${rgb.a.toFixed(2).toString()})`,
        ),
      },
      hex: this.setLetterCase(hex),
      hexa: this.setLetterCase(hexa),
    };
  }
  setColor(colorString) {
    const newColor = this.parseColor(colorString);
    if (newColor === null) {
      return false;
    }
    this.hue = newColor.hsva.h;
    this.saturation = newColor.hsva.s;
    this.brightness = newColor.hsva.v;
    this.alpha = this.opacity ? newColor.hsva.a * 100 : 100;
    this.syncValues();
    return true;
  }
  setLetterCase(string) {
    if (typeof string !== "string") {
      return "";
    }
    return this.uppercase ? string.toUpperCase() : string.toLowerCase();
  }
  async syncValues() {
    const currentColor = this.parseColor(
      `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`,
    );
    if (currentColor === null) {
      return;
    }
    if (this.format === "hsl") {
      this.inputValue = this.opacity
        ? currentColor.hsla.string
        : currentColor.hsl.string;
    } else if (this.format === "rgb") {
      this.inputValue = this.opacity
        ? currentColor.rgba.string
        : currentColor.rgb.string;
    } else if (this.format === "hsv") {
      this.inputValue = this.opacity
        ? currentColor.hsva.string
        : currentColor.hsv.string;
    } else {
      this.inputValue = this.opacity ? currentColor.hexa : currentColor.hex;
    }
    this.isSafeValue = true;
    this.value = this.inputValue;
    await this.updateComplete;
    this.isSafeValue = false;
  }
  handleAfterHide() {
    this.previewButton.classList.remove("color-picker__preview-color--copied");
  }
  handleEyeDropper() {
    if (!hasEyeDropper) {
      return;
    }
    const eyeDropper = new EyeDropper();
    eyeDropper
      .open()
      .then((colorSelectionResult) => {
        const oldValue = this.value;
        this.setColor(colorSelectionResult.sRGBHex);
        if (this.value !== oldValue) {
          this.emit("sl-change");
          this.emit("sl-input");
        }
      })
      .catch(() => {});
  }
  selectSwatch(color) {
    const oldValue = this.value;
    if (!this.disabled) {
      this.setColor(color);
      if (this.value !== oldValue) {
        this.emit("sl-change");
        this.emit("sl-input");
      }
    }
  }
  /** Generates a hex string from HSV values. Hue must be 0-360. All other arguments must be 0-100. */
  getHexString(hue, saturation, brightness, alpha = 100) {
    const color = new TinyColor(
      `hsva(${hue}, ${saturation}%, ${brightness}%, ${alpha / 100})`,
    );
    if (!color.isValid) {
      return "";
    }
    return color.toHex8String();
  }
  // Prevents nested components from leaking events
  stopNestedEventPropagation(event) {
    event.stopImmediatePropagation();
  }
  handleFormatChange() {
    this.syncValues();
  }
  handleOpacityChange() {
    this.alpha = 100;
  }
  handleValueChange(oldValue, newValue) {
    this.isEmpty = !newValue;
    if (!newValue) {
      this.hue = 0;
      this.saturation = 0;
      this.brightness = 100;
      this.alpha = 100;
    }
    if (!this.isSafeValue) {
      const newColor = this.parseColor(newValue);
      if (newColor !== null) {
        this.inputValue = this.value;
        this.hue = newColor.hsva.h;
        this.saturation = newColor.hsva.s;
        this.brightness = newColor.hsva.v;
        this.alpha = newColor.hsva.a * 100;
        this.syncValues();
      } else {
        this.inputValue = oldValue != null ? oldValue : "";
      }
    }
  }
  /** Sets focus on the color picker. */
  focus(options) {
    if (this.inline) {
      this.base.focus(options);
    } else {
      this.trigger.focus(options);
    }
  }
  /** Removes focus from the color picker. */
  blur() {
    var _a2;
    const elementToBlur = this.inline ? this.base : this.trigger;
    if (this.hasFocus) {
      elementToBlur.focus({ preventScroll: true });
      elementToBlur.blur();
    }
    if ((_a2 = this.dropdown) == null ? void 0 : _a2.open) {
      this.dropdown.hide();
    }
  }
  /** Returns the current value as a string in the specified format. */
  getFormattedValue(format = "hex") {
    const currentColor = this.parseColor(
      `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`,
    );
    if (currentColor === null) {
      return "";
    }
    switch (format) {
      case "hex":
        return currentColor.hex;
      case "hexa":
        return currentColor.hexa;
      case "rgb":
        return currentColor.rgb.string;
      case "rgba":
        return currentColor.rgba.string;
      case "hsl":
        return currentColor.hsl.string;
      case "hsla":
        return currentColor.hsla.string;
      case "hsv":
        return currentColor.hsv.string;
      case "hsva":
        return currentColor.hsva.string;
      default:
        return "";
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (!this.inline && !this.validity.valid) {
      this.dropdown.show();
      this.addEventListener(
        "sl-after-show",
        () => this.input.reportValidity(),
        { once: true },
      );
      if (!this.disabled) {
        this.formControlController.emitInvalidEvent();
      }
      return false;
    }
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const gridHandleX = this.saturation;
    const gridHandleY = 100 - this.brightness;
    const swatches = Array.isArray(this.swatches)
      ? this.swatches
      : this.swatches.split(";").filter((color) => color.trim() !== "");
    const colorPicker = x$2`
      <div
        part="base"
        class=${e$4({
          "color-picker": true,
          "color-picker--inline": this.inline,
          "color-picker--disabled": this.disabled,
          "color-picker--focused": this.hasFocus,
        })}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-labelledby="label"
        tabindex=${this.inline ? "0" : "-1"}
      >
        ${
          this.inline
            ? x$2`
              <sl-visually-hidden id="label">
                <slot name="label">${this.label}</slot>
              </sl-visually-hidden>
            `
            : null
        }

        <div
          part="grid"
          class="color-picker__grid"
          style=${o$4({ backgroundColor: this.getHexString(this.hue, 100, 100) })}
          @pointerdown=${this.handleGridDrag}
          @touchmove=${this.handleTouchMove}
        >
          <span
            part="grid-handle"
            class=${e$4({
              "color-picker__grid-handle": true,
              "color-picker__grid-handle--dragging": this.isDraggingGridHandle,
            })}
            style=${o$4({
              top: `${gridHandleY}%`,
              left: `${gridHandleX}%`,
              backgroundColor: this.getHexString(
                this.hue,
                this.saturation,
                this.brightness,
                this.alpha,
              ),
            })}
            role="application"
            aria-label="HSV"
            tabindex=${o$7(this.disabled ? void 0 : "0")}
            @keydown=${this.handleGridKeyDown}
          ></span>
        </div>

        <div class="color-picker__controls">
          <div class="color-picker__sliders">
            <div
              part="slider hue-slider"
              class="color-picker__hue color-picker__slider"
              @pointerdown=${this.handleHueDrag}
              @touchmove=${this.handleTouchMove}
            >
              <span
                part="slider-handle hue-slider-handle"
                class="color-picker__slider-handle"
                style=${o$4({
                  left: `${this.hue === 0 ? 0 : 100 / (360 / this.hue)}%`,
                })}
                role="slider"
                aria-label="hue"
                aria-orientation="horizontal"
                aria-valuemin="0"
                aria-valuemax="360"
                aria-valuenow=${`${Math.round(this.hue)}`}
                tabindex=${o$7(this.disabled ? void 0 : "0")}
                @keydown=${this.handleHueKeyDown}
              ></span>
            </div>

            ${
              this.opacity
                ? x$2`
                  <div
                    part="slider opacity-slider"
                    class="color-picker__alpha color-picker__slider color-picker__transparent-bg"
                    @pointerdown="${this.handleAlphaDrag}"
                    @touchmove=${this.handleTouchMove}
                  >
                    <div
                      class="color-picker__alpha-gradient"
                      style=${o$4({
                        backgroundImage: `linear-gradient(
                          to right,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 0)} 0%,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 100)} 100%
                        )`,
                      })}
                    ></div>
                    <span
                      part="slider-handle opacity-slider-handle"
                      class="color-picker__slider-handle"
                      style=${o$4({
                        left: `${this.alpha}%`,
                      })}
                      role="slider"
                      aria-label="alpha"
                      aria-orientation="horizontal"
                      aria-valuemin="0"
                      aria-valuemax="100"
                      aria-valuenow=${Math.round(this.alpha)}
                      tabindex=${o$7(this.disabled ? void 0 : "0")}
                      @keydown=${this.handleAlphaKeyDown}
                    ></span>
                  </div>
                `
                : ""
            }
          </div>

          <button
            type="button"
            part="preview"
            class="color-picker__preview color-picker__transparent-bg"
            aria-label=${this.localize.term("copy")}
            style=${o$4({
              "--preview-color": this.getHexString(
                this.hue,
                this.saturation,
                this.brightness,
                this.alpha,
              ),
            })}
            @click=${this.handleCopy}
          ></button>
        </div>

        <div class="color-picker__user-input" aria-live="polite">
          <sl-input
            part="input"
            type="text"
            name=${this.name}
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            value=${this.isEmpty ? "" : this.inputValue}
            ?required=${this.required}
            ?disabled=${this.disabled}
            aria-label=${this.localize.term("currentValue")}
            @keydown=${this.handleInputKeyDown}
            @sl-change=${this.handleInputChange}
            @sl-input=${this.handleInputInput}
            @sl-invalid=${this.handleInputInvalid}
            @sl-blur=${this.stopNestedEventPropagation}
            @sl-focus=${this.stopNestedEventPropagation}
          ></sl-input>

          <sl-button-group>
            ${
              !this.noFormatToggle
                ? x$2`
                  <sl-button
                    part="format-button"
                    aria-label=${this.localize.term("toggleColorFormat")}
                    exportparts="
                      base:format-button__base,
                      prefix:format-button__prefix,
                      label:format-button__label,
                      suffix:format-button__suffix,
                      caret:format-button__caret
                    "
                    @click=${this.handleFormatToggle}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    ${this.setLetterCase(this.format)}
                  </sl-button>
                `
                : ""
            }
            ${
              hasEyeDropper
                ? x$2`
                  <sl-button
                    part="eye-dropper-button"
                    exportparts="
                      base:eye-dropper-button__base,
                      prefix:eye-dropper-button__prefix,
                      label:eye-dropper-button__label,
                      suffix:eye-dropper-button__suffix,
                      caret:eye-dropper-button__caret
                    "
                    @click=${this.handleEyeDropper}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    <sl-icon
                      library="system"
                      name="eyedropper"
                      label=${this.localize.term("selectAColorFromTheScreen")}
                    ></sl-icon>
                  </sl-button>
                `
                : ""
            }
          </sl-button-group>
        </div>

        ${
          swatches.length > 0
            ? x$2`
              <div part="swatches" class="color-picker__swatches">
                ${swatches.map((swatch) => {
                  const parsedColor = this.parseColor(swatch);
                  if (!parsedColor) {
                    console.error(
                      `Unable to parse swatch color: "${swatch}"`,
                      this,
                    );
                    return "";
                  }
                  return x$2`
                    <div
                      part="swatch"
                      class="color-picker__swatch color-picker__transparent-bg"
                      tabindex=${o$7(this.disabled ? void 0 : "0")}
                      role="button"
                      aria-label=${swatch}
                      @click=${() => this.selectSwatch(swatch)}
                      @keydown=${(event) => !this.disabled && event.key === "Enter" && this.setColor(parsedColor.hexa)}
                    >
                      <div
                        class="color-picker__swatch-color"
                        style=${o$4({ backgroundColor: parsedColor.hexa })}
                      ></div>
                    </div>
                  `;
                })}
              </div>
            `
            : ""
        }
      </div>
    `;
    if (this.inline) {
      return colorPicker;
    }
    return x$2`
      <sl-dropdown
        class="color-dropdown"
        aria-disabled=${this.disabled ? "true" : "false"}
        .containingElement=${this}
        ?disabled=${this.disabled}
        ?hoist=${this.hoist}
        @sl-after-hide=${this.handleAfterHide}
      >
        <button
          part="trigger"
          slot="trigger"
          class=${e$4({
            "color-dropdown__trigger": true,
            "color-dropdown__trigger--disabled": this.disabled,
            "color-dropdown__trigger--small": this.size === "small",
            "color-dropdown__trigger--medium": this.size === "medium",
            "color-dropdown__trigger--large": this.size === "large",
            "color-dropdown__trigger--empty": this.isEmpty,
            "color-dropdown__trigger--focused": this.hasFocus,
            "color-picker__transparent-bg": true,
          })}
          style=${o$4({
            color: this.getHexString(
              this.hue,
              this.saturation,
              this.brightness,
              this.alpha,
            ),
          })}
          type="button"
        >
          <sl-visually-hidden>
            <slot name="label">${this.label}</slot>
          </sl-visually-hidden>
        </button>
        ${colorPicker}
      </sl-dropdown>
    `;
  }
};
SlColorPicker.styles = [component_styles_default, color_picker_styles_default];
SlColorPicker.dependencies = {
  "sl-button-group": SlButtonGroup,
  "sl-button": SlButton,
  "sl-dropdown": SlDropdown,
  "sl-icon": SlIcon,
  "sl-input": SlInput,
  "sl-visually-hidden": SlVisuallyHidden,
};
__decorateClass([e$8('[part~="base"]')], SlColorPicker.prototype, "base", 2);
__decorateClass([e$8('[part~="input"]')], SlColorPicker.prototype, "input", 2);
__decorateClass(
  [e$8(".color-dropdown")],
  SlColorPicker.prototype,
  "dropdown",
  2,
);
__decorateClass(
  [e$8('[part~="preview"]')],
  SlColorPicker.prototype,
  "previewButton",
  2,
);
__decorateClass(
  [e$8('[part~="trigger"]')],
  SlColorPicker.prototype,
  "trigger",
  2,
);
__decorateClass([r$4()], SlColorPicker.prototype, "hasFocus", 2);
__decorateClass([r$4()], SlColorPicker.prototype, "isDraggingGridHandle", 2);
__decorateClass([r$4()], SlColorPicker.prototype, "isEmpty", 2);
__decorateClass([r$4()], SlColorPicker.prototype, "inputValue", 2);
__decorateClass([r$4()], SlColorPicker.prototype, "hue", 2);
__decorateClass([r$4()], SlColorPicker.prototype, "saturation", 2);
__decorateClass([r$4()], SlColorPicker.prototype, "brightness", 2);
__decorateClass([r$4()], SlColorPicker.prototype, "alpha", 2);
__decorateClass([n$6()], SlColorPicker.prototype, "value", 2);
__decorateClass([defaultValue()], SlColorPicker.prototype, "defaultValue", 2);
__decorateClass([n$6()], SlColorPicker.prototype, "label", 2);
__decorateClass([n$6()], SlColorPicker.prototype, "format", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlColorPicker.prototype,
  "inline",
  2,
);
__decorateClass([n$6({ reflect: true })], SlColorPicker.prototype, "size", 2);
__decorateClass(
  [n$6({ attribute: "no-format-toggle", type: Boolean })],
  SlColorPicker.prototype,
  "noFormatToggle",
  2,
);
__decorateClass([n$6()], SlColorPicker.prototype, "name", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlColorPicker.prototype,
  "disabled",
  2,
);
__decorateClass([n$6({ type: Boolean })], SlColorPicker.prototype, "hoist", 2);
__decorateClass(
  [n$6({ type: Boolean })],
  SlColorPicker.prototype,
  "opacity",
  2,
);
__decorateClass(
  [n$6({ type: Boolean })],
  SlColorPicker.prototype,
  "uppercase",
  2,
);
__decorateClass([n$6()], SlColorPicker.prototype, "swatches", 2);
__decorateClass([n$6({ reflect: true })], SlColorPicker.prototype, "form", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlColorPicker.prototype,
  "required",
  2,
);
__decorateClass(
  [t$3({ passive: false })],
  SlColorPicker.prototype,
  "handleTouchMove",
  1,
);
__decorateClass(
  [watch("format", { waitUntilFirstUpdate: true })],
  SlColorPicker.prototype,
  "handleFormatChange",
  1,
);
__decorateClass(
  [watch("opacity", { waitUntilFirstUpdate: true })],
  SlColorPicker.prototype,
  "handleOpacityChange",
  1,
);
__decorateClass(
  [watch("value")],
  SlColorPicker.prototype,
  "handleValueChange",
  1,
);
var tagName$d = "sl-color-picker";
SlColorPicker.define("sl-color-picker");
o$8({
  tagName: tagName$d,
  elementClass: SlColorPicker,
  react: React,
  events: {
    onSlBlur: "sl-blur",
    onSlChange: "sl-change",
    onSlFocus: "sl-focus",
    onSlInput: "sl-input",
    onSlInvalid: "sl-invalid",
  },
  displayName: "SlColorPicker",
});
var tagName$c = "sl-checkbox";
SlCheckbox.define("sl-checkbox");
var reactWrapper$5 = o$8({
  tagName: tagName$c,
  elementClass: SlCheckbox,
  react: React,
  events: {
    onSlBlur: "sl-blur",
    onSlChange: "sl-change",
    onSlFocus: "sl-focus",
    onSlInput: "sl-input",
    onSlInvalid: "sl-invalid",
  },
  displayName: "SlCheckbox",
});
var checkbox_default = reactWrapper$5;
var copy_button_styles_default = i$8`
  :host {
    --error-color: var(--sl-color-danger-600);
    --success-color: var(--sl-color-success-600);

    display: inline-block;
  }

  .copy-button__button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
  }

  .copy-button--success .copy-button__button {
    color: var(--success-color);
  }

  .copy-button--error .copy-button__button {
    color: var(--error-color);
  }

  .copy-button__button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .copy-button__button[disabled] {
    opacity: 0.5;
    cursor: not-allowed !important;
  }

  slot {
    display: inline-flex;
  }
`;
var SlCopyButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.isCopying = false;
    this.status = "rest";
    this.value = "";
    this.from = "";
    this.disabled = false;
    this.copyLabel = "";
    this.successLabel = "";
    this.errorLabel = "";
    this.feedbackDuration = 1e3;
    this.tooltipPlacement = "top";
    this.hoist = false;
  }
  async handleCopy() {
    if (this.disabled || this.isCopying) {
      return;
    }
    this.isCopying = true;
    let valueToCopy = this.value;
    if (this.from) {
      const root = this.getRootNode();
      const isProperty = this.from.includes(".");
      const isAttribute = this.from.includes("[") && this.from.includes("]");
      let id2 = this.from;
      let field = "";
      if (isProperty) {
        [id2, field] = this.from.trim().split(".");
      } else if (isAttribute) {
        [id2, field] = this.from.trim().replace(/\]$/, "").split("[");
      }
      const target = "getElementById" in root ? root.getElementById(id2) : null;
      if (target) {
        if (isAttribute) {
          valueToCopy = target.getAttribute(field) || "";
        } else if (isProperty) {
          valueToCopy = target[field] || "";
        } else {
          valueToCopy = target.textContent || "";
        }
      } else {
        this.showStatus("error");
        this.emit("sl-error");
      }
    }
    if (!valueToCopy) {
      this.showStatus("error");
      this.emit("sl-error");
    } else {
      try {
        await navigator.clipboard.writeText(valueToCopy);
        this.showStatus("success");
        this.emit("sl-copy", {
          detail: {
            value: valueToCopy,
          },
        });
      } catch (error) {
        this.showStatus("error");
        this.emit("sl-error");
      }
    }
  }
  async showStatus(status) {
    const copyLabel = this.copyLabel || this.localize.term("copy");
    const successLabel = this.successLabel || this.localize.term("copied");
    const errorLabel = this.errorLabel || this.localize.term("error");
    const iconToShow = status === "success" ? this.successIcon : this.errorIcon;
    const showAnimation = getAnimation(this, "copy.in", { dir: "ltr" });
    const hideAnimation = getAnimation(this, "copy.out", { dir: "ltr" });
    this.tooltip.content = status === "success" ? successLabel : errorLabel;
    await this.copyIcon.animate(hideAnimation.keyframes, hideAnimation.options)
      .finished;
    this.copyIcon.hidden = true;
    this.status = status;
    iconToShow.hidden = false;
    await iconToShow.animate(showAnimation.keyframes, showAnimation.options)
      .finished;
    setTimeout(async () => {
      await iconToShow.animate(hideAnimation.keyframes, hideAnimation.options)
        .finished;
      iconToShow.hidden = true;
      this.status = "rest";
      this.copyIcon.hidden = false;
      await this.copyIcon.animate(
        showAnimation.keyframes,
        showAnimation.options,
      ).finished;
      this.tooltip.content = copyLabel;
      this.isCopying = false;
    }, this.feedbackDuration);
  }
  render() {
    const copyLabel = this.copyLabel || this.localize.term("copy");
    return x$2`
      <sl-tooltip
        class=${e$4({
          "copy-button": true,
          "copy-button--success": this.status === "success",
          "copy-button--error": this.status === "error",
        })}
        content=${copyLabel}
        placement=${this.tooltipPlacement}
        ?disabled=${this.disabled}
        ?hoist=${this.hoist}
        exportparts="
          base:tooltip__base,
          base__popup:tooltip__base__popup,
          base__arrow:tooltip__base__arrow,
          body:tooltip__body
        "
      >
        <button
          class="copy-button__button"
          part="button"
          type="button"
          ?disabled=${this.disabled}
          @click=${this.handleCopy}
        >
          <slot part="copy-icon" name="copy-icon">
            <sl-icon library="system" name="copy"></sl-icon>
          </slot>
          <slot part="success-icon" name="success-icon" hidden>
            <sl-icon library="system" name="check"></sl-icon>
          </slot>
          <slot part="error-icon" name="error-icon" hidden>
            <sl-icon library="system" name="x-lg"></sl-icon>
          </slot>
        </button>
      </sl-tooltip>
    `;
  }
};
SlCopyButton.styles = [component_styles_default, copy_button_styles_default];
SlCopyButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-tooltip": SlTooltip,
};
__decorateClass(
  [e$8('slot[name="copy-icon"]')],
  SlCopyButton.prototype,
  "copyIcon",
  2,
);
__decorateClass(
  [e$8('slot[name="success-icon"]')],
  SlCopyButton.prototype,
  "successIcon",
  2,
);
__decorateClass(
  [e$8('slot[name="error-icon"]')],
  SlCopyButton.prototype,
  "errorIcon",
  2,
);
__decorateClass([e$8("sl-tooltip")], SlCopyButton.prototype, "tooltip", 2);
__decorateClass([r$4()], SlCopyButton.prototype, "isCopying", 2);
__decorateClass([r$4()], SlCopyButton.prototype, "status", 2);
__decorateClass([n$6()], SlCopyButton.prototype, "value", 2);
__decorateClass([n$6()], SlCopyButton.prototype, "from", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlCopyButton.prototype,
  "disabled",
  2,
);
__decorateClass(
  [n$6({ attribute: "copy-label" })],
  SlCopyButton.prototype,
  "copyLabel",
  2,
);
__decorateClass(
  [n$6({ attribute: "success-label" })],
  SlCopyButton.prototype,
  "successLabel",
  2,
);
__decorateClass(
  [n$6({ attribute: "error-label" })],
  SlCopyButton.prototype,
  "errorLabel",
  2,
);
__decorateClass(
  [n$6({ attribute: "feedback-duration", type: Number })],
  SlCopyButton.prototype,
  "feedbackDuration",
  2,
);
__decorateClass(
  [n$6({ attribute: "tooltip-placement" })],
  SlCopyButton.prototype,
  "tooltipPlacement",
  2,
);
__decorateClass([n$6({ type: Boolean })], SlCopyButton.prototype, "hoist", 2);
setDefaultAnimation("copy.in", {
  keyframes: [
    { scale: ".25", opacity: ".25" },
    { scale: "1", opacity: "1" },
  ],
  options: { duration: 100 },
});
setDefaultAnimation("copy.out", {
  keyframes: [
    { scale: "1", opacity: "1" },
    { scale: ".25", opacity: "0" },
  ],
  options: { duration: 100 },
});
var tagName$b = "sl-copy-button";
SlCopyButton.define("sl-copy-button");
var reactWrapper$4 = o$8({
  tagName: tagName$b,
  elementClass: SlCopyButton,
  react: React,
  events: {
    onSlCopy: "sl-copy",
    onSlError: "sl-error",
  },
  displayName: "SlCopyButton",
});
var copy_button_default = reactWrapper$4;
var dialog_styles_default = i$8`
  :host {
    --width: 31rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .dialog {
    display: flex;
    align-items: center;
    justify-content: center;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: var(--sl-z-index-dialog);
  }

  .dialog__panel {
    display: flex;
    flex-direction: column;
    z-index: 2;
    width: var(--width);
    max-width: calc(100% - var(--sl-spacing-2x-large));
    max-height: calc(100% - var(--sl-spacing-2x-large));
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    box-shadow: var(--sl-shadow-x-large);
  }

  .dialog__panel:focus {
    outline: none;
  }

  /* Ensure there's enough vertical padding for phones that don't update vh when chrome appears (e.g. iPhone) */
  @media screen and (max-width: 420px) {
    .dialog__panel {
      max-height: 80vh;
    }
  }

  .dialog--open .dialog__panel {
    display: flex;
    opacity: 1;
  }

  .dialog__header {
    flex: 0 0 auto;
    display: flex;
  }

  .dialog__title {
    flex: 1 1 auto;
    font: inherit;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
    margin: 0;
  }

  .dialog__header-actions {
    flex-shrink: 0;
    display: flex;
    flex-wrap: wrap;
    justify-content: end;
    gap: var(--sl-spacing-2x-small);
    padding: 0 var(--header-spacing);
  }

  .dialog__header-actions sl-icon-button,
  .dialog__header-actions ::slotted(sl-icon-button) {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
  }

  .dialog__body {
    flex: 1 1 auto;
    display: block;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .dialog__footer {
    flex: 0 0 auto;
    text-align: right;
    padding: var(--footer-spacing);
  }

  .dialog__footer ::slotted(sl-button:not(:first-of-type)) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  .dialog:not(.dialog--has-footer) .dialog__footer {
    display: none;
  }

  .dialog__overlay {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
  }

  @media (forced-colors: active) {
    .dialog__panel {
      border: solid 1px var(--sl-color-neutral-0);
    }
  }
`;
var SlDialog = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "footer");
    this.localize = new LocalizeController2(this);
    this.modal = new Modal(this);
    this.open = false;
    this.label = "";
    this.noHeader = false;
    this.handleDocumentKeyDown = (event) => {
      if (event.key === "Escape" && this.modal.isActive() && this.open) {
        event.stopPropagation();
        this.requestClose("keyboard");
      }
    };
  }
  firstUpdated() {
    this.dialog.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      this.modal.activate();
      lockBodyScrolling(this);
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.modal.deactivate();
    unlockBodyScrolling(this);
    this.removeOpenListeners();
  }
  requestClose(source) {
    const slRequestClose = this.emit("sl-request-close", {
      cancelable: true,
      detail: { source },
    });
    if (slRequestClose.defaultPrevented) {
      const animation = getAnimation(this, "dialog.denyClose", {
        dir: this.localize.dir(),
      });
      animateTo(this.panel, animation.keyframes, animation.options);
      return;
    }
    this.hide();
  }
  addOpenListeners() {
    var _a2;
    if ("CloseWatcher" in window) {
      (_a2 = this.closeWatcher) == null ? void 0 : _a2.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => this.requestClose("keyboard");
    } else {
      document.addEventListener("keydown", this.handleDocumentKeyDown);
    }
  }
  removeOpenListeners() {
    var _a2;
    (_a2 = this.closeWatcher) == null ? void 0 : _a2.destroy();
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      this.originalTrigger = document.activeElement;
      this.modal.activate();
      lockBodyScrolling(this);
      const autoFocusTarget = this.querySelector("[autofocus]");
      if (autoFocusTarget) {
        autoFocusTarget.removeAttribute("autofocus");
      }
      await Promise.all([
        stopAnimations(this.dialog),
        stopAnimations(this.overlay),
      ]);
      this.dialog.hidden = false;
      requestAnimationFrame(() => {
        const slInitialFocus = this.emit("sl-initial-focus", {
          cancelable: true,
        });
        if (!slInitialFocus.defaultPrevented) {
          if (autoFocusTarget) {
            autoFocusTarget.focus({ preventScroll: true });
          } else {
            this.panel.focus({ preventScroll: true });
          }
        }
        if (autoFocusTarget) {
          autoFocusTarget.setAttribute("autofocus", "");
        }
      });
      const panelAnimation = getAnimation(this, "dialog.show", {
        dir: this.localize.dir(),
      });
      const overlayAnimation = getAnimation(this, "dialog.overlay.show", {
        dir: this.localize.dir(),
      });
      await Promise.all([
        animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options),
        animateTo(
          this.overlay,
          overlayAnimation.keyframes,
          overlayAnimation.options,
        ),
      ]);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      this.modal.deactivate();
      await Promise.all([
        stopAnimations(this.dialog),
        stopAnimations(this.overlay),
      ]);
      const panelAnimation = getAnimation(this, "dialog.hide", {
        dir: this.localize.dir(),
      });
      const overlayAnimation = getAnimation(this, "dialog.overlay.hide", {
        dir: this.localize.dir(),
      });
      await Promise.all([
        animateTo(
          this.overlay,
          overlayAnimation.keyframes,
          overlayAnimation.options,
        ).then(() => {
          this.overlay.hidden = true;
        }),
        animateTo(
          this.panel,
          panelAnimation.keyframes,
          panelAnimation.options,
        ).then(() => {
          this.panel.hidden = true;
        }),
      ]);
      this.dialog.hidden = true;
      this.overlay.hidden = false;
      this.panel.hidden = false;
      unlockBodyScrolling(this);
      const trigger = this.originalTrigger;
      if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
        setTimeout(() => trigger.focus());
      }
      this.emit("sl-after-hide");
    }
  }
  /** Shows the dialog. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the dialog */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  render() {
    return x$2`
      <div
        part="base"
        class=${e$4({
          dialog: true,
          "dialog--open": this.open,
          "dialog--has-footer": this.hasSlotController.test("footer"),
        })}
      >
        <div part="overlay" class="dialog__overlay" @click=${() => this.requestClose("overlay")} tabindex="-1"></div>

        <div
          part="panel"
          class="dialog__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${o$7(this.noHeader ? this.label : void 0)}
          aria-labelledby=${o$7(!this.noHeader ? "title" : void 0)}
          tabindex="-1"
        >
          ${
            !this.noHeader
              ? x$2`
                <header part="header" class="dialog__header">
                  <h2 part="title" class="dialog__title" id="title">
                    <slot name="label"> ${this.label.length > 0 ? this.label : String.fromCharCode(65279)} </slot>
                  </h2>
                  <div part="header-actions" class="dialog__header-actions">
                    <slot name="header-actions"></slot>
                    <sl-icon-button
                      part="close-button"
                      exportparts="base:close-button__base"
                      class="dialog__close"
                      name="x-lg"
                      label=${this.localize.term("close")}
                      library="system"
                      @click="${() => this.requestClose("close-button")}"
                    ></sl-icon-button>
                  </div>
                </header>
              `
              : ""
          }
          ${""}
          <div part="body" class="dialog__body" tabindex="-1"><slot></slot></div>

          <footer part="footer" class="dialog__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
  }
};
SlDialog.styles = [component_styles_default, dialog_styles_default];
SlDialog.dependencies = {
  "sl-icon-button": SlIconButton,
};
__decorateClass([e$8(".dialog")], SlDialog.prototype, "dialog", 2);
__decorateClass([e$8(".dialog__panel")], SlDialog.prototype, "panel", 2);
__decorateClass([e$8(".dialog__overlay")], SlDialog.prototype, "overlay", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlDialog.prototype,
  "open",
  2,
);
__decorateClass([n$6({ reflect: true })], SlDialog.prototype, "label", 2);
__decorateClass(
  [n$6({ attribute: "no-header", type: Boolean, reflect: true })],
  SlDialog.prototype,
  "noHeader",
  2,
);
__decorateClass(
  [watch("open", { waitUntilFirstUpdate: true })],
  SlDialog.prototype,
  "handleOpenChange",
  1,
);
setDefaultAnimation("dialog.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 },
  ],
  options: { duration: 250, easing: "ease" },
});
setDefaultAnimation("dialog.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 },
  ],
  options: { duration: 250, easing: "ease" },
});
setDefaultAnimation("dialog.denyClose", {
  keyframes: [{ scale: 1 }, { scale: 1.02 }, { scale: 1 }],
  options: { duration: 250 },
});
setDefaultAnimation("dialog.overlay.show", {
  keyframes: [{ opacity: 0 }, { opacity: 1 }],
  options: { duration: 250 },
});
setDefaultAnimation("dialog.overlay.hide", {
  keyframes: [{ opacity: 1 }, { opacity: 0 }],
  options: { duration: 250 },
});
var tagName$a = "sl-dialog";
SlDialog.define("sl-dialog");
var reactWrapper$3 = o$8({
  tagName: tagName$a,
  elementClass: SlDialog,
  react: React,
  events: {
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide",
    onSlInitialFocus: "sl-initial-focus",
    onSlRequestClose: "sl-request-close",
  },
  displayName: "SlDialog",
});
var dialog_default = reactWrapper$3;
var details_styles_default = i$8`
  :host {
    display: block;
  }

  .details {
    border: solid 1px var(--sl-color-neutral-200);
    border-radius: var(--sl-border-radius-medium);
    background-color: var(--sl-color-neutral-0);
    overflow-anchor: none;
  }

  .details--disabled {
    opacity: 0.5;
  }

  .details__header {
    display: flex;
    align-items: center;
    border-radius: inherit;
    padding: var(--sl-spacing-medium);
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
  }

  .details__header::-webkit-details-marker {
    display: none;
  }

  .details__header:focus {
    outline: none;
  }

  .details__header:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: calc(1px + var(--sl-focus-ring-offset));
  }

  .details--disabled .details__header {
    cursor: not-allowed;
  }

  .details--disabled .details__header:focus-visible {
    outline: none;
    box-shadow: none;
  }

  .details__summary {
    flex: 1 1 auto;
    display: flex;
    align-items: center;
  }

  .details__summary-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
  }

  .details--open .details__summary-icon {
    rotate: 90deg;
  }

  .details--open.details--rtl .details__summary-icon {
    rotate: -90deg;
  }

  .details--open slot[name='expand-icon'],
  .details:not(.details--open) slot[name='collapse-icon'] {
    display: none;
  }

  .details__body {
    overflow: hidden;
  }

  .details__content {
    display: block;
    padding: var(--sl-spacing-medium);
  }
`;
var SlDetails = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.open = false;
    this.disabled = false;
  }
  firstUpdated() {
    this.body.style.height = this.open ? "auto" : "0";
    if (this.open) {
      this.details.open = true;
    }
    this.detailsObserver = new MutationObserver((changes) => {
      for (const change of changes) {
        if (change.type === "attributes" && change.attributeName === "open") {
          if (this.details.open) {
            this.show();
          } else {
            this.hide();
          }
        }
      }
    });
    this.detailsObserver.observe(this.details, { attributes: true });
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback();
    (_a2 = this.detailsObserver) == null ? void 0 : _a2.disconnect();
  }
  handleSummaryClick(event) {
    event.preventDefault();
    if (!this.disabled) {
      if (this.open) {
        this.hide();
      } else {
        this.show();
      }
      this.header.focus();
    }
  }
  handleSummaryKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      if (this.open) {
        this.hide();
      } else {
        this.show();
      }
    }
    if (event.key === "ArrowUp" || event.key === "ArrowLeft") {
      event.preventDefault();
      this.hide();
    }
    if (event.key === "ArrowDown" || event.key === "ArrowRight") {
      event.preventDefault();
      this.show();
    }
  }
  async handleOpenChange() {
    if (this.open) {
      this.details.open = true;
      const slShow = this.emit("sl-show", { cancelable: true });
      if (slShow.defaultPrevented) {
        this.open = false;
        this.details.open = false;
        return;
      }
      await stopAnimations(this.body);
      const { keyframes, options } = getAnimation(this, "details.show", {
        dir: this.localize.dir(),
      });
      await animateTo(
        this.body,
        shimKeyframesHeightAuto(keyframes, this.body.scrollHeight),
        options,
      );
      this.body.style.height = "auto";
      this.emit("sl-after-show");
    } else {
      const slHide = this.emit("sl-hide", { cancelable: true });
      if (slHide.defaultPrevented) {
        this.details.open = true;
        this.open = true;
        return;
      }
      await stopAnimations(this.body);
      const { keyframes, options } = getAnimation(this, "details.hide", {
        dir: this.localize.dir(),
      });
      await animateTo(
        this.body,
        shimKeyframesHeightAuto(keyframes, this.body.scrollHeight),
        options,
      );
      this.body.style.height = "auto";
      this.details.open = false;
      this.emit("sl-after-hide");
    }
  }
  /** Shows the details. */
  async show() {
    if (this.open || this.disabled) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the details */
  async hide() {
    if (!this.open || this.disabled) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    return x$2`
      <details
        part="base"
        class=${e$4({
          details: true,
          "details--open": this.open,
          "details--disabled": this.disabled,
          "details--rtl": isRtl,
        })}
      >
        <summary
          part="header"
          id="header"
          class="details__header"
          role="button"
          aria-expanded=${this.open ? "true" : "false"}
          aria-controls="content"
          aria-disabled=${this.disabled ? "true" : "false"}
          tabindex=${this.disabled ? "-1" : "0"}
          @click=${this.handleSummaryClick}
          @keydown=${this.handleSummaryKeyDown}
        >
          <slot name="summary" part="summary" class="details__summary">${this.summary}</slot>

          <span part="summary-icon" class="details__summary-icon">
            <slot name="expand-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
            <slot name="collapse-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
          </span>
        </summary>

        <div class="details__body" role="region" aria-labelledby="header">
          <slot part="content" id="content" class="details__content"></slot>
        </div>
      </details>
    `;
  }
};
SlDetails.styles = [component_styles_default, details_styles_default];
SlDetails.dependencies = {
  "sl-icon": SlIcon,
};
__decorateClass([e$8(".details")], SlDetails.prototype, "details", 2);
__decorateClass([e$8(".details__header")], SlDetails.prototype, "header", 2);
__decorateClass([e$8(".details__body")], SlDetails.prototype, "body", 2);
__decorateClass(
  [e$8(".details__expand-icon-slot")],
  SlDetails.prototype,
  "expandIconSlot",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlDetails.prototype,
  "open",
  2,
);
__decorateClass([n$6()], SlDetails.prototype, "summary", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlDetails.prototype,
  "disabled",
  2,
);
__decorateClass(
  [watch("open", { waitUntilFirstUpdate: true })],
  SlDetails.prototype,
  "handleOpenChange",
  1,
);
setDefaultAnimation("details.show", {
  keyframes: [
    { height: "0", opacity: "0" },
    { height: "auto", opacity: "1" },
  ],
  options: { duration: 250, easing: "linear" },
});
setDefaultAnimation("details.hide", {
  keyframes: [
    { height: "auto", opacity: "1" },
    { height: "0", opacity: "0" },
  ],
  options: { duration: 250, easing: "linear" },
});
var tagName$9 = "sl-details";
SlDetails.define("sl-details");
o$8({
  tagName: tagName$9,
  elementClass: SlDetails,
  react: React,
  events: {
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide",
  },
  displayName: "SlDetails",
});
var animated_image_styles_default = i$8`
  :host {
    --control-box-size: 3rem;
    --icon-size: calc(var(--control-box-size) * 0.625);

    display: inline-flex;
    position: relative;
    cursor: pointer;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
  }

  img[aria-hidden='true'] {
    display: none;
  }

  .animated-image__control-box {
    display: flex;
    position: absolute;
    align-items: center;
    justify-content: center;
    top: calc(50% - var(--control-box-size) / 2);
    right: calc(50% - var(--control-box-size) / 2);
    width: var(--control-box-size);
    height: var(--control-box-size);
    font-size: var(--icon-size);
    background: none;
    border: solid 2px currentColor;
    background-color: rgb(0 0 0 /50%);
    border-radius: var(--sl-border-radius-circle);
    color: white;
    pointer-events: none;
    transition: var(--sl-transition-fast) opacity;
  }

  :host([play]:hover) .animated-image__control-box {
    opacity: 1;
  }

  :host([play]:not(:hover)) .animated-image__control-box {
    opacity: 0;
  }

  :host([play]) slot[name='play-icon'],
  :host(:not([play])) slot[name='pause-icon'] {
    display: none;
  }
`;
var SlAnimatedImage = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.isLoaded = false;
  }
  handleClick() {
    this.play = !this.play;
  }
  handleLoad() {
    const canvas = document.createElement("canvas");
    const { width, height } = this.animatedImage;
    canvas.width = width;
    canvas.height = height;
    canvas.getContext("2d").drawImage(this.animatedImage, 0, 0, width, height);
    this.frozenFrame = canvas.toDataURL("image/gif");
    if (!this.isLoaded) {
      this.emit("sl-load");
      this.isLoaded = true;
    }
  }
  handleError() {
    this.emit("sl-error");
  }
  handlePlayChange() {
    if (this.play) {
      this.animatedImage.src = "";
      this.animatedImage.src = this.src;
    }
  }
  handleSrcChange() {
    this.isLoaded = false;
  }
  render() {
    return x$2`
      <div class="animated-image">
        <img
          class="animated-image__animated"
          src=${this.src}
          alt=${this.alt}
          crossorigin="anonymous"
          aria-hidden=${this.play ? "false" : "true"}
          @click=${this.handleClick}
          @load=${this.handleLoad}
          @error=${this.handleError}
        />

        ${
          this.isLoaded
            ? x$2`
              <img
                class="animated-image__frozen"
                src=${this.frozenFrame}
                alt=${this.alt}
                aria-hidden=${this.play ? "true" : "false"}
                @click=${this.handleClick}
              />

              <div part="control-box" class="animated-image__control-box">
                <slot name="play-icon"><sl-icon name="play-fill" library="system"></sl-icon></slot>
                <slot name="pause-icon"><sl-icon name="pause-fill" library="system"></sl-icon></slot>
              </div>
            `
            : ""
        }
      </div>
    `;
  }
};
SlAnimatedImage.styles = [
  component_styles_default,
  animated_image_styles_default,
];
SlAnimatedImage.dependencies = { "sl-icon": SlIcon };
__decorateClass(
  [e$8(".animated-image__animated")],
  SlAnimatedImage.prototype,
  "animatedImage",
  2,
);
__decorateClass([r$4()], SlAnimatedImage.prototype, "frozenFrame", 2);
__decorateClass([r$4()], SlAnimatedImage.prototype, "isLoaded", 2);
__decorateClass([n$6()], SlAnimatedImage.prototype, "src", 2);
__decorateClass([n$6()], SlAnimatedImage.prototype, "alt", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlAnimatedImage.prototype,
  "play",
  2,
);
__decorateClass(
  [watch("play", { waitUntilFirstUpdate: true })],
  SlAnimatedImage.prototype,
  "handlePlayChange",
  1,
);
__decorateClass(
  [watch("src")],
  SlAnimatedImage.prototype,
  "handleSrcChange",
  1,
);
var tagName$8 = "sl-animated-image";
SlAnimatedImage.define("sl-animated-image");
o$8({
  tagName: tagName$8,
  elementClass: SlAnimatedImage,
  react: React,
  events: {
    onSlLoad: "sl-load",
    onSlError: "sl-error",
  },
  displayName: "SlAnimatedImage",
});
var animation_styles_default = i$8`
  :host {
    display: contents;
  }
`;
const bounce = [
  {
    offset: 0,
    easing: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    transform: "translate3d(0, 0, 0)",
  },
  {
    offset: 0.2,
    easing: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    transform: "translate3d(0, 0, 0)",
  },
  {
    offset: 0.4,
    easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    transform: "translate3d(0, -30px, 0) scaleY(1.1)",
  },
  {
    offset: 0.43,
    easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    transform: "translate3d(0, -30px, 0) scaleY(1.1)",
  },
  {
    offset: 0.53,
    easing: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    transform: "translate3d(0, 0, 0)",
  },
  {
    offset: 0.7,
    easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    transform: "translate3d(0, -15px, 0) scaleY(1.05)",
  },
  {
    offset: 0.8,
    "transition-timing-function": "cubic-bezier(0.215, 0.61, 0.355, 1)",
    transform: "translate3d(0, 0, 0) scaleY(0.95)",
  },
  { offset: 0.9, transform: "translate3d(0, -4px, 0) scaleY(1.02)" },
  {
    offset: 1,
    easing: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    transform: "translate3d(0, 0, 0)",
  },
];
const flash = [
  { offset: 0, opacity: "1" },
  { offset: 0.25, opacity: "0" },
  { offset: 0.5, opacity: "1" },
  { offset: 0.75, opacity: "0" },
  { offset: 1, opacity: "1" },
];
const headShake = [
  { offset: 0, transform: "translateX(0)" },
  { offset: 0.065, transform: "translateX(-6px) rotateY(-9deg)" },
  { offset: 0.185, transform: "translateX(5px) rotateY(7deg)" },
  { offset: 0.315, transform: "translateX(-3px) rotateY(-5deg)" },
  { offset: 0.435, transform: "translateX(2px) rotateY(3deg)" },
  { offset: 0.5, transform: "translateX(0)" },
];
const heartBeat = [
  { offset: 0, transform: "scale(1)" },
  { offset: 0.14, transform: "scale(1.3)" },
  { offset: 0.28, transform: "scale(1)" },
  { offset: 0.42, transform: "scale(1.3)" },
  { offset: 0.7, transform: "scale(1)" },
];
const jello = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.111, transform: "translate3d(0, 0, 0)" },
  { offset: 0.222, transform: "skewX(-12.5deg) skewY(-12.5deg)" },
  { offset: 0.33299999999999996, transform: "skewX(6.25deg) skewY(6.25deg)" },
  { offset: 0.444, transform: "skewX(-3.125deg) skewY(-3.125deg)" },
  { offset: 0.555, transform: "skewX(1.5625deg) skewY(1.5625deg)" },
  {
    offset: 0.6659999999999999,
    transform: "skewX(-0.78125deg) skewY(-0.78125deg)",
  },
  { offset: 0.777, transform: "skewX(0.390625deg) skewY(0.390625deg)" },
  { offset: 0.888, transform: "skewX(-0.1953125deg) skewY(-0.1953125deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
];
const pulse = [
  { offset: 0, transform: "scale3d(1, 1, 1)" },
  { offset: 0.5, transform: "scale3d(1.05, 1.05, 1.05)" },
  { offset: 1, transform: "scale3d(1, 1, 1)" },
];
const rubberBand = [
  { offset: 0, transform: "scale3d(1, 1, 1)" },
  { offset: 0.3, transform: "scale3d(1.25, 0.75, 1)" },
  { offset: 0.4, transform: "scale3d(0.75, 1.25, 1)" },
  { offset: 0.5, transform: "scale3d(1.15, 0.85, 1)" },
  { offset: 0.65, transform: "scale3d(0.95, 1.05, 1)" },
  { offset: 0.75, transform: "scale3d(1.05, 0.95, 1)" },
  { offset: 1, transform: "scale3d(1, 1, 1)" },
];
const shake = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.1, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.2, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.3, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.4, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.5, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.6, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.7, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.8, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.9, transform: "translate3d(-10px, 0, 0)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
];
const shakeX = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.1, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.2, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.3, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.4, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.5, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.6, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.7, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.8, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.9, transform: "translate3d(-10px, 0, 0)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
];
const shakeY = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.1, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.2, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.3, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.4, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.5, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.6, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.7, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.8, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.9, transform: "translate3d(0, -10px, 0)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
];
const swing = [
  { offset: 0.2, transform: "rotate3d(0, 0, 1, 15deg)" },
  { offset: 0.4, transform: "rotate3d(0, 0, 1, -10deg)" },
  { offset: 0.6, transform: "rotate3d(0, 0, 1, 5deg)" },
  { offset: 0.8, transform: "rotate3d(0, 0, 1, -5deg)" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 0deg)" },
];
const tada = [
  { offset: 0, transform: "scale3d(1, 1, 1)" },
  { offset: 0.1, transform: "scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.2, transform: "scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.3, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.4, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.5, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.6, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.7, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.8, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.9, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 1, transform: "scale3d(1, 1, 1)" },
];
const wobble = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  {
    offset: 0.15,
    transform: "translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg)",
  },
  { offset: 0.3, transform: "translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg)" },
  {
    offset: 0.45,
    transform: "translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg)",
  },
  { offset: 0.6, transform: "translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg)" },
  {
    offset: 0.75,
    transform: "translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg)",
  },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
];
const backInDown = [
  { offset: 0, transform: "translateY(-1200px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" },
];
const backInLeft = [
  { offset: 0, transform: "translateX(-2000px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" },
];
const backInRight = [
  { offset: 0, transform: "translateX(2000px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" },
];
const backInUp = [
  { offset: 0, transform: "translateY(1200px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" },
];
const backOutDown = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateY(700px) scale(0.7)", opacity: "0.7" },
];
const backOutLeft = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateX(-2000px) scale(0.7)", opacity: "0.7" },
];
const backOutRight = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateX(2000px) scale(0.7)", opacity: "0.7" },
];
const backOutUp = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateY(-700px) scale(0.7)", opacity: "0.7" },
];
const bounceIn = [
  { offset: 0, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.2, transform: "scale3d(1.1, 1.1, 1.1)" },
  { offset: 0.2, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.4, transform: "scale3d(0.9, 0.9, 0.9)" },
  { offset: 0.4, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "scale3d(1.03, 1.03, 1.03)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.8, transform: "scale3d(0.97, 0.97, 0.97)" },
  { offset: 0.8, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, opacity: "1", transform: "scale3d(1, 1, 1)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
];
const bounceInDown = [
  {
    offset: 0,
    opacity: "0",
    transform: "translate3d(0, -3000px, 0) scaleY(3)",
  },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  {
    offset: 0.6,
    opacity: "1",
    transform: "translate3d(0, 25px, 0) scaleY(0.9)",
  },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(0, -10px, 0) scaleY(0.95)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(0, 5px, 0) scaleY(0.985)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
];
const bounceInLeft = [
  {
    offset: 0,
    opacity: "0",
    transform: "translate3d(-3000px, 0, 0) scaleX(3)",
  },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "translate3d(25px, 0, 0) scaleX(1)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(-10px, 0, 0) scaleX(0.98)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(5px, 0, 0) scaleX(0.995)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
];
const bounceInRight = [
  { offset: 0, opacity: "0", transform: "translate3d(3000px, 0, 0) scaleX(3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  {
    offset: 0.6,
    opacity: "1",
    transform: "translate3d(-25px, 0, 0) scaleX(1)",
  },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(10px, 0, 0) scaleX(0.98)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(-5px, 0, 0) scaleX(0.995)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
];
const bounceInUp = [
  { offset: 0, opacity: "0", transform: "translate3d(0, 3000px, 0) scaleY(5)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  {
    offset: 0.6,
    opacity: "1",
    transform: "translate3d(0, -20px, 0) scaleY(0.9)",
  },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(0, 10px, 0) scaleY(0.95)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(0, -5px, 0) scaleY(0.985)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
];
const bounceOut = [
  { offset: 0.2, transform: "scale3d(0.9, 0.9, 0.9)" },
  { offset: 0.5, opacity: "1", transform: "scale3d(1.1, 1.1, 1.1)" },
  { offset: 0.55, opacity: "1", transform: "scale3d(1.1, 1.1, 1.1)" },
  { offset: 1, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" },
];
const bounceOutDown = [
  { offset: 0.2, transform: "translate3d(0, 10px, 0) scaleY(0.985)" },
  {
    offset: 0.4,
    opacity: "1",
    transform: "translate3d(0, -20px, 0) scaleY(0.9)",
  },
  {
    offset: 0.45,
    opacity: "1",
    transform: "translate3d(0, -20px, 0) scaleY(0.9)",
  },
  { offset: 1, opacity: "0", transform: "translate3d(0, 2000px, 0) scaleY(3)" },
];
const bounceOutLeft = [
  {
    offset: 0.2,
    opacity: "1",
    transform: "translate3d(20px, 0, 0) scaleX(0.9)",
  },
  {
    offset: 1,
    opacity: "0",
    transform: "translate3d(-2000px, 0, 0) scaleX(2)",
  },
];
const bounceOutRight = [
  {
    offset: 0.2,
    opacity: "1",
    transform: "translate3d(-20px, 0, 0) scaleX(0.9)",
  },
  { offset: 1, opacity: "0", transform: "translate3d(2000px, 0, 0) scaleX(2)" },
];
const bounceOutUp = [
  { offset: 0.2, transform: "translate3d(0, -10px, 0) scaleY(0.985)" },
  {
    offset: 0.4,
    opacity: "1",
    transform: "translate3d(0, 20px, 0) scaleY(0.9)",
  },
  {
    offset: 0.45,
    opacity: "1",
    transform: "translate3d(0, 20px, 0) scaleY(0.9)",
  },
  {
    offset: 1,
    opacity: "0",
    transform: "translate3d(0, -2000px, 0) scaleY(3)",
  },
];
const fadeIn = [
  { offset: 0, opacity: "0" },
  { offset: 1, opacity: "1" },
];
const fadeInBottomLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, 100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" },
];
const fadeInBottomRight = [
  { offset: 0, opacity: "0", transform: "translate3d(100%, 100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" },
];
const fadeInDown = [
  { offset: 0, opacity: "0", transform: "translate3d(0, -100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" },
];
const fadeInDownBig = [
  { offset: 0, opacity: "0", transform: "translate3d(0, -2000px, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" },
];
const fadeInLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" },
];
const fadeInLeftBig = [
  { offset: 0, opacity: "0", transform: "translate3d(-2000px, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" },
];
const fadeInRight = [
  { offset: 0, opacity: "0", transform: "translate3d(100%, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" },
];
const fadeInRightBig = [
  { offset: 0, opacity: "0", transform: "translate3d(2000px, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" },
];
const fadeInTopLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, -100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" },
];
const fadeInTopRight = [
  { offset: 0, opacity: "0", transform: "translate3d(100%, -100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" },
];
const fadeInUp = [
  { offset: 0, opacity: "0", transform: "translate3d(0, 100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" },
];
const fadeInUpBig = [
  { offset: 0, opacity: "0", transform: "translate3d(0, 2000px, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" },
];
const fadeOut = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0" },
];
const fadeOutBottomLeft = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(-100%, 100%, 0)" },
];
const fadeOutBottomRight = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, 100%, 0)" },
];
const fadeOutDown = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, 100%, 0)" },
];
const fadeOutDownBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, 2000px, 0)" },
];
const fadeOutLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(-100%, 0, 0)" },
];
const fadeOutLeftBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(-2000px, 0, 0)" },
];
const fadeOutRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, 0, 0)" },
];
const fadeOutRightBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(2000px, 0, 0)" },
];
const fadeOutTopLeft = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(-100%, -100%, 0)" },
];
const fadeOutTopRight = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, -100%, 0)" },
];
const fadeOutUp = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, -100%, 0)" },
];
const fadeOutUpBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, -2000px, 0)" },
];
const flip = [
  {
    offset: 0,
    transform:
      "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, -360deg)",
    easing: "ease-out",
  },
  {
    offset: 0.4,
    transform:
      "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)\n      rotate3d(0, 1, 0, -190deg)",
    easing: "ease-out",
  },
  {
    offset: 0.5,
    transform:
      "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)\n      rotate3d(0, 1, 0, -170deg)",
    easing: "ease-in",
  },
  {
    offset: 0.8,
    transform:
      "perspective(400px) scale3d(0.95, 0.95, 0.95) translate3d(0, 0, 0)\n      rotate3d(0, 1, 0, 0deg)",
    easing: "ease-in",
  },
  {
    offset: 1,
    transform:
      "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg)",
    easing: "ease-in",
  },
];
const flipInX = [
  {
    offset: 0,
    transform: "perspective(400px) rotate3d(1, 0, 0, 90deg)",
    easing: "ease-in",
    opacity: "0",
  },
  {
    offset: 0.4,
    transform: "perspective(400px) rotate3d(1, 0, 0, -20deg)",
    easing: "ease-in",
  },
  {
    offset: 0.6,
    transform: "perspective(400px) rotate3d(1, 0, 0, 10deg)",
    opacity: "1",
  },
  { offset: 0.8, transform: "perspective(400px) rotate3d(1, 0, 0, -5deg)" },
  { offset: 1, transform: "perspective(400px)" },
];
const flipInY = [
  {
    offset: 0,
    transform: "perspective(400px) rotate3d(0, 1, 0, 90deg)",
    easing: "ease-in",
    opacity: "0",
  },
  {
    offset: 0.4,
    transform: "perspective(400px) rotate3d(0, 1, 0, -20deg)",
    easing: "ease-in",
  },
  {
    offset: 0.6,
    transform: "perspective(400px) rotate3d(0, 1, 0, 10deg)",
    opacity: "1",
  },
  { offset: 0.8, transform: "perspective(400px) rotate3d(0, 1, 0, -5deg)" },
  { offset: 1, transform: "perspective(400px)" },
];
const flipOutX = [
  { offset: 0, transform: "perspective(400px)" },
  {
    offset: 0.3,
    transform: "perspective(400px) rotate3d(1, 0, 0, -20deg)",
    opacity: "1",
  },
  {
    offset: 1,
    transform: "perspective(400px) rotate3d(1, 0, 0, 90deg)",
    opacity: "0",
  },
];
const flipOutY = [
  { offset: 0, transform: "perspective(400px)" },
  {
    offset: 0.3,
    transform: "perspective(400px) rotate3d(0, 1, 0, -15deg)",
    opacity: "1",
  },
  {
    offset: 1,
    transform: "perspective(400px) rotate3d(0, 1, 0, 90deg)",
    opacity: "0",
  },
];
const lightSpeedInLeft = [
  {
    offset: 0,
    transform: "translate3d(-100%, 0, 0) skewX(30deg)",
    opacity: "0",
  },
  { offset: 0.6, transform: "skewX(-20deg)", opacity: "1" },
  { offset: 0.8, transform: "skewX(5deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
];
const lightSpeedInRight = [
  {
    offset: 0,
    transform: "translate3d(100%, 0, 0) skewX(-30deg)",
    opacity: "0",
  },
  { offset: 0.6, transform: "skewX(20deg)", opacity: "1" },
  { offset: 0.8, transform: "skewX(-5deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
];
const lightSpeedOutLeft = [
  { offset: 0, opacity: "1" },
  {
    offset: 1,
    transform: "translate3d(-100%, 0, 0) skewX(-30deg)",
    opacity: "0",
  },
];
const lightSpeedOutRight = [
  { offset: 0, opacity: "1" },
  {
    offset: 1,
    transform: "translate3d(100%, 0, 0) skewX(30deg)",
    opacity: "0",
  },
];
const rotateIn = [
  { offset: 0, transform: "rotate3d(0, 0, 1, -200deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" },
];
const rotateInDownLeft = [
  { offset: 0, transform: "rotate3d(0, 0, 1, -45deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" },
];
const rotateInDownRight = [
  { offset: 0, transform: "rotate3d(0, 0, 1, 45deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" },
];
const rotateInUpLeft = [
  { offset: 0, transform: "rotate3d(0, 0, 1, 45deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" },
];
const rotateInUpRight = [
  { offset: 0, transform: "rotate3d(0, 0, 1, -90deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" },
];
const rotateOut = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 200deg)", opacity: "0" },
];
const rotateOutDownLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 45deg)", opacity: "0" },
];
const rotateOutDownRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, -45deg)", opacity: "0" },
];
const rotateOutUpLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, -45deg)", opacity: "0" },
];
const rotateOutUpRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 90deg)", opacity: "0" },
];
const slideInDown = [
  { offset: 0, transform: "translate3d(0, -100%, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
];
const slideInLeft = [
  { offset: 0, transform: "translate3d(-100%, 0, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
];
const slideInRight = [
  { offset: 0, transform: "translate3d(100%, 0, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
];
const slideInUp = [
  { offset: 0, transform: "translate3d(0, 100%, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
];
const slideOutDown = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(0, 100%, 0)" },
];
const slideOutLeft = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(-100%, 0, 0)" },
];
const slideOutRight = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(100%, 0, 0)" },
];
const slideOutUp = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(0, -100%, 0)" },
];
const hinge = [
  { offset: 0, easing: "ease-in-out" },
  { offset: 0.2, transform: "rotate3d(0, 0, 1, 80deg)", easing: "ease-in-out" },
  {
    offset: 0.4,
    transform: "rotate3d(0, 0, 1, 60deg)",
    easing: "ease-in-out",
    opacity: "1",
  },
  { offset: 0.6, transform: "rotate3d(0, 0, 1, 80deg)", easing: "ease-in-out" },
  {
    offset: 0.8,
    transform: "rotate3d(0, 0, 1, 60deg)",
    easing: "ease-in-out",
    opacity: "1",
  },
  { offset: 1, transform: "translate3d(0, 700px, 0)", opacity: "0" },
];
const jackInTheBox = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale(0.1) rotate(30deg)",
    "transform-origin": "center bottom",
  },
  { offset: 0.5, transform: "rotate(-10deg)" },
  { offset: 0.7, transform: "rotate(3deg)" },
  { offset: 1, opacity: "1", transform: "scale(1)" },
];
const rollIn = [
  {
    offset: 0,
    opacity: "0",
    transform: "translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg)",
  },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" },
];
const rollOut = [
  { offset: 0, opacity: "1" },
  {
    offset: 1,
    opacity: "0",
    transform: "translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg)",
  },
];
const zoomIn = [
  { offset: 0, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" },
  { offset: 0.5, opacity: "1" },
];
const zoomInDown = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, -1000px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)",
  },
];
const zoomInLeft = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(-1000px, 0, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(10px, 0, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)",
  },
];
const zoomInRight = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(1000px, 0, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(-10px, 0, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)",
  },
];
const zoomInUp = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, 1000px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)",
  },
];
const zoomOut = [
  { offset: 0, opacity: "1" },
  { offset: 0.5, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" },
  { offset: 1, opacity: "0" },
];
const zoomOutDown = [
  {
    offset: 0.4,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
  },
  {
    offset: 1,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, 2000px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)",
  },
];
const zoomOutLeft = [
  {
    offset: 0.4,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(42px, 0, 0)",
  },
  {
    offset: 1,
    opacity: "0",
    transform: "scale(0.1) translate3d(-2000px, 0, 0)",
  },
];
const zoomOutRight = [
  {
    offset: 0.4,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(-42px, 0, 0)",
  },
  {
    offset: 1,
    opacity: "0",
    transform: "scale(0.1) translate3d(2000px, 0, 0)",
  },
];
const zoomOutUp = [
  {
    offset: 0.4,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
  },
  {
    offset: 1,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, -2000px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)",
  },
];
const easings = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  easeInSine: "cubic-bezier(0.47, 0, 0.745, 0.715)",
  easeOutSine: "cubic-bezier(0.39, 0.575, 0.565, 1)",
  easeInOutSine: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
  easeInQuad: "cubic-bezier(0.55, 0.085, 0.68, 0.53)",
  easeOutQuad: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
  easeInOutQuad: "cubic-bezier(0.455, 0.03, 0.515, 0.955)",
  easeInCubic: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
  easeOutCubic: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  easeInOutCubic: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  easeInQuart: "cubic-bezier(0.895, 0.03, 0.685, 0.22)",
  easeOutQuart: "cubic-bezier(0.165, 0.84, 0.44, 1)",
  easeInOutQuart: "cubic-bezier(0.77, 0, 0.175, 1)",
  easeInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  easeOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  easeInOutQuint: "cubic-bezier(0.86, 0, 0.07, 1)",
  easeInExpo: "cubic-bezier(0.95, 0.05, 0.795, 0.035)",
  easeOutExpo: "cubic-bezier(0.19, 1, 0.22, 1)",
  easeInOutExpo: "cubic-bezier(1, 0, 0, 1)",
  easeInCirc: "cubic-bezier(0.6, 0.04, 0.98, 0.335)",
  easeOutCirc: "cubic-bezier(0.075, 0.82, 0.165, 1)",
  easeInOutCirc: "cubic-bezier(0.785, 0.135, 0.15, 0.86)",
  easeInBack: "cubic-bezier(0.6, -0.28, 0.735, 0.045)",
  easeOutBack: "cubic-bezier(0.175, 0.885, 0.32, 1.275)",
  easeInOutBack: "cubic-bezier(0.68, -0.55, 0.265, 1.55)",
};
const animations = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      backInDown,
      backInLeft,
      backInRight,
      backInUp,
      backOutDown,
      backOutLeft,
      backOutRight,
      backOutUp,
      bounce,
      bounceIn,
      bounceInDown,
      bounceInLeft,
      bounceInRight,
      bounceInUp,
      bounceOut,
      bounceOutDown,
      bounceOutLeft,
      bounceOutRight,
      bounceOutUp,
      easings,
      fadeIn,
      fadeInBottomLeft,
      fadeInBottomRight,
      fadeInDown,
      fadeInDownBig,
      fadeInLeft,
      fadeInLeftBig,
      fadeInRight,
      fadeInRightBig,
      fadeInTopLeft,
      fadeInTopRight,
      fadeInUp,
      fadeInUpBig,
      fadeOut,
      fadeOutBottomLeft,
      fadeOutBottomRight,
      fadeOutDown,
      fadeOutDownBig,
      fadeOutLeft,
      fadeOutLeftBig,
      fadeOutRight,
      fadeOutRightBig,
      fadeOutTopLeft,
      fadeOutTopRight,
      fadeOutUp,
      fadeOutUpBig,
      flash,
      flip,
      flipInX,
      flipInY,
      flipOutX,
      flipOutY,
      headShake,
      heartBeat,
      hinge,
      jackInTheBox,
      jello,
      lightSpeedInLeft,
      lightSpeedInRight,
      lightSpeedOutLeft,
      lightSpeedOutRight,
      pulse,
      rollIn,
      rollOut,
      rotateIn,
      rotateInDownLeft,
      rotateInDownRight,
      rotateInUpLeft,
      rotateInUpRight,
      rotateOut,
      rotateOutDownLeft,
      rotateOutDownRight,
      rotateOutUpLeft,
      rotateOutUpRight,
      rubberBand,
      shake,
      shakeX,
      shakeY,
      slideInDown,
      slideInLeft,
      slideInRight,
      slideInUp,
      slideOutDown,
      slideOutLeft,
      slideOutRight,
      slideOutUp,
      swing,
      tada,
      wobble,
      zoomIn,
      zoomInDown,
      zoomInLeft,
      zoomInRight,
      zoomInUp,
      zoomOut,
      zoomOutDown,
      zoomOutLeft,
      zoomOutRight,
      zoomOutUp,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);
var SlAnimation = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasStarted = false;
    this.name = "none";
    this.play = false;
    this.delay = 0;
    this.direction = "normal";
    this.duration = 1e3;
    this.easing = "linear";
    this.endDelay = 0;
    this.fill = "auto";
    this.iterations = Infinity;
    this.iterationStart = 0;
    this.playbackRate = 1;
    this.handleAnimationFinish = () => {
      this.play = false;
      this.hasStarted = false;
      this.emit("sl-finish");
    };
    this.handleAnimationCancel = () => {
      this.play = false;
      this.hasStarted = false;
      this.emit("sl-cancel");
    };
  }
  /** Gets and sets the current animation time. */
  get currentTime() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.animation) == null ? void 0 : _a2.currentTime) !=
      null
      ? _b2
      : 0;
  }
  set currentTime(time) {
    if (this.animation) {
      this.animation.currentTime = time;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    this.createAnimation();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.destroyAnimation();
  }
  handleSlotChange() {
    this.destroyAnimation();
    this.createAnimation();
  }
  async createAnimation() {
    var _a2, _b2;
    const easing = (_a2 = easings[this.easing]) != null ? _a2 : this.easing;
    const keyframes =
      (_b2 = this.keyframes) != null ? _b2 : animations[this.name];
    const slot = await this.defaultSlot;
    const element = slot.assignedElements()[0];
    if (!element || !keyframes) {
      return false;
    }
    this.destroyAnimation();
    this.animation = element.animate(keyframes, {
      delay: this.delay,
      direction: this.direction,
      duration: this.duration,
      easing,
      endDelay: this.endDelay,
      fill: this.fill,
      iterationStart: this.iterationStart,
      iterations: this.iterations,
    });
    this.animation.playbackRate = this.playbackRate;
    this.animation.addEventListener("cancel", this.handleAnimationCancel);
    this.animation.addEventListener("finish", this.handleAnimationFinish);
    if (this.play) {
      this.hasStarted = true;
      this.emit("sl-start");
    } else {
      this.animation.pause();
    }
    return true;
  }
  destroyAnimation() {
    if (this.animation) {
      this.animation.cancel();
      this.animation.removeEventListener("cancel", this.handleAnimationCancel);
      this.animation.removeEventListener("finish", this.handleAnimationFinish);
      this.hasStarted = false;
    }
  }
  handleAnimationChange() {
    if (!this.hasUpdated) {
      return;
    }
    this.createAnimation();
  }
  handlePlayChange() {
    if (this.animation) {
      if (this.play && !this.hasStarted) {
        this.hasStarted = true;
        this.emit("sl-start");
      }
      if (this.play) {
        this.animation.play();
      } else {
        this.animation.pause();
      }
      return true;
    }
    return false;
  }
  handlePlaybackRateChange() {
    if (this.animation) {
      this.animation.playbackRate = this.playbackRate;
    }
  }
  /** Clears all keyframe effects caused by this animation and aborts its playback. */
  cancel() {
    var _a2;
    (_a2 = this.animation) == null ? void 0 : _a2.cancel();
  }
  /** Sets the playback time to the end of the animation corresponding to the current playback direction. */
  finish() {
    var _a2;
    (_a2 = this.animation) == null ? void 0 : _a2.finish();
  }
  render() {
    return x$2` <slot @slotchange=${this.handleSlotChange}></slot> `;
  }
};
SlAnimation.styles = [component_styles_default, animation_styles_default];
__decorateClass([r$3("slot")], SlAnimation.prototype, "defaultSlot", 2);
__decorateClass([n$6()], SlAnimation.prototype, "name", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlAnimation.prototype,
  "play",
  2,
);
__decorateClass([n$6({ type: Number })], SlAnimation.prototype, "delay", 2);
__decorateClass([n$6()], SlAnimation.prototype, "direction", 2);
__decorateClass([n$6({ type: Number })], SlAnimation.prototype, "duration", 2);
__decorateClass([n$6()], SlAnimation.prototype, "easing", 2);
__decorateClass(
  [n$6({ attribute: "end-delay", type: Number })],
  SlAnimation.prototype,
  "endDelay",
  2,
);
__decorateClass([n$6()], SlAnimation.prototype, "fill", 2);
__decorateClass(
  [n$6({ type: Number })],
  SlAnimation.prototype,
  "iterations",
  2,
);
__decorateClass(
  [n$6({ attribute: "iteration-start", type: Number })],
  SlAnimation.prototype,
  "iterationStart",
  2,
);
__decorateClass(
  [n$6({ attribute: false })],
  SlAnimation.prototype,
  "keyframes",
  2,
);
__decorateClass(
  [n$6({ attribute: "playback-rate", type: Number })],
  SlAnimation.prototype,
  "playbackRate",
  2,
);
__decorateClass(
  [
    watch([
      "name",
      "delay",
      "direction",
      "duration",
      "easing",
      "endDelay",
      "fill",
      "iterations",
      "iterationsStart",
      "keyframes",
    ]),
  ],
  SlAnimation.prototype,
  "handleAnimationChange",
  1,
);
__decorateClass([watch("play")], SlAnimation.prototype, "handlePlayChange", 1);
__decorateClass(
  [watch("playbackRate")],
  SlAnimation.prototype,
  "handlePlaybackRateChange",
  1,
);
var tagName$7 = "sl-animation";
SlAnimation.define("sl-animation");
o$8({
  tagName: tagName$7,
  elementClass: SlAnimation,
  react: React,
  events: {
    onSlCancel: "sl-cancel",
    onSlFinish: "sl-finish",
    onSlStart: "sl-start",
  },
  displayName: "SlAnimation",
});
var breadcrumb_styles_default = i$8`
  .breadcrumb {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
  }
`;
var SlBreadcrumb = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.separatorDir = this.localize.dir();
    this.label = "";
  }
  // Generates a clone of the separator element to use for each breadcrumb item
  getSeparator() {
    const separator = this.separatorSlot.assignedElements({ flatten: true })[0];
    const clone = separator.cloneNode(true);
    [clone, ...clone.querySelectorAll("[id]")].forEach((el) =>
      el.removeAttribute("id"),
    );
    clone.setAttribute("data-default", "");
    clone.slot = "separator";
    return clone;
  }
  handleSlotChange() {
    const items = [
      ...this.defaultSlot.assignedElements({ flatten: true }),
    ].filter((item) => item.tagName.toLowerCase() === "sl-breadcrumb-item");
    items.forEach((item, index) => {
      const separator = item.querySelector('[slot="separator"]');
      if (separator === null) {
        item.append(this.getSeparator());
      } else if (separator.hasAttribute("data-default")) {
        separator.replaceWith(this.getSeparator());
      } else;
      if (index === items.length - 1) {
        item.setAttribute("aria-current", "page");
      } else {
        item.removeAttribute("aria-current");
      }
    });
  }
  render() {
    if (this.separatorDir !== this.localize.dir()) {
      this.separatorDir = this.localize.dir();
      this.updateComplete.then(() => this.handleSlotChange());
    }
    return x$2`
      <nav part="base" class="breadcrumb" aria-label=${this.label}>
        <slot @slotchange=${this.handleSlotChange}></slot>
      </nav>

      <span hidden aria-hidden="true">
        <slot name="separator">
          <sl-icon name=${this.localize.dir() === "rtl" ? "chevron-left" : "chevron-right"} library="system"></sl-icon>
        </slot>
      </span>
    `;
  }
};
SlBreadcrumb.styles = [component_styles_default, breadcrumb_styles_default];
SlBreadcrumb.dependencies = { "sl-icon": SlIcon };
__decorateClass([e$8("slot")], SlBreadcrumb.prototype, "defaultSlot", 2);
__decorateClass(
  [e$8('slot[name="separator"]')],
  SlBreadcrumb.prototype,
  "separatorSlot",
  2,
);
__decorateClass([n$6()], SlBreadcrumb.prototype, "label", 2);
var tagName$6 = "sl-breadcrumb";
SlBreadcrumb.define("sl-breadcrumb");
o$8({
  tagName: tagName$6,
  elementClass: SlBreadcrumb,
  react: React,
  events: {},
  displayName: "SlBreadcrumb",
});
var badge_styles_default = i$8`
  :host {
    display: inline-flex;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: max(12px, 0.75em);
    font-weight: var(--sl-font-weight-semibold);
    letter-spacing: var(--sl-letter-spacing-normal);
    line-height: 1;
    border-radius: var(--sl-border-radius-small);
    border: solid 1px var(--sl-color-neutral-0);
    white-space: nowrap;
    padding: 0.35em 0.6em;
    user-select: none;
    -webkit-user-select: none;
    cursor: inherit;
  }

  /* Variant modifiers */
  .badge--primary {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--success {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--neutral {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--warning {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--danger {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /* Pill modifier */
  .badge--pill {
    border-radius: var(--sl-border-radius-pill);
  }

  /* Pulse modifier */
  .badge--pulse {
    animation: pulse 1.5s infinite;
  }

  .badge--pulse.badge--primary {
    --pulse-color: var(--sl-color-primary-600);
  }

  .badge--pulse.badge--success {
    --pulse-color: var(--sl-color-success-600);
  }

  .badge--pulse.badge--neutral {
    --pulse-color: var(--sl-color-neutral-600);
  }

  .badge--pulse.badge--warning {
    --pulse-color: var(--sl-color-warning-600);
  }

  .badge--pulse.badge--danger {
    --pulse-color: var(--sl-color-danger-600);
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--pulse-color);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }
`;
var SlBadge = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.variant = "primary";
    this.pill = false;
    this.pulse = false;
  }
  render() {
    return x$2`
      <span
        part="base"
        class=${e$4({
          badge: true,
          "badge--primary": this.variant === "primary",
          "badge--success": this.variant === "success",
          "badge--neutral": this.variant === "neutral",
          "badge--warning": this.variant === "warning",
          "badge--danger": this.variant === "danger",
          "badge--pill": this.pill,
          "badge--pulse": this.pulse,
        })}
        role="status"
      >
        <slot></slot>
      </span>
    `;
  }
};
SlBadge.styles = [component_styles_default, badge_styles_default];
__decorateClass([n$6({ reflect: true })], SlBadge.prototype, "variant", 2);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlBadge.prototype,
  "pill",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  SlBadge.prototype,
  "pulse",
  2,
);
var tagName$5 = "sl-badge";
SlBadge.define("sl-badge");
o$8({
  tagName: tagName$5,
  elementClass: SlBadge,
  react: React,
  events: {},
  displayName: "SlBadge",
});
var avatar_styles_default = i$8`
  :host {
    display: inline-block;

    --size: 3rem;
  }

  .avatar {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: var(--size);
    height: var(--size);
    background-color: var(--sl-color-neutral-400);
    font-family: var(--sl-font-sans);
    font-size: calc(var(--size) * 0.5);
    font-weight: var(--sl-font-weight-normal);
    color: var(--sl-color-neutral-0);
    user-select: none;
    -webkit-user-select: none;
    vertical-align: middle;
  }

  .avatar--circle,
  .avatar--circle .avatar__image {
    border-radius: var(--sl-border-radius-circle);
  }

  .avatar--rounded,
  .avatar--rounded .avatar__image {
    border-radius: var(--sl-border-radius-medium);
  }

  .avatar--square {
    border-radius: 0;
  }

  .avatar__icon {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .avatar__initials {
    line-height: 1;
    text-transform: uppercase;
  }

  .avatar__image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    overflow: hidden;
  }
`;
var SlAvatar = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasError = false;
    this.image = "";
    this.label = "";
    this.initials = "";
    this.loading = "eager";
    this.shape = "circle";
  }
  handleImageChange() {
    this.hasError = false;
  }
  handleImageLoadError() {
    this.hasError = true;
    this.emit("sl-error");
  }
  render() {
    const avatarWithImage = x$2`
      <img
        part="image"
        class="avatar__image"
        src="${this.image}"
        loading="${this.loading}"
        alt=""
        @error="${this.handleImageLoadError}"
      />
    `;
    let avatarWithoutImage = x$2``;
    if (this.initials) {
      avatarWithoutImage = x$2`<div part="initials" class="avatar__initials">${this.initials}</div>`;
    } else {
      avatarWithoutImage = x$2`
        <div part="icon" class="avatar__icon" aria-hidden="true">
          <slot name="icon">
            <sl-icon name="person-fill" library="system"></sl-icon>
          </slot>
        </div>
      `;
    }
    return x$2`
      <div
        part="base"
        class=${e$4({
          avatar: true,
          "avatar--circle": this.shape === "circle",
          "avatar--rounded": this.shape === "rounded",
          "avatar--square": this.shape === "square",
        })}
        role="img"
        aria-label=${this.label}
      >
        ${this.image && !this.hasError ? avatarWithImage : avatarWithoutImage}
      </div>
    `;
  }
};
SlAvatar.styles = [component_styles_default, avatar_styles_default];
SlAvatar.dependencies = {
  "sl-icon": SlIcon,
};
__decorateClass([r$4()], SlAvatar.prototype, "hasError", 2);
__decorateClass([n$6()], SlAvatar.prototype, "image", 2);
__decorateClass([n$6()], SlAvatar.prototype, "label", 2);
__decorateClass([n$6()], SlAvatar.prototype, "initials", 2);
__decorateClass([n$6()], SlAvatar.prototype, "loading", 2);
__decorateClass([n$6({ reflect: true })], SlAvatar.prototype, "shape", 2);
__decorateClass([watch("image")], SlAvatar.prototype, "handleImageChange", 1);
var tagName$4 = "sl-avatar";
SlAvatar.define("sl-avatar");
var reactWrapper$2 = o$8({
  tagName: tagName$4,
  elementClass: SlAvatar,
  react: React,
  events: {
    onSlError: "sl-error",
  },
  displayName: "SlAvatar",
});
var avatar_default = reactWrapper$2;
var breadcrumb_item_styles_default = i$8`
  :host {
    display: inline-flex;
  }

  .breadcrumb-item {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-600);
    line-height: var(--sl-line-height-normal);
    white-space: nowrap;
  }

  .breadcrumb-item__label {
    display: inline-block;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    line-height: inherit;
    text-decoration: none;
    color: inherit;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    padding: 0;
    margin: 0;
    cursor: pointer;
    transition: var(--sl-transition-fast) --color;
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label {
    color: var(--sl-color-primary-600);
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label:hover {
    color: var(--sl-color-primary-500);
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label:active {
    color: var(--sl-color-primary-600);
  }

  .breadcrumb-item__label:focus {
    outline: none;
  }

  .breadcrumb-item__label:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .breadcrumb-item__prefix,
  .breadcrumb-item__suffix {
    display: none;
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .breadcrumb-item--has-prefix .breadcrumb-item__prefix {
    display: inline-flex;
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .breadcrumb-item--has-suffix .breadcrumb-item__suffix {
    display: inline-flex;
    margin-inline-start: var(--sl-spacing-x-small);
  }

  :host(:last-of-type) .breadcrumb-item__separator {
    display: none;
  }

  .breadcrumb-item__separator {
    display: inline-flex;
    align-items: center;
    margin: 0 var(--sl-spacing-x-small);
    user-select: none;
    -webkit-user-select: none;
  }
`;
var SlBreadcrumbItem = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "prefix", "suffix");
    this.renderType = "button";
    this.rel = "noreferrer noopener";
  }
  setRenderType() {
    const hasDropdown =
      this.defaultSlot
        .assignedElements({ flatten: true })
        .filter((i3) => i3.tagName.toLowerCase() === "sl-dropdown").length > 0;
    if (this.href) {
      this.renderType = "link";
      return;
    }
    if (hasDropdown) {
      this.renderType = "dropdown";
      return;
    }
    this.renderType = "button";
  }
  hrefChanged() {
    this.setRenderType();
  }
  handleSlotChange() {
    this.setRenderType();
  }
  render() {
    return x$2`
      <div
        part="base"
        class=${e$4({
          "breadcrumb-item": true,
          "breadcrumb-item--has-prefix": this.hasSlotController.test("prefix"),
          "breadcrumb-item--has-suffix": this.hasSlotController.test("suffix"),
        })}
      >
        <span part="prefix" class="breadcrumb-item__prefix">
          <slot name="prefix"></slot>
        </span>

        ${
          this.renderType === "link"
            ? x$2`
              <a
                part="label"
                class="breadcrumb-item__label breadcrumb-item__label--link"
                href="${this.href}"
                target="${o$7(this.target ? this.target : void 0)}"
                rel=${o$7(this.target ? this.rel : void 0)}
              >
                <slot @slotchange=${this.handleSlotChange}></slot>
              </a>
            `
            : ""
        }
        ${
          this.renderType === "button"
            ? x$2`
              <button part="label" type="button" class="breadcrumb-item__label breadcrumb-item__label--button">
                <slot @slotchange=${this.handleSlotChange}></slot>
              </button>
            `
            : ""
        }
        ${
          this.renderType === "dropdown"
            ? x$2`
              <div part="label" class="breadcrumb-item__label breadcrumb-item__label--drop-down">
                <slot @slotchange=${this.handleSlotChange}></slot>
              </div>
            `
            : ""
        }

        <span part="suffix" class="breadcrumb-item__suffix">
          <slot name="suffix"></slot>
        </span>

        <span part="separator" class="breadcrumb-item__separator" aria-hidden="true">
          <slot name="separator"></slot>
        </span>
      </div>
    `;
  }
};
SlBreadcrumbItem.styles = [
  component_styles_default,
  breadcrumb_item_styles_default,
];
__decorateClass(
  [e$8("slot:not([name])")],
  SlBreadcrumbItem.prototype,
  "defaultSlot",
  2,
);
__decorateClass([r$4()], SlBreadcrumbItem.prototype, "renderType", 2);
__decorateClass([n$6()], SlBreadcrumbItem.prototype, "href", 2);
__decorateClass([n$6()], SlBreadcrumbItem.prototype, "target", 2);
__decorateClass([n$6()], SlBreadcrumbItem.prototype, "rel", 2);
__decorateClass(
  [watch("href", { waitUntilFirstUpdate: true })],
  SlBreadcrumbItem.prototype,
  "hrefChanged",
  1,
);
var tagName$3 = "sl-breadcrumb-item";
SlBreadcrumbItem.define("sl-breadcrumb-item");
o$8({
  tagName: tagName$3,
  elementClass: SlBreadcrumbItem,
  react: React,
  events: {},
  displayName: "SlBreadcrumbItem",
});
var tagName$2 = "sl-button-group";
SlButtonGroup.define("sl-button-group");
o$8({
  tagName: tagName$2,
  elementClass: SlButtonGroup,
  react: React,
  events: {},
  displayName: "SlButtonGroup",
});
var tagName$1 = "sl-button";
SlButton.define("sl-button");
var reactWrapper$1 = o$8({
  tagName: tagName$1,
  elementClass: SlButton,
  react: React,
  events: {
    onSlBlur: "sl-blur",
    onSlFocus: "sl-focus",
    onSlInvalid: "sl-invalid",
  },
  displayName: "SlButton",
});
var button_default = reactWrapper$1;
var alert_styles_default = i$8`
  :host {
    display: contents;

    /* For better DX, we'll reset the margin here so the base part can inherit it */
    margin: 0;
  }

  .alert {
    position: relative;
    display: flex;
    align-items: stretch;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-top-width: calc(var(--sl-panel-border-width) * 3);
    border-radius: var(--sl-border-radius-medium);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-normal);
    line-height: 1.6;
    color: var(--sl-color-neutral-700);
    margin: inherit;
    overflow: hidden;
  }

  .alert:not(.alert--has-icon) .alert__icon,
  .alert:not(.alert--closable) .alert__close-button {
    display: none;
  }

  .alert__icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-large);
    padding-inline-start: var(--sl-spacing-large);
  }

  .alert--has-countdown {
    border-bottom: none;
  }

  .alert--primary {
    border-top-color: var(--sl-color-primary-600);
  }

  .alert--primary .alert__icon {
    color: var(--sl-color-primary-600);
  }

  .alert--success {
    border-top-color: var(--sl-color-success-600);
  }

  .alert--success .alert__icon {
    color: var(--sl-color-success-600);
  }

  .alert--neutral {
    border-top-color: var(--sl-color-neutral-600);
  }

  .alert--neutral .alert__icon {
    color: var(--sl-color-neutral-600);
  }

  .alert--warning {
    border-top-color: var(--sl-color-warning-600);
  }

  .alert--warning .alert__icon {
    color: var(--sl-color-warning-600);
  }

  .alert--danger {
    border-top-color: var(--sl-color-danger-600);
  }

  .alert--danger .alert__icon {
    color: var(--sl-color-danger-600);
  }

  .alert__message {
    flex: 1 1 auto;
    display: block;
    padding: var(--sl-spacing-large);
    overflow: hidden;
  }

  .alert__close-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
    padding-inline-end: var(--sl-spacing-medium);
  }

  .alert__countdown {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: calc(var(--sl-panel-border-width) * 3);
    background-color: var(--sl-panel-border-color);
    display: flex;
  }

  .alert__countdown--ltr {
    justify-content: flex-end;
  }

  .alert__countdown .alert__countdown-elapsed {
    height: 100%;
    width: 0;
  }

  .alert--primary .alert__countdown-elapsed {
    background-color: var(--sl-color-primary-600);
  }

  .alert--success .alert__countdown-elapsed {
    background-color: var(--sl-color-success-600);
  }

  .alert--neutral .alert__countdown-elapsed {
    background-color: var(--sl-color-neutral-600);
  }

  .alert--warning .alert__countdown-elapsed {
    background-color: var(--sl-color-warning-600);
  }

  .alert--danger .alert__countdown-elapsed {
    background-color: var(--sl-color-danger-600);
  }

  .alert__timer {
    display: none;
  }
`;
var _SlAlert = class _SlAlert2 extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "icon", "suffix");
    this.localize = new LocalizeController2(this);
    this.open = false;
    this.closable = false;
    this.variant = "primary";
    this.duration = Infinity;
    this.remainingTime = this.duration;
  }
  static get toastStack() {
    if (!this.currentToastStack) {
      this.currentToastStack = Object.assign(document.createElement("div"), {
        className: "sl-toast-stack",
      });
    }
    return this.currentToastStack;
  }
  firstUpdated() {
    this.base.hidden = !this.open;
  }
  restartAutoHide() {
    this.handleCountdownChange();
    clearTimeout(this.autoHideTimeout);
    clearInterval(this.remainingTimeInterval);
    if (this.open && this.duration < Infinity) {
      this.autoHideTimeout = window.setTimeout(
        () => this.hide(),
        this.duration,
      );
      this.remainingTime = this.duration;
      this.remainingTimeInterval = window.setInterval(() => {
        this.remainingTime -= 100;
      }, 100);
    }
  }
  pauseAutoHide() {
    var _a2;
    (_a2 = this.countdownAnimation) == null ? void 0 : _a2.pause();
    clearTimeout(this.autoHideTimeout);
    clearInterval(this.remainingTimeInterval);
  }
  resumeAutoHide() {
    var _a2;
    if (this.duration < Infinity) {
      this.autoHideTimeout = window.setTimeout(
        () => this.hide(),
        this.remainingTime,
      );
      this.remainingTimeInterval = window.setInterval(() => {
        this.remainingTime -= 100;
      }, 100);
      (_a2 = this.countdownAnimation) == null ? void 0 : _a2.play();
    }
  }
  handleCountdownChange() {
    if (this.open && this.duration < Infinity && this.countdown) {
      const { countdownElement } = this;
      const start = "100%";
      const end = "0";
      this.countdownAnimation = countdownElement.animate(
        [{ width: start }, { width: end }],
        {
          duration: this.duration,
          easing: "linear",
        },
      );
    }
  }
  handleCloseClick() {
    this.hide();
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show");
      if (this.duration < Infinity) {
        this.restartAutoHide();
      }
      await stopAnimations(this.base);
      this.base.hidden = false;
      const { keyframes, options } = getAnimation(this, "alert.show", {
        dir: this.localize.dir(),
      });
      await animateTo(this.base, keyframes, options);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      clearTimeout(this.autoHideTimeout);
      clearInterval(this.remainingTimeInterval);
      await stopAnimations(this.base);
      const { keyframes, options } = getAnimation(this, "alert.hide", {
        dir: this.localize.dir(),
      });
      await animateTo(this.base, keyframes, options);
      this.base.hidden = true;
      this.emit("sl-after-hide");
    }
  }
  handleDurationChange() {
    this.restartAutoHide();
  }
  /** Shows the alert. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the alert */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /**
   * Displays the alert as a toast notification. This will move the alert out of its position in the DOM and, when
   * dismissed, it will be removed from the DOM completely. By storing a reference to the alert, you can reuse it by
   * calling this method again. The returned promise will resolve after the alert is hidden.
   */
  async toast() {
    return new Promise((resolve) => {
      this.handleCountdownChange();
      if (_SlAlert2.toastStack.parentElement === null) {
        document.body.append(_SlAlert2.toastStack);
      }
      _SlAlert2.toastStack.appendChild(this);
      requestAnimationFrame(() => {
        this.clientWidth;
        this.show();
      });
      this.addEventListener(
        "sl-after-hide",
        () => {
          _SlAlert2.toastStack.removeChild(this);
          resolve();
          if (_SlAlert2.toastStack.querySelector("sl-alert") === null) {
            _SlAlert2.toastStack.remove();
          }
        },
        { once: true },
      );
    });
  }
  render() {
    return x$2`
      <div
        part="base"
        class=${e$4({
          alert: true,
          "alert--open": this.open,
          "alert--closable": this.closable,
          "alert--has-countdown": !!this.countdown,
          "alert--has-icon": this.hasSlotController.test("icon"),
          "alert--primary": this.variant === "primary",
          "alert--success": this.variant === "success",
          "alert--neutral": this.variant === "neutral",
          "alert--warning": this.variant === "warning",
          "alert--danger": this.variant === "danger",
        })}
        role="alert"
        aria-hidden=${this.open ? "false" : "true"}
        @mouseenter=${this.pauseAutoHide}
        @mouseleave=${this.resumeAutoHide}
      >
        <div part="icon" class="alert__icon">
          <slot name="icon"></slot>
        </div>

        <div part="message" class="alert__message" aria-live="polite">
          <slot></slot>
        </div>

        ${
          this.closable
            ? x$2`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                class="alert__close-button"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                @click=${this.handleCloseClick}
              ></sl-icon-button>
            `
            : ""
        }

        <div role="timer" class="alert__timer">${this.remainingTime}</div>

        ${
          this.countdown
            ? x$2`
              <div
                class=${e$4({
                  alert__countdown: true,
                  "alert__countdown--ltr": this.countdown === "ltr",
                })}
              >
                <div class="alert__countdown-elapsed"></div>
              </div>
            `
            : ""
        }
      </div>
    `;
  }
};
_SlAlert.styles = [component_styles_default, alert_styles_default];
_SlAlert.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([e$8('[part~="base"]')], _SlAlert.prototype, "base", 2);
__decorateClass(
  [e$8(".alert__countdown-elapsed")],
  _SlAlert.prototype,
  "countdownElement",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  _SlAlert.prototype,
  "open",
  2,
);
__decorateClass(
  [n$6({ type: Boolean, reflect: true })],
  _SlAlert.prototype,
  "closable",
  2,
);
__decorateClass([n$6({ reflect: true })], _SlAlert.prototype, "variant", 2);
__decorateClass([n$6({ type: Number })], _SlAlert.prototype, "duration", 2);
__decorateClass(
  [n$6({ type: String, reflect: true })],
  _SlAlert.prototype,
  "countdown",
  2,
);
__decorateClass([r$4()], _SlAlert.prototype, "remainingTime", 2);
__decorateClass(
  [watch("open", { waitUntilFirstUpdate: true })],
  _SlAlert.prototype,
  "handleOpenChange",
  1,
);
__decorateClass(
  [watch("duration")],
  _SlAlert.prototype,
  "handleDurationChange",
  1,
);
var SlAlert = _SlAlert;
setDefaultAnimation("alert.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 },
  ],
  options: { duration: 250, easing: "ease" },
});
setDefaultAnimation("alert.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 },
  ],
  options: { duration: 250, easing: "ease" },
});
var tagName = "sl-alert";
SlAlert.define("sl-alert");
var reactWrapper = o$8({
  tagName,
  elementClass: SlAlert,
  react: React,
  events: {
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide",
  },
  displayName: "SlAlert",
});
var alert_default = reactWrapper;
var debounce = (fn2, delay) => {
  let timerId = 0;
  return function (...args) {
    window.clearTimeout(timerId);
    timerId = window.setTimeout(() => {
      fn2.call(this, ...args);
    }, delay);
  };
};
var decorate = (proto, method, decorateFn) => {
  const superFn = proto[method];
  proto[method] = function (...args) {
    superFn.call(this, ...args);
    decorateFn.call(this, superFn, ...args);
  };
};
(() => {
  if (typeof window === "undefined") {
    return;
  }
  const isSupported = "onscrollend" in window;
  if (!isSupported) {
    const pointers = /* @__PURE__ */ new Set();
    const scrollHandlers = /* @__PURE__ */ new WeakMap();
    const handlePointerDown = (event) => {
      for (const touch of event.changedTouches) {
        pointers.add(touch.identifier);
      }
    };
    const handlePointerUp = (event) => {
      for (const touch of event.changedTouches) {
        pointers.delete(touch.identifier);
      }
    };
    document.addEventListener("touchstart", handlePointerDown, true);
    document.addEventListener("touchend", handlePointerUp, true);
    document.addEventListener("touchcancel", handlePointerUp, true);
    decorate(
      EventTarget.prototype,
      "addEventListener",
      function (addEventListener, type) {
        if (type !== "scrollend") return;
        const handleScrollEnd = debounce(() => {
          if (!pointers.size) {
            this.dispatchEvent(new Event("scrollend"));
          } else {
            handleScrollEnd();
          }
        }, 100);
        addEventListener.call(this, "scroll", handleScrollEnd, {
          passive: true,
        });
        scrollHandlers.set(this, handleScrollEnd);
      },
    );
    decorate(
      EventTarget.prototype,
      "removeEventListener",
      function (removeEventListener, type) {
        if (type !== "scrollend") return;
        const scrollHandler = scrollHandlers.get(this);
        if (scrollHandler) {
          removeEventListener.call(this, "scroll", scrollHandler, {
            passive: true,
          });
        }
      },
    );
  }
})();
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {}
  onUnsubscribe() {}
};
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop$1() {}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale,
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(queryKey, (_2, val) =>
    isPlainObject(val)
      ? Object.keys(val)
          .sort()
          .reduce((result, key) => {
            result[key] = val[key];
            return result;
          }, {})
      : val,
  );
}
function partialMatchKey(a2, b3) {
  if (a2 === b3) {
    return true;
  }
  if (typeof a2 !== typeof b3) {
    return false;
  }
  if (a2 && b3 && typeof a2 === "object" && typeof b3 === "object") {
    return Object.keys(b3).every((key) => partialMatchKey(a2[key], b3[key]));
  }
  return false;
}
function replaceEqualDeep(a2, b3) {
  if (a2 === b3) {
    return a2;
  }
  const array = isPlainArray(a2) && isPlainArray(b3);
  if (array || (isPlainObject(a2) && isPlainObject(b3))) {
    const aItems = array ? a2 : Object.keys(a2);
    const aSize = aItems.length;
    const bItems = array ? b3 : Object.keys(b3);
    const bSize = bItems.length;
    const copy = array ? [] : {};
    let equalItems = 0;
    for (let i3 = 0; i3 < bSize; i3++) {
      const key = array ? i3 : bItems[i3];
      if (
        ((!array && aItems.includes(key)) || array) &&
        a2[key] === void 0 &&
        b3[key] === void 0
      ) {
        copy[key] = void 0;
        equalItems++;
      } else {
        copy[key] = replaceEqualDeep(a2[key], b3[key]);
        if (copy[key] === a2[key] && a2[key] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a2 : copy;
  }
  return b3;
}
function shallowEqualObjects(a2, b3) {
  if (!b3 || Object.keys(a2).length !== Object.keys(b3).length) {
    return false;
  }
  for (const key in a2) {
    if (a2[key] !== b3[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o2) {
  if (!hasObjectPrototype(o2)) {
    return false;
  }
  const ctor = o2.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o2) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function addToEnd(items, item, max2 = 0) {
  const newItems = [...items, item];
  return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max2 = 0) {
  const newItems = [item, ...items];
  return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (
    !options.queryFn &&
    (fetchOptions == null ? void 0 : fetchOptions.initialPromise)
  ) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () =>
      Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
var FocusManager =
  ((_b = class extends Subscribable {
    constructor() {
      super();
      __privateAdd(this, _focused);
      __privateAdd(this, _cleanup);
      __privateAdd(this, _setup);
      __privateSet(this, _setup, (onFocus) => {
        if (!isServer && window.addEventListener) {
          const listener = () => onFocus();
          window.addEventListener("visibilitychange", listener, false);
          return () => {
            window.removeEventListener("visibilitychange", listener);
          };
        }
        return;
      });
    }
    onSubscribe() {
      if (!__privateGet(this, _cleanup)) {
        this.setEventListener(__privateGet(this, _setup));
      }
    }
    onUnsubscribe() {
      var _a2;
      if (!this.hasListeners()) {
        (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
        __privateSet(this, _cleanup, void 0);
      }
    }
    setEventListener(setup) {
      var _a2;
      __privateSet(this, _setup, setup);
      (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
      __privateSet(
        this,
        _cleanup,
        setup((focused) => {
          if (typeof focused === "boolean") {
            this.setFocused(focused);
          } else {
            this.onFocus();
          }
        }),
      );
    }
    setFocused(focused) {
      const changed = __privateGet(this, _focused) !== focused;
      if (changed) {
        __privateSet(this, _focused, focused);
        this.onFocus();
      }
    }
    onFocus() {
      const isFocused = this.isFocused();
      this.listeners.forEach((listener) => {
        listener(isFocused);
      });
    }
    isFocused() {
      var _a2;
      if (typeof __privateGet(this, _focused) === "boolean") {
        return __privateGet(this, _focused);
      }
      return (
        ((_a2 = globalThis.document) == null ? void 0 : _a2.visibilityState) !==
        "hidden"
      );
    }
  }),
  (_focused = new WeakMap()),
  (_cleanup = new WeakMap()),
  (_setup = new WeakMap()),
  _b);
var focusManager = new FocusManager();
var OnlineManager =
  ((_c = class extends Subscribable {
    constructor() {
      super();
      __privateAdd(this, _online, true);
      __privateAdd(this, _cleanup2);
      __privateAdd(this, _setup2);
      __privateSet(this, _setup2, (onOnline) => {
        if (!isServer && window.addEventListener) {
          const onlineListener = () => onOnline(true);
          const offlineListener = () => onOnline(false);
          window.addEventListener("online", onlineListener, false);
          window.addEventListener("offline", offlineListener, false);
          return () => {
            window.removeEventListener("online", onlineListener);
            window.removeEventListener("offline", offlineListener);
          };
        }
        return;
      });
    }
    onSubscribe() {
      if (!__privateGet(this, _cleanup2)) {
        this.setEventListener(__privateGet(this, _setup2));
      }
    }
    onUnsubscribe() {
      var _a2;
      if (!this.hasListeners()) {
        (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
        __privateSet(this, _cleanup2, void 0);
      }
    }
    setEventListener(setup) {
      var _a2;
      __privateSet(this, _setup2, setup);
      (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
    }
    setOnline(online) {
      const changed = __privateGet(this, _online) !== online;
      if (changed) {
        __privateSet(this, _online, online);
        this.listeners.forEach((listener) => {
          listener(online);
        });
      }
    }
    isOnline() {
      return __privateGet(this, _online);
    }
  }),
  (_online = new WeakMap()),
  (_cleanup2 = new WeakMap()),
  (_setup2 = new WeakMap()),
  _c);
var onlineManager = new OnlineManager();
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {});
  function finalize(data) {
    Object.assign(thenable, data);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value,
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason,
    });
    reject(reason);
  };
  return thenable;
}
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online"
    ? onlineManager.isOnline()
    : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  const thenable = pendingThenable();
  const cancel = (cancelOptions) => {
    var _a2;
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      (_a2 = config.abort) == null ? void 0 : _a2.call(config);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () =>
    focusManager.isFocused() &&
    (config.networkMode === "always" || onlineManager.isOnline()) &&
    config.canRun();
  const canStart = () => canFetch(config.networkMode) && config.canRun();
  const resolve = (value) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config.onSuccess) == null ? void 0 : _a2.call(config, value);
      continueFn == null ? void 0 : continueFn();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config.onError) == null ? void 0 : _a2.call(config, value);
      continueFn == null ? void 0 : continueFn();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      var _a2;
      continueFn = (value) => {
        if (isResolved || canContinue()) {
          continueResolve(value);
        }
      };
      (_a2 = config.onPause) == null ? void 0 : _a2.call(config);
    }).then(() => {
      var _a2;
      continueFn = void 0;
      if (!isResolved) {
        (_a2 = config.onContinue) == null ? void 0 : _a2.call(config);
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue)
      .then(resolve)
      .catch((error) => {
        var _a2;
        if (isResolved) {
          return;
        }
        const retry = config.retry ?? (isServer ? 0 : 3);
        const retryDelay = config.retryDelay ?? defaultRetryDelay;
        const delay =
          typeof retryDelay === "function"
            ? retryDelay(failureCount, error)
            : retryDelay;
        const shouldRetry =
          retry === true ||
          (typeof retry === "number" && failureCount < retry) ||
          (typeof retry === "function" && retry(failureCount, error));
        if (isRetryCancelled || !shouldRetry) {
          reject(error);
          return;
        }
        failureCount++;
        (_a2 = config.onFail) == null
          ? void 0
          : _a2.call(config, failureCount, error);
        sleep(delay)
          .then(() => {
            return canContinue() ? void 0 : pause();
          })
          .then(() => {
            if (isRetryCancelled) {
              reject(error);
            } else {
              run();
            }
          });
      });
  };
  return {
    promise: thenable,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    },
  };
}
var defaultScheduler = (cb) => setTimeout(cb, 0);
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = defaultScheduler;
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn2) => {
      notifyFn = fn2;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn2) => {
      batchNotifyFn = fn2;
    },
    setScheduler: (fn2) => {
      scheduleFn = fn2;
    },
  };
}
var notifyManager = createNotifyManager();
var Removable =
  ((_d = class {
    constructor() {
      __privateAdd(this, _gcTimeout);
    }
    destroy() {
      this.clearGcTimeout();
    }
    scheduleGc() {
      this.clearGcTimeout();
      if (isValidTimeout(this.gcTime)) {
        __privateSet(
          this,
          _gcTimeout,
          setTimeout(() => {
            this.optionalRemove();
          }, this.gcTime),
        );
      }
    }
    updateGcTime(newGcTime) {
      this.gcTime = Math.max(
        this.gcTime || 0,
        newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3),
      );
    }
    clearGcTimeout() {
      if (__privateGet(this, _gcTimeout)) {
        clearTimeout(__privateGet(this, _gcTimeout));
        __privateSet(this, _gcTimeout, void 0);
      }
    }
  }),
  (_gcTimeout = new WeakMap()),
  _d);
var Query =
  ((_e = class extends Removable {
    constructor(config) {
      super();
      __privateAdd(this, _Query_instances);
      __privateAdd(this, _initialState);
      __privateAdd(this, _revertState);
      __privateAdd(this, _cache);
      __privateAdd(this, _client);
      __privateAdd(this, _retryer);
      __privateAdd(this, _defaultOptions);
      __privateAdd(this, _abortSignalConsumed);
      __privateSet(this, _abortSignalConsumed, false);
      __privateSet(this, _defaultOptions, config.defaultOptions);
      this.setOptions(config.options);
      this.observers = [];
      __privateSet(this, _client, config.client);
      __privateSet(this, _cache, __privateGet(this, _client).getQueryCache());
      this.queryKey = config.queryKey;
      this.queryHash = config.queryHash;
      __privateSet(this, _initialState, getDefaultState$1(this.options));
      this.state = config.state ?? __privateGet(this, _initialState);
      this.scheduleGc();
    }
    get meta() {
      return this.options.meta;
    }
    get promise() {
      var _a2;
      return (_a2 = __privateGet(this, _retryer)) == null
        ? void 0
        : _a2.promise;
    }
    setOptions(options) {
      this.options = { ...__privateGet(this, _defaultOptions), ...options };
      this.updateGcTime(this.options.gcTime);
    }
    optionalRemove() {
      if (!this.observers.length && this.state.fetchStatus === "idle") {
        __privateGet(this, _cache).remove(this);
      }
    }
    setData(newData, options) {
      const data = replaceData(this.state.data, newData, this.options);
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
        data,
        type: "success",
        dataUpdatedAt: options == null ? void 0 : options.updatedAt,
        manual: options == null ? void 0 : options.manual,
      });
      return data;
    }
    setState(state, setStateOptions) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
        type: "setState",
        state,
        setStateOptions,
      });
    }
    cancel(options) {
      var _a2, _b2;
      const promise =
        (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
      (_b2 = __privateGet(this, _retryer)) == null
        ? void 0
        : _b2.cancel(options);
      return promise ? promise.then(noop$1).catch(noop$1) : Promise.resolve();
    }
    destroy() {
      super.destroy();
      this.cancel({ silent: true });
    }
    reset() {
      this.destroy();
      this.setState(__privateGet(this, _initialState));
    }
    isActive() {
      return this.observers.some(
        (observer) => resolveEnabled(observer.options.enabled, this) !== false,
      );
    }
    isDisabled() {
      if (this.getObserversCount() > 0) {
        return !this.isActive();
      }
      return (
        this.options.queryFn === skipToken ||
        this.state.dataUpdateCount + this.state.errorUpdateCount === 0
      );
    }
    isStale() {
      if (this.state.isInvalidated) {
        return true;
      }
      if (this.getObserversCount() > 0) {
        return this.observers.some(
          (observer) => observer.getCurrentResult().isStale,
        );
      }
      return this.state.data === void 0;
    }
    isStaleByTime(staleTime = 0) {
      return (
        this.state.isInvalidated ||
        this.state.data === void 0 ||
        !timeUntilStale(this.state.dataUpdatedAt, staleTime)
      );
    }
    onFocus() {
      var _a2;
      const observer = this.observers.find((x2) =>
        x2.shouldFetchOnWindowFocus(),
      );
      observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
      (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
    }
    onOnline() {
      var _a2;
      const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
      observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
      (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
    }
    addObserver(observer) {
      if (!this.observers.includes(observer)) {
        this.observers.push(observer);
        this.clearGcTimeout();
        __privateGet(this, _cache).notify({
          type: "observerAdded",
          query: this,
          observer,
        });
      }
    }
    removeObserver(observer) {
      if (this.observers.includes(observer)) {
        this.observers = this.observers.filter((x2) => x2 !== observer);
        if (!this.observers.length) {
          if (__privateGet(this, _retryer)) {
            if (__privateGet(this, _abortSignalConsumed)) {
              __privateGet(this, _retryer).cancel({ revert: true });
            } else {
              __privateGet(this, _retryer).cancelRetry();
            }
          }
          this.scheduleGc();
        }
        __privateGet(this, _cache).notify({
          type: "observerRemoved",
          query: this,
          observer,
        });
      }
    }
    getObserversCount() {
      return this.observers.length;
    }
    invalidate() {
      if (!this.state.isInvalidated) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
          type: "invalidate",
        });
      }
    }
    fetch(options, fetchOptions) {
      var _a2, _b2, _c2;
      if (this.state.fetchStatus !== "idle") {
        if (
          this.state.data !== void 0 &&
          (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)
        ) {
          this.cancel({ silent: true });
        } else if (__privateGet(this, _retryer)) {
          __privateGet(this, _retryer).continueRetry();
          return __privateGet(this, _retryer).promise;
        }
      }
      if (options) {
        this.setOptions(options);
      }
      if (!this.options.queryFn) {
        const observer = this.observers.find((x2) => x2.options.queryFn);
        if (observer) {
          this.setOptions(observer.options);
        }
      }
      const abortController = new AbortController();
      const addSignalProperty = (object) => {
        Object.defineProperty(object, "signal", {
          enumerable: true,
          get: () => {
            __privateSet(this, _abortSignalConsumed, true);
            return abortController.signal;
          },
        });
      };
      const fetchFn = () => {
        const queryFn = ensureQueryFn(this.options, fetchOptions);
        const queryFnContext = {
          client: __privateGet(this, _client),
          queryKey: this.queryKey,
          meta: this.meta,
        };
        addSignalProperty(queryFnContext);
        __privateSet(this, _abortSignalConsumed, false);
        if (this.options.persister) {
          return this.options.persister(queryFn, queryFnContext, this);
        }
        return queryFn(queryFnContext);
      };
      const context = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        client: __privateGet(this, _client),
        state: this.state,
        fetchFn,
      };
      addSignalProperty(context);
      (_a2 = this.options.behavior) == null
        ? void 0
        : _a2.onFetch(context, this);
      __privateSet(this, _revertState, this.state);
      if (
        this.state.fetchStatus === "idle" ||
        this.state.fetchMeta !==
          ((_b2 = context.fetchOptions) == null ? void 0 : _b2.meta)
      ) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
          type: "fetch",
          meta: (_c2 = context.fetchOptions) == null ? void 0 : _c2.meta,
        });
      }
      const onError = (error) => {
        var _a3, _b3, _c3, _d2;
        if (!(isCancelledError(error) && error.silent)) {
          __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
            type: "error",
            error,
          });
        }
        if (!isCancelledError(error)) {
          (_b3 = (_a3 = __privateGet(this, _cache).config).onError) == null
            ? void 0
            : _b3.call(_a3, error, this);
          (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null
            ? void 0
            : _d2.call(_c3, this.state.data, error, this);
        }
        this.scheduleGc();
      };
      __privateSet(
        this,
        _retryer,
        createRetryer({
          initialPromise:
            fetchOptions == null ? void 0 : fetchOptions.initialPromise,
          fn: context.fetchFn,
          abort: abortController.abort.bind(abortController),
          onSuccess: (data) => {
            var _a3, _b3, _c3, _d2;
            if (data === void 0) {
              onError(new Error(`${this.queryHash} data is undefined`));
              return;
            }
            try {
              this.setData(data);
            } catch (error) {
              onError(error);
              return;
            }
            (_b3 = (_a3 = __privateGet(this, _cache).config).onSuccess) == null
              ? void 0
              : _b3.call(_a3, data, this);
            (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null
              ? void 0
              : _d2.call(_c3, data, this.state.error, this);
            this.scheduleGc();
          },
          onError,
          onFail: (failureCount, error) => {
            __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
              type: "failed",
              failureCount,
              error,
            });
          },
          onPause: () => {
            __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
              type: "pause",
            });
          },
          onContinue: () => {
            __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
              type: "continue",
            });
          },
          retry: context.options.retry,
          retryDelay: context.options.retryDelay,
          networkMode: context.options.networkMode,
          canRun: () => true,
        }),
      );
      return __privateGet(this, _retryer).start();
    }
  }),
  (_initialState = new WeakMap()),
  (_revertState = new WeakMap()),
  (_cache = new WeakMap()),
  (_client = new WeakMap()),
  (_retryer = new WeakMap()),
  (_defaultOptions = new WeakMap()),
  (_abortSignalConsumed = new WeakMap()),
  (_Query_instances = new WeakSet()),
  (dispatch_fn = function (action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error,
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused",
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching",
          };
        case "fetch":
          return {
            ...state,
            ...fetchState(state.data, this.options),
            fetchMeta: action.meta ?? null,
          };
        case "success":
          return {
            ...state,
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
            error: null,
            isInvalidated: false,
            status: "success",
            ...(!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null,
            }),
          };
        case "error":
          const error = action.error;
          if (
            isCancelledError(error) &&
            error.revert &&
            __privateGet(this, _revertState)
          ) {
            return { ...__privateGet(this, _revertState), fetchStatus: "idle" };
          }
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error",
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true,
          };
        case "setState":
          return {
            ...state,
            ...action.state,
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate();
      });
      __privateGet(this, _cache).notify({
        query: this,
        type: "updated",
        action,
      });
    });
  }),
  _e);
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...(data === void 0 && {
      error: null,
      status: "pending",
    }),
  };
}
function getDefaultState$1(options) {
  const data =
    typeof options.initialData === "function"
      ? options.initialData()
      : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData
    ? typeof options.initialDataUpdatedAt === "function"
      ? options.initialDataUpdatedAt()
      : options.initialDataUpdatedAt
    : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle",
  };
}
var QueryCache =
  ((_f = class extends Subscribable {
    constructor(config = {}) {
      super();
      __privateAdd(this, _queries);
      this.config = config;
      __privateSet(this, _queries, /* @__PURE__ */ new Map());
    }
    build(client, options, state) {
      const queryKey = options.queryKey;
      const queryHash =
        options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
      let query = this.get(queryHash);
      if (!query) {
        query = new Query({
          client,
          queryKey,
          queryHash,
          options: client.defaultQueryOptions(options),
          state,
          defaultOptions: client.getQueryDefaults(queryKey),
        });
        this.add(query);
      }
      return query;
    }
    add(query) {
      if (!__privateGet(this, _queries).has(query.queryHash)) {
        __privateGet(this, _queries).set(query.queryHash, query);
        this.notify({
          type: "added",
          query,
        });
      }
    }
    remove(query) {
      const queryInMap = __privateGet(this, _queries).get(query.queryHash);
      if (queryInMap) {
        query.destroy();
        if (queryInMap === query) {
          __privateGet(this, _queries).delete(query.queryHash);
        }
        this.notify({ type: "removed", query });
      }
    }
    clear() {
      notifyManager.batch(() => {
        this.getAll().forEach((query) => {
          this.remove(query);
        });
      });
    }
    get(queryHash) {
      return __privateGet(this, _queries).get(queryHash);
    }
    getAll() {
      return [...__privateGet(this, _queries).values()];
    }
    find(filters) {
      const defaultedFilters = { exact: true, ...filters };
      return this.getAll().find((query) => matchQuery(defaultedFilters, query));
    }
    findAll(filters = {}) {
      const queries = this.getAll();
      return Object.keys(filters).length > 0
        ? queries.filter((query) => matchQuery(filters, query))
        : queries;
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach((listener) => {
          listener(event);
        });
      });
    }
    onFocus() {
      notifyManager.batch(() => {
        this.getAll().forEach((query) => {
          query.onFocus();
        });
      });
    }
    onOnline() {
      notifyManager.batch(() => {
        this.getAll().forEach((query) => {
          query.onOnline();
        });
      });
    }
  }),
  (_queries = new WeakMap()),
  _f);
var Mutation =
  ((_g = class extends Removable {
    constructor(config) {
      super();
      __privateAdd(this, _Mutation_instances);
      __privateAdd(this, _observers);
      __privateAdd(this, _mutationCache);
      __privateAdd(this, _retryer2);
      this.mutationId = config.mutationId;
      __privateSet(this, _mutationCache, config.mutationCache);
      __privateSet(this, _observers, []);
      this.state = config.state || getDefaultState();
      this.setOptions(config.options);
      this.scheduleGc();
    }
    setOptions(options) {
      this.options = options;
      this.updateGcTime(this.options.gcTime);
    }
    get meta() {
      return this.options.meta;
    }
    addObserver(observer) {
      if (!__privateGet(this, _observers).includes(observer)) {
        __privateGet(this, _observers).push(observer);
        this.clearGcTimeout();
        __privateGet(this, _mutationCache).notify({
          type: "observerAdded",
          mutation: this,
          observer,
        });
      }
    }
    removeObserver(observer) {
      __privateSet(
        this,
        _observers,
        __privateGet(this, _observers).filter((x2) => x2 !== observer),
      );
      this.scheduleGc();
      __privateGet(this, _mutationCache).notify({
        type: "observerRemoved",
        mutation: this,
        observer,
      });
    }
    optionalRemove() {
      if (!__privateGet(this, _observers).length) {
        if (this.state.status === "pending") {
          this.scheduleGc();
        } else {
          __privateGet(this, _mutationCache).remove(this);
        }
      }
    }
    continue() {
      var _a2;
      return (
        ((_a2 = __privateGet(this, _retryer2)) == null
          ? void 0
          : _a2.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
        this.execute(this.state.variables)
      );
    }
    async execute(variables) {
      var _a2,
        _b2,
        _c2,
        _d2,
        _e2,
        _f2,
        _g2,
        _h2,
        _i2,
        _j2,
        _k,
        _l,
        _m,
        _n2,
        _o,
        _p,
        _q,
        _r,
        _s,
        _t;
      __privateSet(
        this,
        _retryer2,
        createRetryer({
          fn: () => {
            if (!this.options.mutationFn) {
              return Promise.reject(new Error("No mutationFn found"));
            }
            return this.options.mutationFn(variables);
          },
          onFail: (failureCount, error) => {
            __privateMethod(this, _Mutation_instances, dispatch_fn2).call(
              this,
              { type: "failed", failureCount, error },
            );
          },
          onPause: () => {
            __privateMethod(this, _Mutation_instances, dispatch_fn2).call(
              this,
              { type: "pause" },
            );
          },
          onContinue: () => {
            __privateMethod(this, _Mutation_instances, dispatch_fn2).call(
              this,
              { type: "continue" },
            );
          },
          retry: this.options.retry ?? 0,
          retryDelay: this.options.retryDelay,
          networkMode: this.options.networkMode,
          canRun: () => __privateGet(this, _mutationCache).canRun(this),
        }),
      );
      const restored = this.state.status === "pending";
      const isPaused = !__privateGet(this, _retryer2).canStart();
      try {
        if (!restored) {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
            type: "pending",
            variables,
            isPaused,
          });
          await ((_b2 = (_a2 = __privateGet(this, _mutationCache).config)
            .onMutate) == null
            ? void 0
            : _b2.call(_a2, variables, this));
          const context = await ((_d2 = (_c2 = this.options).onMutate) == null
            ? void 0
            : _d2.call(_c2, variables));
          if (context !== this.state.context) {
            __privateMethod(this, _Mutation_instances, dispatch_fn2).call(
              this,
              {
                type: "pending",
                context,
                variables,
                isPaused,
              },
            );
          }
        }
        const data = await __privateGet(this, _retryer2).start();
        await ((_f2 = (_e2 = __privateGet(this, _mutationCache).config)
          .onSuccess) == null
          ? void 0
          : _f2.call(_e2, data, variables, this.state.context, this));
        await ((_h2 = (_g2 = this.options).onSuccess) == null
          ? void 0
          : _h2.call(_g2, data, variables, this.state.context));
        await ((_j2 = (_i2 = __privateGet(this, _mutationCache).config)
          .onSettled) == null
          ? void 0
          : _j2.call(
              _i2,
              data,
              null,
              this.state.variables,
              this.state.context,
              this,
            ));
        await ((_l = (_k = this.options).onSettled) == null
          ? void 0
          : _l.call(_k, data, null, variables, this.state.context));
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
          type: "success",
          data,
        });
        return data;
      } catch (error) {
        try {
          await ((_n2 = (_m = __privateGet(this, _mutationCache).config)
            .onError) == null
            ? void 0
            : _n2.call(_m, error, variables, this.state.context, this));
          await ((_p = (_o = this.options).onError) == null
            ? void 0
            : _p.call(_o, error, variables, this.state.context));
          await ((_r = (_q = __privateGet(this, _mutationCache).config)
            .onSettled) == null
            ? void 0
            : _r.call(
                _q,
                void 0,
                error,
                this.state.variables,
                this.state.context,
                this,
              ));
          await ((_t = (_s = this.options).onSettled) == null
            ? void 0
            : _t.call(_s, void 0, error, variables, this.state.context));
          throw error;
        } finally {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
            type: "error",
            error,
          });
        }
      } finally {
        __privateGet(this, _mutationCache).runNext(this);
      }
    }
  }),
  (_observers = new WeakMap()),
  (_mutationCache = new WeakMap()),
  (_retryer2 = new WeakMap()),
  (_Mutation_instances = new WeakSet()),
  (dispatch_fn2 = function (action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: action.failureCount,
            failureReason: action.error,
          };
        case "pause":
          return {
            ...state,
            isPaused: true,
          };
        case "continue":
          return {
            ...state,
            isPaused: false,
          };
        case "pending":
          return {
            ...state,
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: action.isPaused,
            status: "pending",
            variables: action.variables,
            submittedAt: Date.now(),
          };
        case "success":
          return {
            ...state,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false,
          };
        case "error":
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error",
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      __privateGet(this, _observers).forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      __privateGet(this, _mutationCache).notify({
        mutation: this,
        type: "updated",
        action,
      });
    });
  }),
  _g);
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0,
  };
}
var MutationCache =
  ((_h = class extends Subscribable {
    constructor(config = {}) {
      super();
      __privateAdd(this, _mutations);
      __privateAdd(this, _scopes);
      __privateAdd(this, _mutationId);
      this.config = config;
      __privateSet(this, _mutations, /* @__PURE__ */ new Set());
      __privateSet(this, _scopes, /* @__PURE__ */ new Map());
      __privateSet(this, _mutationId, 0);
    }
    build(client, options, state) {
      const mutation = new Mutation({
        mutationCache: this,
        mutationId: ++__privateWrapper(this, _mutationId)._,
        options: client.defaultMutationOptions(options),
        state,
      });
      this.add(mutation);
      return mutation;
    }
    add(mutation) {
      __privateGet(this, _mutations).add(mutation);
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const scopedMutations = __privateGet(this, _scopes).get(scope);
        if (scopedMutations) {
          scopedMutations.push(mutation);
        } else {
          __privateGet(this, _scopes).set(scope, [mutation]);
        }
      }
      this.notify({ type: "added", mutation });
    }
    remove(mutation) {
      if (__privateGet(this, _mutations).delete(mutation)) {
        const scope = scopeFor(mutation);
        if (typeof scope === "string") {
          const scopedMutations = __privateGet(this, _scopes).get(scope);
          if (scopedMutations) {
            if (scopedMutations.length > 1) {
              const index = scopedMutations.indexOf(mutation);
              if (index !== -1) {
                scopedMutations.splice(index, 1);
              }
            } else if (scopedMutations[0] === mutation) {
              __privateGet(this, _scopes).delete(scope);
            }
          }
        }
      }
      this.notify({ type: "removed", mutation });
    }
    canRun(mutation) {
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const mutationsWithSameScope = __privateGet(this, _scopes).get(scope);
        const firstPendingMutation =
          mutationsWithSameScope == null
            ? void 0
            : mutationsWithSameScope.find(
                (m2) => m2.state.status === "pending",
              );
        return !firstPendingMutation || firstPendingMutation === mutation;
      } else {
        return true;
      }
    }
    runNext(mutation) {
      var _a2;
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const foundMutation =
          (_a2 = __privateGet(this, _scopes).get(scope)) == null
            ? void 0
            : _a2.find((m2) => m2 !== mutation && m2.state.isPaused);
        return (
          (foundMutation == null ? void 0 : foundMutation.continue()) ??
          Promise.resolve()
        );
      } else {
        return Promise.resolve();
      }
    }
    clear() {
      notifyManager.batch(() => {
        __privateGet(this, _mutations).forEach((mutation) => {
          this.notify({ type: "removed", mutation });
        });
        __privateGet(this, _mutations).clear();
        __privateGet(this, _scopes).clear();
      });
    }
    getAll() {
      return Array.from(__privateGet(this, _mutations));
    }
    find(filters) {
      const defaultedFilters = { exact: true, ...filters };
      return this.getAll().find((mutation) =>
        matchMutation(defaultedFilters, mutation),
      );
    }
    findAll(filters = {}) {
      return this.getAll().filter((mutation) =>
        matchMutation(filters, mutation),
      );
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach((listener) => {
          listener(event);
        });
      });
    }
    resumePausedMutations() {
      const pausedMutations = this.getAll().filter((x2) => x2.state.isPaused);
      return notifyManager.batch(() =>
        Promise.all(
          pausedMutations.map((mutation) => mutation.continue().catch(noop$1)),
        ),
      );
    }
  }),
  (_mutations = new WeakMap()),
  (_scopes = new WeakMap()),
  (_mutationId = new WeakMap()),
  _h);
function scopeFor(mutation) {
  var _a2;
  return (_a2 = mutation.options.scope) == null ? void 0 : _a2.id;
}
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      var _a2, _b2, _c2, _d2, _e2;
      const options = context.options;
      const direction =
        (_c2 =
          (_b2 = (_a2 = context.fetchOptions) == null ? void 0 : _a2.meta) ==
          null
            ? void 0
            : _b2.fetchMore) == null
          ? void 0
          : _c2.direction;
      const oldPages =
        ((_d2 = context.state.data) == null ? void 0 : _d2.pages) || [];
      const oldPageParams =
        ((_e2 = context.state.data) == null ? void 0 : _e2.pageParams) || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            },
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const queryFnContext = {
            client: context.client,
            queryKey: context.queryKey,
            pageParam: param,
            direction: previous ? "backward" : "forward",
            meta: context.options.meta,
          };
          addSignalProperty(queryFnContext);
          const page = await queryFn(queryFnContext);
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages),
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous
            ? getPreviousPageParam
            : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams,
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param =
              currentPage === 0
                ? (oldPageParams[0] ?? options.initialPageParam)
                : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          var _a3, _b3;
          return (_b3 = (_a3 = context.options).persister) == null
            ? void 0
            : _b3.call(
                _a3,
                fetchFn,
                {
                  client: context.client,
                  queryKey: context.queryKey,
                  meta: context.options.meta,
                  signal: context.signal,
                },
                query,
              );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    },
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0
    ? options.getNextPageParam(
        pages[lastIndex],
        pages,
        pageParams[lastIndex],
        pageParams,
      )
    : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  var _a2;
  return pages.length > 0
    ? (_a2 = options.getPreviousPageParam) == null
      ? void 0
      : _a2.call(options, pages[0], pages, pageParams[0], pageParams)
    : void 0;
}
var QueryClient =
  ((_i = class {
    constructor(config = {}) {
      __privateAdd(this, _queryCache);
      __privateAdd(this, _mutationCache2);
      __privateAdd(this, _defaultOptions2);
      __privateAdd(this, _queryDefaults);
      __privateAdd(this, _mutationDefaults);
      __privateAdd(this, _mountCount);
      __privateAdd(this, _unsubscribeFocus);
      __privateAdd(this, _unsubscribeOnline);
      __privateSet(this, _queryCache, config.queryCache || new QueryCache());
      __privateSet(
        this,
        _mutationCache2,
        config.mutationCache || new MutationCache(),
      );
      __privateSet(this, _defaultOptions2, config.defaultOptions || {});
      __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
      __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
      __privateSet(this, _mountCount, 0);
    }
    mount() {
      __privateWrapper(this, _mountCount)._++;
      if (__privateGet(this, _mountCount) !== 1) return;
      __privateSet(
        this,
        _unsubscribeFocus,
        focusManager.subscribe(async (focused) => {
          if (focused) {
            await this.resumePausedMutations();
            __privateGet(this, _queryCache).onFocus();
          }
        }),
      );
      __privateSet(
        this,
        _unsubscribeOnline,
        onlineManager.subscribe(async (online) => {
          if (online) {
            await this.resumePausedMutations();
            __privateGet(this, _queryCache).onOnline();
          }
        }),
      );
    }
    unmount() {
      var _a2, _b2;
      __privateWrapper(this, _mountCount)._--;
      if (__privateGet(this, _mountCount) !== 0) return;
      (_a2 = __privateGet(this, _unsubscribeFocus)) == null
        ? void 0
        : _a2.call(this);
      __privateSet(this, _unsubscribeFocus, void 0);
      (_b2 = __privateGet(this, _unsubscribeOnline)) == null
        ? void 0
        : _b2.call(this);
      __privateSet(this, _unsubscribeOnline, void 0);
    }
    isFetching(filters) {
      return __privateGet(this, _queryCache).findAll({
        ...filters,
        fetchStatus: "fetching",
      }).length;
    }
    isMutating(filters) {
      return __privateGet(this, _mutationCache2).findAll({
        ...filters,
        status: "pending",
      }).length;
    }
    /**
     * Imperative (non-reactive) way to retrieve data for a QueryKey.
     * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
     *
     * Hint: Do not use this function inside a component, because it won't receive updates.
     * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
     */
    getQueryData(queryKey) {
      var _a2;
      const options = this.defaultQueryOptions({ queryKey });
      return (_a2 = __privateGet(this, _queryCache).get(options.queryHash)) ==
        null
        ? void 0
        : _a2.state.data;
    }
    ensureQueryData(options) {
      const defaultedOptions = this.defaultQueryOptions(options);
      const query = __privateGet(this, _queryCache).build(
        this,
        defaultedOptions,
      );
      const cachedData = query.state.data;
      if (cachedData === void 0) {
        return this.fetchQuery(options);
      }
      if (
        options.revalidateIfStale &&
        query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))
      ) {
        void this.prefetchQuery(defaultedOptions);
      }
      return Promise.resolve(cachedData);
    }
    getQueriesData(filters) {
      return __privateGet(this, _queryCache)
        .findAll(filters)
        .map(({ queryKey, state }) => {
          const data = state.data;
          return [queryKey, data];
        });
    }
    setQueryData(queryKey, updater, options) {
      const defaultedOptions = this.defaultQueryOptions({ queryKey });
      const query = __privateGet(this, _queryCache).get(
        defaultedOptions.queryHash,
      );
      const prevData = query == null ? void 0 : query.state.data;
      const data = functionalUpdate(updater, prevData);
      if (data === void 0) {
        return void 0;
      }
      return __privateGet(this, _queryCache)
        .build(this, defaultedOptions)
        .setData(data, { ...options, manual: true });
    }
    setQueriesData(filters, updater, options) {
      return notifyManager.batch(() =>
        __privateGet(this, _queryCache)
          .findAll(filters)
          .map(({ queryKey }) => [
            queryKey,
            this.setQueryData(queryKey, updater, options),
          ]),
      );
    }
    getQueryState(queryKey) {
      var _a2;
      const options = this.defaultQueryOptions({ queryKey });
      return (_a2 = __privateGet(this, _queryCache).get(options.queryHash)) ==
        null
        ? void 0
        : _a2.state;
    }
    removeQueries(filters) {
      const queryCache = __privateGet(this, _queryCache);
      notifyManager.batch(() => {
        queryCache.findAll(filters).forEach((query) => {
          queryCache.remove(query);
        });
      });
    }
    resetQueries(filters, options) {
      const queryCache = __privateGet(this, _queryCache);
      return notifyManager.batch(() => {
        queryCache.findAll(filters).forEach((query) => {
          query.reset();
        });
        return this.refetchQueries(
          {
            type: "active",
            ...filters,
          },
          options,
        );
      });
    }
    cancelQueries(filters, cancelOptions = {}) {
      const defaultedCancelOptions = { revert: true, ...cancelOptions };
      const promises = notifyManager.batch(() =>
        __privateGet(this, _queryCache)
          .findAll(filters)
          .map((query) => query.cancel(defaultedCancelOptions)),
      );
      return Promise.all(promises).then(noop$1).catch(noop$1);
    }
    invalidateQueries(filters, options = {}) {
      return notifyManager.batch(() => {
        __privateGet(this, _queryCache)
          .findAll(filters)
          .forEach((query) => {
            query.invalidate();
          });
        if ((filters == null ? void 0 : filters.refetchType) === "none") {
          return Promise.resolve();
        }
        return this.refetchQueries(
          {
            ...filters,
            type:
              (filters == null ? void 0 : filters.refetchType) ??
              (filters == null ? void 0 : filters.type) ??
              "active",
          },
          options,
        );
      });
    }
    refetchQueries(filters, options = {}) {
      const fetchOptions = {
        ...options,
        cancelRefetch: options.cancelRefetch ?? true,
      };
      const promises = notifyManager.batch(() =>
        __privateGet(this, _queryCache)
          .findAll(filters)
          .filter((query) => !query.isDisabled())
          .map((query) => {
            let promise = query.fetch(void 0, fetchOptions);
            if (!fetchOptions.throwOnError) {
              promise = promise.catch(noop$1);
            }
            return query.state.fetchStatus === "paused"
              ? Promise.resolve()
              : promise;
          }),
      );
      return Promise.all(promises).then(noop$1);
    }
    fetchQuery(options) {
      const defaultedOptions = this.defaultQueryOptions(options);
      if (defaultedOptions.retry === void 0) {
        defaultedOptions.retry = false;
      }
      const query = __privateGet(this, _queryCache).build(
        this,
        defaultedOptions,
      );
      return query.isStaleByTime(
        resolveStaleTime(defaultedOptions.staleTime, query),
      )
        ? query.fetch(defaultedOptions)
        : Promise.resolve(query.state.data);
    }
    prefetchQuery(options) {
      return this.fetchQuery(options).then(noop$1).catch(noop$1);
    }
    fetchInfiniteQuery(options) {
      options.behavior = infiniteQueryBehavior(options.pages);
      return this.fetchQuery(options);
    }
    prefetchInfiniteQuery(options) {
      return this.fetchInfiniteQuery(options).then(noop$1).catch(noop$1);
    }
    ensureInfiniteQueryData(options) {
      options.behavior = infiniteQueryBehavior(options.pages);
      return this.ensureQueryData(options);
    }
    resumePausedMutations() {
      if (onlineManager.isOnline()) {
        return __privateGet(this, _mutationCache2).resumePausedMutations();
      }
      return Promise.resolve();
    }
    getQueryCache() {
      return __privateGet(this, _queryCache);
    }
    getMutationCache() {
      return __privateGet(this, _mutationCache2);
    }
    getDefaultOptions() {
      return __privateGet(this, _defaultOptions2);
    }
    setDefaultOptions(options) {
      __privateSet(this, _defaultOptions2, options);
    }
    setQueryDefaults(queryKey, options) {
      __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
        queryKey,
        defaultOptions: options,
      });
    }
    getQueryDefaults(queryKey) {
      const defaults = [...__privateGet(this, _queryDefaults).values()];
      const result = {};
      defaults.forEach((queryDefault) => {
        if (partialMatchKey(queryKey, queryDefault.queryKey)) {
          Object.assign(result, queryDefault.defaultOptions);
        }
      });
      return result;
    }
    setMutationDefaults(mutationKey, options) {
      __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
        mutationKey,
        defaultOptions: options,
      });
    }
    getMutationDefaults(mutationKey) {
      const defaults = [...__privateGet(this, _mutationDefaults).values()];
      const result = {};
      defaults.forEach((queryDefault) => {
        if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
          Object.assign(result, queryDefault.defaultOptions);
        }
      });
      return result;
    }
    defaultQueryOptions(options) {
      if (options._defaulted) {
        return options;
      }
      const defaultedOptions = {
        ...__privateGet(this, _defaultOptions2).queries,
        ...this.getQueryDefaults(options.queryKey),
        ...options,
        _defaulted: true,
      };
      if (!defaultedOptions.queryHash) {
        defaultedOptions.queryHash = hashQueryKeyByOptions(
          defaultedOptions.queryKey,
          defaultedOptions,
        );
      }
      if (defaultedOptions.refetchOnReconnect === void 0) {
        defaultedOptions.refetchOnReconnect =
          defaultedOptions.networkMode !== "always";
      }
      if (defaultedOptions.throwOnError === void 0) {
        defaultedOptions.throwOnError = !!defaultedOptions.suspense;
      }
      if (!defaultedOptions.networkMode && defaultedOptions.persister) {
        defaultedOptions.networkMode = "offlineFirst";
      }
      if (defaultedOptions.queryFn === skipToken) {
        defaultedOptions.enabled = false;
      }
      return defaultedOptions;
    }
    defaultMutationOptions(options) {
      if (options == null ? void 0 : options._defaulted) {
        return options;
      }
      return {
        ...__privateGet(this, _defaultOptions2).mutations,
        ...((options == null ? void 0 : options.mutationKey) &&
          this.getMutationDefaults(options.mutationKey)),
        ...options,
        _defaulted: true,
      };
    }
    clear() {
      __privateGet(this, _queryCache).clear();
      __privateGet(this, _mutationCache2).clear();
    }
  }),
  (_queryCache = new WeakMap()),
  (_mutationCache2 = new WeakMap()),
  (_defaultOptions2 = new WeakMap()),
  (_queryDefaults = new WeakMap()),
  (_mutationDefaults = new WeakMap()),
  (_mountCount = new WeakMap()),
  (_unsubscribeFocus = new WeakMap()),
  (_unsubscribeOnline = new WeakMap()),
  _i);
var QueryObserver =
  ((_j = class extends Subscribable {
    constructor(client, options) {
      super();
      __privateAdd(this, _QueryObserver_instances);
      __privateAdd(this, _client2);
      __privateAdd(this, _currentQuery);
      __privateAdd(this, _currentQueryInitialState);
      __privateAdd(this, _currentResult);
      __privateAdd(this, _currentResultState);
      __privateAdd(this, _currentResultOptions);
      __privateAdd(this, _currentThenable);
      __privateAdd(this, _selectError);
      __privateAdd(this, _selectFn);
      __privateAdd(this, _selectResult);
      // This property keeps track of the last query with defined data.
      // It will be used to pass the previous data and query to the placeholder function between renders.
      __privateAdd(this, _lastQueryWithDefinedData);
      __privateAdd(this, _staleTimeoutId);
      __privateAdd(this, _refetchIntervalId);
      __privateAdd(this, _currentRefetchInterval);
      __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());
      this.options = options;
      __privateSet(this, _client2, client);
      __privateSet(this, _selectError, null);
      __privateSet(this, _currentThenable, pendingThenable());
      if (!this.options.experimental_prefetchInRender) {
        __privateGet(this, _currentThenable).reject(
          new Error(
            "experimental_prefetchInRender feature flag is not enabled",
          ),
        );
      }
      this.bindMethods();
      this.setOptions(options);
    }
    bindMethods() {
      this.refetch = this.refetch.bind(this);
    }
    onSubscribe() {
      if (this.listeners.size === 1) {
        __privateGet(this, _currentQuery).addObserver(this);
        if (
          shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)
        ) {
          __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(
            this,
          );
        } else {
          this.updateResult();
        }
        __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(
          this,
        );
      }
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        this.destroy();
      }
    }
    shouldFetchOnReconnect() {
      return shouldFetchOn(
        __privateGet(this, _currentQuery),
        this.options,
        this.options.refetchOnReconnect,
      );
    }
    shouldFetchOnWindowFocus() {
      return shouldFetchOn(
        __privateGet(this, _currentQuery),
        this.options,
        this.options.refetchOnWindowFocus,
      );
    }
    destroy() {
      this.listeners = /* @__PURE__ */ new Set();
      __privateMethod(
        this,
        _QueryObserver_instances,
        clearStaleTimeout_fn,
      ).call(this);
      __privateMethod(
        this,
        _QueryObserver_instances,
        clearRefetchInterval_fn,
      ).call(this);
      __privateGet(this, _currentQuery).removeObserver(this);
    }
    setOptions(options) {
      const prevOptions = this.options;
      const prevQuery = __privateGet(this, _currentQuery);
      this.options = __privateGet(this, _client2).defaultQueryOptions(options);
      if (
        this.options.enabled !== void 0 &&
        typeof this.options.enabled !== "boolean" &&
        typeof this.options.enabled !== "function" &&
        typeof resolveEnabled(
          this.options.enabled,
          __privateGet(this, _currentQuery),
        ) !== "boolean"
      ) {
        throw new Error(
          "Expected enabled to be a boolean or a callback that returns a boolean",
        );
      }
      __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(
        this,
      );
      __privateGet(this, _currentQuery).setOptions(this.options);
      if (
        prevOptions._defaulted &&
        !shallowEqualObjects(this.options, prevOptions)
      ) {
        __privateGet(this, _client2)
          .getQueryCache()
          .notify({
            type: "observerOptionsUpdated",
            query: __privateGet(this, _currentQuery),
            observer: this,
          });
      }
      const mounted = this.hasListeners();
      if (
        mounted &&
        shouldFetchOptionally(
          __privateGet(this, _currentQuery),
          prevQuery,
          this.options,
          prevOptions,
        )
      ) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(
          this,
        );
      }
      this.updateResult();
      if (
        mounted &&
        (__privateGet(this, _currentQuery) !== prevQuery ||
          resolveEnabled(
            this.options.enabled,
            __privateGet(this, _currentQuery),
          ) !==
            resolveEnabled(
              prevOptions.enabled,
              __privateGet(this, _currentQuery),
            ) ||
          resolveStaleTime(
            this.options.staleTime,
            __privateGet(this, _currentQuery),
          ) !==
            resolveStaleTime(
              prevOptions.staleTime,
              __privateGet(this, _currentQuery),
            ))
      ) {
        __privateMethod(
          this,
          _QueryObserver_instances,
          updateStaleTimeout_fn,
        ).call(this);
      }
      const nextRefetchInterval = __privateMethod(
        this,
        _QueryObserver_instances,
        computeRefetchInterval_fn,
      ).call(this);
      if (
        mounted &&
        (__privateGet(this, _currentQuery) !== prevQuery ||
          resolveEnabled(
            this.options.enabled,
            __privateGet(this, _currentQuery),
          ) !==
            resolveEnabled(
              prevOptions.enabled,
              __privateGet(this, _currentQuery),
            ) ||
          nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))
      ) {
        __privateMethod(
          this,
          _QueryObserver_instances,
          updateRefetchInterval_fn,
        ).call(this, nextRefetchInterval);
      }
    }
    getOptimisticResult(options) {
      const query = __privateGet(this, _client2)
        .getQueryCache()
        .build(__privateGet(this, _client2), options);
      const result = this.createResult(query, options);
      if (shouldAssignObserverCurrentProperties(this, result)) {
        __privateSet(this, _currentResult, result);
        __privateSet(this, _currentResultOptions, this.options);
        __privateSet(
          this,
          _currentResultState,
          __privateGet(this, _currentQuery).state,
        );
      }
      return result;
    }
    getCurrentResult() {
      return __privateGet(this, _currentResult);
    }
    trackResult(result, onPropTracked) {
      const trackedResult = {};
      Object.keys(result).forEach((key) => {
        Object.defineProperty(trackedResult, key, {
          configurable: false,
          enumerable: true,
          get: () => {
            this.trackProp(key);
            onPropTracked == null ? void 0 : onPropTracked(key);
            return result[key];
          },
        });
      });
      return trackedResult;
    }
    trackProp(key) {
      __privateGet(this, _trackedProps).add(key);
    }
    getCurrentQuery() {
      return __privateGet(this, _currentQuery);
    }
    refetch({ ...options } = {}) {
      return this.fetch({
        ...options,
      });
    }
    fetchOptimistic(options) {
      const defaultedOptions = __privateGet(this, _client2).defaultQueryOptions(
        options,
      );
      const query = __privateGet(this, _client2)
        .getQueryCache()
        .build(__privateGet(this, _client2), defaultedOptions);
      return query
        .fetch()
        .then(() => this.createResult(query, defaultedOptions));
    }
    fetch(fetchOptions) {
      return __privateMethod(this, _QueryObserver_instances, executeFetch_fn)
        .call(this, {
          ...fetchOptions,
          cancelRefetch: fetchOptions.cancelRefetch ?? true,
        })
        .then(() => {
          this.updateResult();
          return __privateGet(this, _currentResult);
        });
    }
    createResult(query, options) {
      var _a2;
      const prevQuery = __privateGet(this, _currentQuery);
      const prevOptions = this.options;
      const prevResult = __privateGet(this, _currentResult);
      const prevResultState = __privateGet(this, _currentResultState);
      const prevResultOptions = __privateGet(this, _currentResultOptions);
      const queryChange = query !== prevQuery;
      const queryInitialState = queryChange
        ? query.state
        : __privateGet(this, _currentQueryInitialState);
      const { state } = query;
      let newState = { ...state };
      let isPlaceholderData = false;
      let data;
      if (options._optimisticResults) {
        const mounted = this.hasListeners();
        const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
        const fetchOptionally =
          mounted &&
          shouldFetchOptionally(query, prevQuery, options, prevOptions);
        if (fetchOnMount || fetchOptionally) {
          newState = {
            ...newState,
            ...fetchState(state.data, query.options),
          };
        }
        if (options._optimisticResults === "isRestoring") {
          newState.fetchStatus = "idle";
        }
      }
      let { error, errorUpdatedAt, status } = newState;
      if (options.select && newState.data !== void 0) {
        if (
          prevResult &&
          newState.data ===
            (prevResultState == null ? void 0 : prevResultState.data) &&
          options.select === __privateGet(this, _selectFn)
        ) {
          data = __privateGet(this, _selectResult);
        } else {
          try {
            __privateSet(this, _selectFn, options.select);
            data = options.select(newState.data);
            data = replaceData(
              prevResult == null ? void 0 : prevResult.data,
              data,
              options,
            );
            __privateSet(this, _selectResult, data);
            __privateSet(this, _selectError, null);
          } catch (selectError) {
            __privateSet(this, _selectError, selectError);
          }
        }
      } else {
        data = newState.data;
      }
      if (
        options.placeholderData !== void 0 &&
        data === void 0 &&
        status === "pending"
      ) {
        let placeholderData;
        if (
          (prevResult == null ? void 0 : prevResult.isPlaceholderData) &&
          options.placeholderData ===
            (prevResultOptions == null
              ? void 0
              : prevResultOptions.placeholderData)
        ) {
          placeholderData = prevResult.data;
        } else {
          placeholderData =
            typeof options.placeholderData === "function"
              ? options.placeholderData(
                  (_a2 = __privateGet(this, _lastQueryWithDefinedData)) == null
                    ? void 0
                    : _a2.state.data,
                  __privateGet(this, _lastQueryWithDefinedData),
                )
              : options.placeholderData;
          if (options.select && placeholderData !== void 0) {
            try {
              placeholderData = options.select(placeholderData);
              __privateSet(this, _selectError, null);
            } catch (selectError) {
              __privateSet(this, _selectError, selectError);
            }
          }
        }
        if (placeholderData !== void 0) {
          status = "success";
          data = replaceData(
            prevResult == null ? void 0 : prevResult.data,
            placeholderData,
            options,
          );
          isPlaceholderData = true;
        }
      }
      if (__privateGet(this, _selectError)) {
        error = __privateGet(this, _selectError);
        data = __privateGet(this, _selectResult);
        errorUpdatedAt = Date.now();
        status = "error";
      }
      const isFetching = newState.fetchStatus === "fetching";
      const isPending = status === "pending";
      const isError = status === "error";
      const isLoading = isPending && isFetching;
      const hasData = data !== void 0;
      const result = {
        status,
        fetchStatus: newState.fetchStatus,
        isPending,
        isSuccess: status === "success",
        isError,
        isInitialLoading: isLoading,
        isLoading,
        data,
        dataUpdatedAt: newState.dataUpdatedAt,
        error,
        errorUpdatedAt,
        failureCount: newState.fetchFailureCount,
        failureReason: newState.fetchFailureReason,
        errorUpdateCount: newState.errorUpdateCount,
        isFetched:
          newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
        isFetchedAfterMount:
          newState.dataUpdateCount > queryInitialState.dataUpdateCount ||
          newState.errorUpdateCount > queryInitialState.errorUpdateCount,
        isFetching,
        isRefetching: isFetching && !isPending,
        isLoadingError: isError && !hasData,
        isPaused: newState.fetchStatus === "paused",
        isPlaceholderData,
        isRefetchError: isError && hasData,
        isStale: isStale(query, options),
        refetch: this.refetch,
        promise: __privateGet(this, _currentThenable),
      };
      const nextResult = result;
      if (this.options.experimental_prefetchInRender) {
        const finalizeThenableIfPossible = (thenable) => {
          if (nextResult.status === "error") {
            thenable.reject(nextResult.error);
          } else if (nextResult.data !== void 0) {
            thenable.resolve(nextResult.data);
          }
        };
        const recreateThenable = () => {
          const pending = __privateSet(
            this,
            _currentThenable,
            (nextResult.promise = pendingThenable()),
          );
          finalizeThenableIfPossible(pending);
        };
        const prevThenable = __privateGet(this, _currentThenable);
        switch (prevThenable.status) {
          case "pending":
            if (query.queryHash === prevQuery.queryHash) {
              finalizeThenableIfPossible(prevThenable);
            }
            break;
          case "fulfilled":
            if (
              nextResult.status === "error" ||
              nextResult.data !== prevThenable.value
            ) {
              recreateThenable();
            }
            break;
          case "rejected":
            if (
              nextResult.status !== "error" ||
              nextResult.error !== prevThenable.reason
            ) {
              recreateThenable();
            }
            break;
        }
      }
      return nextResult;
    }
    updateResult() {
      const prevResult = __privateGet(this, _currentResult);
      const nextResult = this.createResult(
        __privateGet(this, _currentQuery),
        this.options,
      );
      __privateSet(
        this,
        _currentResultState,
        __privateGet(this, _currentQuery).state,
      );
      __privateSet(this, _currentResultOptions, this.options);
      if (__privateGet(this, _currentResultState).data !== void 0) {
        __privateSet(
          this,
          _lastQueryWithDefinedData,
          __privateGet(this, _currentQuery),
        );
      }
      if (shallowEqualObjects(nextResult, prevResult)) {
        return;
      }
      __privateSet(this, _currentResult, nextResult);
      const shouldNotifyListeners = () => {
        if (!prevResult) {
          return true;
        }
        const { notifyOnChangeProps } = this.options;
        const notifyOnChangePropsValue =
          typeof notifyOnChangeProps === "function"
            ? notifyOnChangeProps()
            : notifyOnChangeProps;
        if (
          notifyOnChangePropsValue === "all" ||
          (!notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size)
        ) {
          return true;
        }
        const includedProps = new Set(
          notifyOnChangePropsValue ?? __privateGet(this, _trackedProps),
        );
        if (this.options.throwOnError) {
          includedProps.add("error");
        }
        return Object.keys(__privateGet(this, _currentResult)).some((key) => {
          const typedKey = key;
          const changed =
            __privateGet(this, _currentResult)[typedKey] !==
            prevResult[typedKey];
          return changed && includedProps.has(typedKey);
        });
      };
      __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, {
        listeners: shouldNotifyListeners(),
      });
    }
    onQueryUpdate() {
      this.updateResult();
      if (this.hasListeners()) {
        __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(
          this,
        );
      }
    }
  }),
  (_client2 = new WeakMap()),
  (_currentQuery = new WeakMap()),
  (_currentQueryInitialState = new WeakMap()),
  (_currentResult = new WeakMap()),
  (_currentResultState = new WeakMap()),
  (_currentResultOptions = new WeakMap()),
  (_currentThenable = new WeakMap()),
  (_selectError = new WeakMap()),
  (_selectFn = new WeakMap()),
  (_selectResult = new WeakMap()),
  (_lastQueryWithDefinedData = new WeakMap()),
  (_staleTimeoutId = new WeakMap()),
  (_refetchIntervalId = new WeakMap()),
  (_currentRefetchInterval = new WeakMap()),
  (_trackedProps = new WeakMap()),
  (_QueryObserver_instances = new WeakSet()),
  (executeFetch_fn = function (fetchOptions) {
    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
    let promise = __privateGet(this, _currentQuery).fetch(
      this.options,
      fetchOptions,
    );
    if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
      promise = promise.catch(noop$1);
    }
    return promise;
  }),
  (updateStaleTimeout_fn = function () {
    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(
      this,
    );
    const staleTime = resolveStaleTime(
      this.options.staleTime,
      __privateGet(this, _currentQuery),
    );
    if (
      isServer ||
      __privateGet(this, _currentResult).isStale ||
      !isValidTimeout(staleTime)
    ) {
      return;
    }
    const time = timeUntilStale(
      __privateGet(this, _currentResult).dataUpdatedAt,
      staleTime,
    );
    const timeout = time + 1;
    __privateSet(
      this,
      _staleTimeoutId,
      setTimeout(() => {
        if (!__privateGet(this, _currentResult).isStale) {
          this.updateResult();
        }
      }, timeout),
    );
  }),
  (computeRefetchInterval_fn = function () {
    return (
      (typeof this.options.refetchInterval === "function"
        ? this.options.refetchInterval(__privateGet(this, _currentQuery))
        : this.options.refetchInterval) ?? false
    );
  }),
  (updateRefetchInterval_fn = function (nextInterval) {
    __privateMethod(
      this,
      _QueryObserver_instances,
      clearRefetchInterval_fn,
    ).call(this);
    __privateSet(this, _currentRefetchInterval, nextInterval);
    if (
      isServer ||
      resolveEnabled(
        this.options.enabled,
        __privateGet(this, _currentQuery),
      ) === false ||
      !isValidTimeout(__privateGet(this, _currentRefetchInterval)) ||
      __privateGet(this, _currentRefetchInterval) === 0
    ) {
      return;
    }
    __privateSet(
      this,
      _refetchIntervalId,
      setInterval(
        () => {
          if (
            this.options.refetchIntervalInBackground ||
            focusManager.isFocused()
          ) {
            __privateMethod(
              this,
              _QueryObserver_instances,
              executeFetch_fn,
            ).call(this);
          }
        },
        __privateGet(this, _currentRefetchInterval),
      ),
    );
  }),
  (updateTimers_fn = function () {
    __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(
      this,
    );
    __privateMethod(
      this,
      _QueryObserver_instances,
      updateRefetchInterval_fn,
    ).call(
      this,
      __privateMethod(
        this,
        _QueryObserver_instances,
        computeRefetchInterval_fn,
      ).call(this),
    );
  }),
  (clearStaleTimeout_fn = function () {
    if (__privateGet(this, _staleTimeoutId)) {
      clearTimeout(__privateGet(this, _staleTimeoutId));
      __privateSet(this, _staleTimeoutId, void 0);
    }
  }),
  (clearRefetchInterval_fn = function () {
    if (__privateGet(this, _refetchIntervalId)) {
      clearInterval(__privateGet(this, _refetchIntervalId));
      __privateSet(this, _refetchIntervalId, void 0);
    }
  }),
  (updateQuery_fn = function () {
    const query = __privateGet(this, _client2)
      .getQueryCache()
      .build(__privateGet(this, _client2), this.options);
    if (query === __privateGet(this, _currentQuery)) {
      return;
    }
    const prevQuery = __privateGet(this, _currentQuery);
    __privateSet(this, _currentQuery, query);
    __privateSet(this, _currentQueryInitialState, query.state);
    if (this.hasListeners()) {
      prevQuery == null ? void 0 : prevQuery.removeObserver(this);
      query.addObserver(this);
    }
  }),
  (notify_fn = function (notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(__privateGet(this, _currentResult));
        });
      }
      __privateGet(this, _client2)
        .getQueryCache()
        .notify({
          query: __privateGet(this, _currentQuery),
          type: "observerResultsUpdated",
        });
    });
  }),
  _j);
function shouldLoadOnMount(query, options) {
  return (
    resolveEnabled(options.enabled, query) !== false &&
    query.state.data === void 0 &&
    !(query.state.status === "error" && options.retryOnMount === false)
  );
}
function shouldFetchOnMount(query, options) {
  return (
    shouldLoadOnMount(query, options) ||
    (query.state.data !== void 0 &&
      shouldFetchOn(query, options, options.refetchOnMount))
  );
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || (value !== false && isStale(query, options));
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (
    (query !== prevQuery ||
      resolveEnabled(prevOptions.enabled, query) === false) &&
    (!options.suspense || query.state.status !== "error") &&
    isStale(query, options)
  );
}
function isStale(query, options) {
  return (
    resolveEnabled(options.enabled, query) !== false &&
    query.isStaleByTime(resolveStaleTime(options.staleTime, query))
  );
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}
var QueryClientContext = J$1(void 0);
var useQueryClient = (queryClient2) => {
  const client = x$1(QueryClientContext);
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};
var QueryClientProvider = ({ client, children }) => {
  y(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  return /* @__PURE__ */ u$5(QueryClientContext.Provider, {
    value: client,
    children,
  });
};
var IsRestoringContext = J$1(false);
var useIsRestoring = () => x$1(IsRestoringContext);
IsRestoringContext.Provider;
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    },
  };
}
var QueryErrorResetBoundaryContext = J$1(createValue());
var useQueryErrorResetBoundary = () => x$1(QueryErrorResetBoundaryContext);
function shouldThrowError(throwError, params) {
  if (typeof throwError === "function") {
    return throwError(...params);
  }
  return !!throwError;
}
function noop() {}
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (
    options.suspense ||
    options.throwOnError ||
    options.experimental_prefetchInRender
  ) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  y(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query,
  suspense,
}) => {
  return (
    result.isError &&
    !errorResetBoundary.isReset() &&
    !result.isFetching &&
    query &&
    ((suspense && result.data === void 0) ||
      shouldThrowError(throwOnError, [result.error, query]))
  );
};
var ensureSuspenseTimers = (defaultedOptions) => {
  const originalStaleTime = defaultedOptions.staleTime;
  if (defaultedOptions.suspense) {
    defaultedOptions.staleTime =
      typeof originalStaleTime === "function"
        ? (...args) => Math.max(originalStaleTime(...args), 1e3)
        : Math.max(originalStaleTime ?? 1e3, 1e3);
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);
    }
  }
};
var willFetch = (result, isRestoring) =>
  result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result) =>
  (defaultedOptions == null ? void 0 : defaultedOptions.suspense) &&
  result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) =>
  observer.fetchOptimistic(defaultedOptions).catch(() => {
    errorResetBoundary.clearReset();
  });
function useBaseQuery(options, Observer, queryClient2) {
  var _a2, _b2, _c2, _d2, _e2;
  const client = useQueryClient();
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = client.defaultQueryOptions(options);
  (_b2 =
    (_a2 = client.getDefaultOptions().queries) == null
      ? void 0
      : _a2._experimental_beforeQuery) == null
    ? void 0
    : _b2.call(_a2, defaultedOptions);
  defaultedOptions._optimisticResults = isRestoring
    ? "isRestoring"
    : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const isNewCacheEntry = !client
    .getQueryCache()
    .get(defaultedOptions.queryHash);
  const [observer] = h$2(() => new Observer(client, defaultedOptions));
  const result = observer.getOptimisticResult(defaultedOptions);
  const shouldSubscribe = !isRestoring && options.subscribed !== false;
  C(
    q$1(
      (onStoreChange) => {
        const unsubscribe = shouldSubscribe
          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))
          : noop;
        observer.updateResult();
        return unsubscribe;
      },
      [observer, shouldSubscribe],
    ),
    () => observer.getCurrentResult(),
  );
  y(() => {
    observer.setOptions(defaultedOptions);
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (
    getHasError({
      result,
      errorResetBoundary,
      throwOnError: defaultedOptions.throwOnError,
      query: client.getQueryCache().get(defaultedOptions.queryHash),
      suspense: defaultedOptions.suspense,
    })
  ) {
    throw result.error;
  }
  (_d2 =
    (_c2 = client.getDefaultOptions().queries) == null
      ? void 0
      : _c2._experimental_afterQuery) == null
    ? void 0
    : _d2.call(_c2, defaultedOptions, result);
  if (
    defaultedOptions.experimental_prefetchInRender &&
    !isServer &&
    willFetch(result, isRestoring)
  ) {
    const promise = isNewCacheEntry
      ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
        fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
      : // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
        (_e2 = client.getQueryCache().get(defaultedOptions.queryHash)) == null
        ? void 0
        : _e2.promise;
    promise == null
      ? void 0
      : promise.catch(noop).finally(() => {
          observer.updateResult();
        });
  }
  return !defaultedOptions.notifyOnChangeProps
    ? observer.trackResult(result)
    : result;
}
function useQuery(options, queryClient2) {
  return useBaseQuery(options, QueryObserver);
}
var dist$1 = {};
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist$1;
  hasRequiredDist$1 = 1;
  Object.defineProperty(dist$1, "__esModule", { value: true });
  dist$1.parse = parse;
  dist$1.serialize = serialize;
  const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
  const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
  const domainValueRegExp =
    /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  const __toString = Object.prototype.toString;
  const NullObject = /* @__PURE__ */ (() => {
    const C2 = function () {};
    C2.prototype = /* @__PURE__ */ Object.create(null);
    return C2;
  })();
  function parse(str, options) {
    const obj = new NullObject();
    const len = str.length;
    if (len < 2) return obj;
    const dec = (options == null ? void 0 : options.decode) || decode;
    let index = 0;
    do {
      const eqIdx = str.indexOf("=", index);
      if (eqIdx === -1) break;
      const colonIdx = str.indexOf(";", index);
      const endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      const keyStartIdx = startIndex(str, index, eqIdx);
      const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
      const key = str.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === void 0) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
        let valEndIdx = endIndex(str, endIdx, valStartIdx);
        const value = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max2) {
    do {
      const code = str.charCodeAt(index);
      if (code !== 32 && code !== 9) return index;
    } while (++index < max2);
    return max2;
  }
  function endIndex(str, index, min2) {
    while (index > min2) {
      const code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9) return index + 1;
    }
    return min2;
  }
  function serialize(name, val, options) {
    const enc =
      (options == null ? void 0 : options.encode) || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options) return str;
    if (options.maxAge !== void 0) {
      if (!Number.isInteger(options.maxAge)) {
        throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
      }
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain)) {
        throw new TypeError(`option domain is invalid: ${options.domain}`);
      }
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path)) {
        throw new TypeError(`option path is invalid: ${options.path}`);
      }
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (
        !isDate(options.expires) ||
        !Number.isFinite(options.expires.valueOf())
      ) {
        throw new TypeError(`option expires is invalid: ${options.expires}`);
      }
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
      str += "; HttpOnly";
    }
    if (options.secure) {
      str += "; Secure";
    }
    if (options.partitioned) {
      str += "; Partitioned";
    }
    if (options.priority) {
      const priority =
        typeof options.priority === "string"
          ? options.priority.toLowerCase()
          : void 0;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError(
            `option priority is invalid: ${options.priority}`,
          );
      }
    }
    if (options.sameSite) {
      const sameSite =
        typeof options.sameSite === "string"
          ? options.sameSite.toLowerCase()
          : options.sameSite;
      switch (sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError(
            `option sameSite is invalid: ${options.sameSite}`,
          );
      }
    }
    return str;
  }
  function decode(str) {
    if (str.indexOf("%") === -1) return str;
    try {
      return decodeURIComponent(str);
    } catch (e3) {
      return str;
    }
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
  return dist$1;
}
requireDist$1();
/**
 * react-router v7.5.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var PopStateEventType = "popstate";
function createBrowserHistory(options = {}) {
  function createBrowserLocation(window2, globalHistory) {
    let { pathname, search, hash } = window2.location;
    return createLocation(
      "",
      { pathname, search, hash },
      // state defaults to `null` because `window.history.state` does
      (globalHistory.state && globalHistory.state.usr) || null,
      (globalHistory.state && globalHistory.state.key) || "default",
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(
    createBrowserLocation,
    createBrowserHref,
    null,
    options,
  );
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e3) {}
  }
}
function createKey() {
  return Math.random().toString(36).substring(2, 10);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index,
  };
}
function createLocation(current, to, state = null, key) {
  let location = {
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: "",
    ...(typeof to === "string" ? parsePath(to) : to),
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: (to && to.key) || key || createKey(),
  };
  return location;
}
function createPath({ pathname = "/", search = "", hash = "" }) {
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substring(hashIndex);
      path = path.substring(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substring(searchIndex);
      path = path.substring(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(
  getLocation,
  createHref2,
  validateLocation,
  options = {},
) {
  let { window: window2 = document.defaultView, v5Compat = false } = options;
  let globalHistory = window2.history;
  let action = "POP";
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState({ ...globalHistory.state, idx: index }, "");
  }
  function getIndex() {
    let state = globalHistory.state || { idx: null };
    return state.idx;
  }
  function handlePop() {
    action = "POP";
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({ action, location: history.location, delta });
    }
  }
  function push(to, state) {
    action = "PUSH";
    let location = createLocation(history.location, to, state);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({ action, location: history.location, delta: 1 });
    }
  }
  function replace2(to, state) {
    action = "REPLACE";
    let location = createLocation(history.location, to, state);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({ action, location: history.location, delta: 0 });
    }
  }
  function createURL(to) {
    let base =
      window2.location.origin !== "null"
        ? window2.location.origin
        : window2.location.href;
    let href2 = typeof to === "string" ? to : createPath(to);
    href2 = href2.replace(/ $/, "%20");
    invariant(
      base,
      `No window.location.(origin|href) available to create URL for href: ${href2}`,
    );
    return new URL(href2, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn2) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn2;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref2(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash,
      };
    },
    push,
    replace: replace2,
    go(n3) {
      return globalHistory.go(n3);
    },
  };
  return history;
}
function matchRoutes(routes, locationArg, basename = "/") {
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location =
    typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i3 = 0; matches == null && i3 < branches.length; ++i3) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i3], decoded, allowPartial);
  }
  return matches;
}
function flattenRoutes(
  routes,
  branches = [],
  parentsMeta = [],
  parentPath = "",
) {
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route,
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(
        meta.relativePath.startsWith(parentPath),
        `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`,
      );
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        `Index routes must not have child routes. Please remove all child routes from route path "${path}".`,
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta,
    });
  };
  routes.forEach((route, index) => {
    var _a2;
    if (
      route.path === "" ||
      !((_a2 = route.path) == null ? void 0 : _a2.includes("?"))
    ) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(
    ...restExploded.map((subpath) =>
      subpath === "" ? required : [required, subpath].join("/"),
    ),
  );
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) =>
    path.startsWith("/") && exploded === "" ? "/" : exploded,
  );
}
function rankRouteBranches(branches) {
  branches.sort((a2, b3) =>
    a2.score !== b3.score
      ? b3.score - a2.score
      : compareIndexes(
          a2.routesMeta.map((meta) => meta.childrenIndex),
          b3.routesMeta.map((meta) => meta.childrenIndex),
        ),
  );
}
var paramRe = /^:[\w-]+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s2) => s2 === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments
    .filter((s2) => !isSplat(s2))
    .reduce(
      (score, segment) =>
        score +
        (paramRe.test(segment)
          ? dynamicSegmentValue
          : segment === ""
            ? emptySegmentValue
            : staticSegmentValue),
      initialScore,
    );
}
function compareIndexes(a2, b3) {
  let siblings =
    a2.length === b3.length && a2.slice(0, -1).every((n3, i3) => n3 === b3[i3]);
  return siblings
    ? // If two routes are siblings, we should try to match the earlier sibling
      // first. This allows people to have fine-grained control over the matching
      // behavior by simply putting routes with identical paths in the order they
      // want them tried.
      a2[a2.length - 1] - b3[b3.length - 1]
    : // Otherwise, it doesn't really make sense to rank non-siblings by index,
      // so they sort equally.
      0;
}
function matchRouteBranch(branch, pathname, allowPartial = false) {
  let { routesMeta } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i3 = 0; i3 < routesMeta.length; ++i3) {
    let meta = routesMeta[i3];
    let end = i3 === routesMeta.length - 1;
    let remainingPathname =
      matchedPathname === "/"
        ? pathname
        : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath(
      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
      remainingPathname,
    );
    let route = meta.route;
    if (
      !match &&
      end &&
      allowPartial &&
      !routesMeta[routesMeta.length - 1].route.index
    ) {
      match = matchPath(
        {
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: false,
        },
        remainingPathname,
      );
    }
    if (!match) {
      return null;
    }
    Object.assign(matchedParams, match.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(
        joinPaths([matchedPathname, match.pathnameBase]),
      ),
      route,
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = { path: pattern, caseSensitive: false, end: true };
  }
  let [matcher, compiledParams] = compilePath(
    pattern.path,
    pattern.caseSensitive,
    pattern.end,
  );
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce(
    (memo2, { paramName, isOptional }, index) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname
          .slice(0, matchedPathname.length - splatValue.length)
          .replace(/(.)\/+$/, "$1");
      }
      const value = captureGroups[index];
      if (isOptional && !value) {
        memo2[paramName] = void 0;
      } else {
        memo2[paramName] = (value || "").replace(/%2F/g, "/");
      }
      return memo2;
    },
    {},
  );
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern,
  };
}
function compilePath(path, caseSensitive = false, end = true) {
  warning(
    path === "*" || !path.endsWith("*") || path.endsWith("/*"),
    `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`,
  );
  let params = [];
  let regexpSource =
    "^" +
    path
      .replace(/\/*\*?$/, "")
      .replace(/^\/*/, "/")
      .replace(/[\\.*+^${}|()[\]]/g, "\\$&")
      .replace(/\/:([\w-]+)(\?)?/g, (_2, paramName, isOptional) => {
        params.push({ paramName, isOptional: isOptional != null });
        return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
      });
  if (path.endsWith("*")) {
    params.push({ paramName: "*" });
    regexpSource +=
      path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value
      .split("/")
      .map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F"))
      .join("/");
  } catch (error) {
    warning(
      false,
      `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`,
    );
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/")
    ? basename.length - 1
    : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname = "/") {
  let {
    pathname: toPathname,
    search = "",
    hash = "",
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname
    ? toPathname.startsWith("/")
      ? toPathname
      : resolvePathname(toPathname, fromPathname)
    : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash),
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
    path,
  )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function getPathContributingMatches(matches) {
  return matches.filter(
    (match, index) =>
      index === 0 || (match.route.path && match.route.path.length > 0),
  );
}
function getResolveToMatches(matches) {
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches.map((match, idx) =>
    idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase,
  );
}
function resolveTo(
  toArg,
  routePathnames,
  locationPathname,
  isPathRelative = false,
) {
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = { ...toArg };
    invariant(
      !to.pathname || !to.pathname.includes("?"),
      getInvalidPathError("?", "pathname", "search", to),
    );
    invariant(
      !to.pathname || !to.pathname.includes("#"),
      getInvalidPathError("#", "pathname", "hash", to),
    );
    invariant(
      !to.search || !to.search.includes("#"),
      getInvalidPathError("#", "search", "hash", to),
    );
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash =
    toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash =
    (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (
    !path.pathname.endsWith("/") &&
    (hasExplicitTrailingSlash || hasCurrentTrailingSlash)
  ) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) =>
  pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) =>
  !search || search === "?"
    ? ""
    : search.startsWith("?")
      ? search
      : "?" + search;
var normalizeHash = (hash) =>
  !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
function isRouteErrorResponse(error) {
  return (
    error != null &&
    typeof error.status === "number" &&
    typeof error.statusText === "string" &&
    typeof error.internal === "boolean" &&
    "data" in error
  );
}
var validMutationMethodsArr = ["POST", "PUT", "PATCH", "DELETE"];
new Set(validMutationMethodsArr);
var validRequestMethodsArr = ["GET", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
var DataRouterContext = J$1(null);
DataRouterContext.displayName = "DataRouter";
var DataRouterStateContext = J$1(null);
DataRouterStateContext.displayName = "DataRouterState";
var ViewTransitionContext = J$1({
  isTransitioning: false,
});
ViewTransitionContext.displayName = "ViewTransition";
var FetchersContext = J$1(/* @__PURE__ */ new Map());
FetchersContext.displayName = "Fetchers";
var AwaitContext = J$1(null);
AwaitContext.displayName = "Await";
var NavigationContext = J$1(null);
NavigationContext.displayName = "Navigation";
var LocationContext = J$1(null);
LocationContext.displayName = "Location";
var RouteContext = J$1({
  outlet: null,
  matches: [],
  isDataRoute: false,
});
RouteContext.displayName = "Route";
var RouteErrorContext = J$1(null);
RouteErrorContext.displayName = "RouteError";
function useHref(to, { relative } = {}) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useHref() may be used only in the context of a <Router> component.`,
  );
  let { basename, navigator: navigator2 } = x$1(NavigationContext);
  let { hash, pathname, search } = useResolvedPath(to, { relative });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname =
      pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({ pathname: joinedPathname, search, hash });
}
function useInRouterContext() {
  return x$1(LocationContext) != null;
}
function useLocation() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useLocation() may be used only in the context of a <Router> component.`,
  );
  return x$1(LocationContext).location;
}
var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
function useIsomorphicLayoutEffect(cb) {
  let isStatic = x$1(NavigationContext).static;
  if (!isStatic) {
    _(cb);
  }
}
function useNavigate() {
  let { isDataRoute } = x$1(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useNavigate() may be used only in the context of a <Router> component.`,
  );
  let dataRouterContext = x$1(DataRouterContext);
  let { basename, navigator: navigator2 } = x$1(NavigationContext);
  let { matches } = x$1(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  let activeRef = A$1(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = q$1(
    (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        navigator2.go(to);
        return;
      }
      let path = resolveTo(
        to,
        JSON.parse(routePathnamesJson),
        locationPathname,
        options.relative === "path",
      );
      if (dataRouterContext == null && basename !== "/") {
        path.pathname =
          path.pathname === "/"
            ? basename
            : joinPaths([basename, path.pathname]);
      }
      (!!options.replace ? navigator2.replace : navigator2.push)(
        path,
        options.state,
        options,
      );
    },
    [
      basename,
      navigator2,
      routePathnamesJson,
      locationPathname,
      dataRouterContext,
    ],
  );
  return navigate;
}
J$1(null);
function useParams() {
  let { matches } = x$1(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to, { relative } = {}) {
  let { matches } = x$1(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  return T$1(
    () =>
      resolveTo(
        to,
        JSON.parse(routePathnamesJson),
        locationPathname,
        relative === "path",
      ),
    [to, routePathnamesJson, locationPathname, relative],
  );
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  var _a2;
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useRoutes() may be used only in the context of a <Router> component.`,
  );
  let { navigator: navigator2, static: isStatic } = x$1(NavigationContext);
  let { matches: parentMatches } = x$1(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  {
    let parentPath = (parentRoute && parentRoute.path) || "";
    warningOnce(
      parentPathname,
      !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`,
    );
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    let parsedLocationArg =
      typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    invariant(
      parentPathnameBase === "/" ||
        ((_a2 = parsedLocationArg.pathname) == null
          ? void 0
          : _a2.startsWith(parentPathnameBase)),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`,
    );
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches =
    !isStatic &&
    dataRouterState &&
    dataRouterState.matches &&
    dataRouterState.matches.length > 0
      ? dataRouterState.matches
      : matchRoutes(routes, { pathname: remainingPathname });
  {
    warning(
      parentRoute || matches != null,
      `No routes matched location "${location.pathname}${location.search}${location.hash}" `,
    );
    warning(
      matches == null ||
        matches[matches.length - 1].route.element !== void 0 ||
        matches[matches.length - 1].route.Component !== void 0 ||
        matches[matches.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`,
    );
  }
  let renderedMatches = _renderMatches(
    matches &&
      matches.map((match) =>
        Object.assign({}, match, {
          params: Object.assign({}, parentParams, match.params),
          pathname: joinPaths([
            parentPathnameBase,
            // Re-encode pathnames that were decoded inside matchRoutes
            navigator2.encodeLocation
              ? navigator2.encodeLocation(match.pathname).pathname
              : match.pathname,
          ]),
          pathnameBase:
            match.pathnameBase === "/"
              ? parentPathnameBase
              : joinPaths([
                  parentPathnameBase,
                  // Re-encode pathnames that were decoded inside matchRoutes
                  navigator2.encodeLocation
                    ? navigator2.encodeLocation(match.pathnameBase).pathname
                    : match.pathnameBase,
                ]),
        }),
      ),
    parentMatches,
    dataRouterState,
    future,
  );
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ g$3(
      LocationContext.Provider,
      {
        value: {
          location: {
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default",
            ...location,
          },
          navigationType: "POP",
          /* Pop */
        },
      },
      renderedMatches,
    );
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error)
    ? `${error.status} ${error.statusText}`
    : error instanceof Error
      ? error.message
      : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
  let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
  let devInfo = null;
  {
    console.error(
      "Error handled by React Router default ErrorBoundary:",
      error,
    );
    devInfo = /* @__PURE__ */ g$3(
      k$3,
      null,
      /* @__PURE__ */ g$3("p", null, " Hey developer "),
      /* @__PURE__ */ g$3(
        "p",
        null,
        "You can provide a way better UX than this when your app throws errors by providing your own ",
        /* @__PURE__ */ g$3("code", { style: codeStyles }, "ErrorBoundary"),
        " or",
        " ",
        /* @__PURE__ */ g$3("code", { style: codeStyles }, "errorElement"),
        " prop on your route.",
      ),
    );
  }
  return /* @__PURE__ */ g$3(
    k$3,
    null,
    /* @__PURE__ */ g$3("h2", null, "Unexpected Application Error!"),
    /* @__PURE__ */ g$3("h3", { style: { fontStyle: "italic" } }, message),
    stack ? /* @__PURE__ */ g$3("pre", { style: preStyles }, stack) : null,
    devInfo,
  );
}
var defaultErrorElement = /* @__PURE__ */ g$3(DefaultErrorComponent, null);
var RenderErrorBoundary = class extends x$3 {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error,
    };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  static getDerivedStateFromProps(props, state) {
    if (
      state.location !== props.location ||
      (state.revalidation !== "idle" && props.revalidation === "idle")
    ) {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation,
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation,
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error(
      "React Router caught the following error during render",
      error,
      errorInfo,
    );
  }
  render() {
    return this.state.error !== void 0
      ? /* @__PURE__ */ g$3(
          RouteContext.Provider,
          { value: this.props.routeContext },
          /* @__PURE__ */ g$3(RouteErrorContext.Provider, {
            value: this.state.error,
            children: this.props.component,
          }),
        )
      : this.props.children;
  }
};
function RenderedRoute({ routeContext, match, children }) {
  let dataRouterContext = x$1(DataRouterContext);
  if (
    dataRouterContext &&
    dataRouterContext.static &&
    dataRouterContext.staticContext &&
    (match.route.errorElement || match.route.ErrorBoundary)
  ) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ g$3(
    RouteContext.Provider,
    { value: routeContext },
    children,
  );
}
function _renderMatches(
  matches,
  parentMatches = [],
  dataRouterState = null,
  future = null,
) {
  if (matches == null) {
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if (
      parentMatches.length === 0 &&
      !dataRouterState.initialized &&
      dataRouterState.matches.length > 0
    ) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(
      (m2) =>
        m2.route.id &&
        (errors == null ? void 0 : errors[m2.route.id]) !== void 0,
    );
    invariant(
      errorIndex >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        errors,
      ).join(",")}`,
    );
    renderedMatches = renderedMatches.slice(
      0,
      Math.min(renderedMatches.length, errorIndex + 1),
    );
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState) {
    for (let i3 = 0; i3 < renderedMatches.length; i3++) {
      let match = renderedMatches[i3];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i3;
      }
      if (match.route.id) {
        let { loaderData, errors: errors2 } = dataRouterState;
        let needsToRunLoader =
          match.route.loader &&
          !loaderData.hasOwnProperty(match.route.id) &&
          (!errors2 || errors2[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match.route.id ? errors[match.route.id] : void 0;
      errorElement = match.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index === 0) {
          warningOnce(
            "route-fallback",
            false,
            "No `HydrateFallback` element provided to render during initial hydration",
          );
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match.route.Component) {
        children = /* @__PURE__ */ g$3(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ g$3(RenderedRoute, {
        match,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null,
        },
        children,
      });
    };
    return dataRouterState &&
      (match.route.ErrorBoundary || match.route.errorElement || index === 0)
      ? /* @__PURE__ */ g$3(RenderErrorBoundary, {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error,
          children: getChildren(),
          routeContext: { outlet: null, matches: matches2, isDataRoute: true },
        })
      : getChildren();
  }, null);
}
function getDataRouterConsoleError(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext(hookName) {
  let ctx = x$1(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError(hookName));
  return ctx;
}
function useDataRouterState(hookName) {
  let state = x$1(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError(hookName));
  return state;
}
function useRouteContext(hookName) {
  let route = x$1(RouteContext);
  invariant(route, getDataRouterConsoleError(hookName));
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  invariant(
    thisRoute.route.id,
    `${hookName} can only be used on routes that contain a unique "id"`,
  );
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId(
    "useRouteId",
    /* UseRouteId */
  );
}
function useRouteError() {
  var _a2;
  let error = x$1(RouteErrorContext);
  let state = useDataRouterState(
    "useRouteError",
    /* UseRouteError */
  );
  let routeId = useCurrentRouteId(
    "useRouteError",
    /* UseRouteError */
  );
  if (error !== void 0) {
    return error;
  }
  return (_a2 = state.errors) == null ? void 0 : _a2[routeId];
}
function useNavigateStable() {
  let { router } = useDataRouterContext(
    "useNavigate",
    /* UseNavigateStable */
  );
  let id2 = useCurrentRouteId(
    "useNavigate",
    /* UseNavigateStable */
  );
  let activeRef = A$1(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = q$1(
    async (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        router.navigate(to);
      } else {
        await router.navigate(to, { fromRouteId: id2, ...options });
      }
    },
    [router, id2],
  );
  return navigate;
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    warning(false, message);
  }
}
M2(DataRoutes);
function DataRoutes({ routes, future, state }) {
  return useRoutesImpl(routes, void 0, state, future);
}
function Route(_props) {
  invariant(
    false,
    `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`,
  );
}
function Router({
  basename: basenameProp = "/",
  children = null,
  location: locationProp,
  navigationType = "POP",
  navigator: navigator2,
  static: staticProp = false,
}) {
  invariant(
    !useInRouterContext(),
    `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`,
  );
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = T$1(
    () => ({
      basename,
      navigator: navigator2,
      static: staticProp,
      future: {},
    }),
    [basename, navigator2, staticProp],
  );
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default",
  } = locationProp;
  let locationContext = T$1(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key,
      },
      navigationType,
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  warning(
    locationContext != null,
    `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`,
  );
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ g$3(
    NavigationContext.Provider,
    { value: navigationContext },
    /* @__PURE__ */ g$3(LocationContext.Provider, {
      children,
      value: locationContext,
    }),
  );
}
function Routes({ children, location }) {
  return useRoutes(createRoutesFromChildren(children), location);
}
function createRoutesFromChildren(children, parentPath = []) {
  let routes = [];
  O.forEach(children, (element, index) => {
    if (!pn(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === k$3) {
      routes.push.apply(
        routes,
        createRoutesFromChildren(element.props.children, treePath),
      );
      return;
    }
    invariant(
      element.type === Route,
      `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`,
    );
    invariant(
      !element.props.index || !element.props.children,
      "An index route cannot have child routes.",
    );
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      hydrateFallbackElement: element.props.hydrateFallbackElement,
      HydrateFallback: element.props.HydrateFallback,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary:
        element.props.hasErrorBoundary === true ||
        element.props.ErrorBoundary != null ||
        element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy,
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(
        element.props.children,
        treePath,
      );
    }
    routes.push(route);
  });
  return routes;
}
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return (
    event.button === 0 && // Ignore everything but left clicks
    (!target || target === "_self") && // Let browser handle "target=_blank" etc.
    !isModifiedEvent(event)
  );
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0,
      );
      _formDataSupportsSubmitter = false;
    } catch (e3) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
var supportedFormEncTypes = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain",
]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    warning(
      false,
      `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`,
    );
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (
    isButtonElement(target) ||
    (isInputElement(target) &&
      (target.type === "submit" || target.type === "image"))
  ) {
    let form = target.form;
    if (form == null) {
      throw new Error(
        `Cannot submit a <button> or <input type="submit"> without a <form>`,
      );
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method =
      target.getAttribute("formmethod") ||
      form.getAttribute("method") ||
      defaultMethod;
    encType =
      getFormEncType(target.getAttribute("formenctype")) ||
      getFormEncType(form.getAttribute("enctype")) ||
      defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let { name, type, value } = target;
      if (type === "image") {
        let prefix = name ? `${name}.` : "";
        formData.append(`${prefix}x`, "0");
        formData.append(`${prefix}y`, "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error(
      `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`,
    );
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body = target;
  }
  if (formData && encType === "text/plain") {
    body = formData;
    formData = void 0;
  }
  return { action, method: method.toLowerCase(), encType, formData, body };
}
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      route.module
    );
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    console.error(
      `Error loading route module \`${route.module}\`, reloading page...`,
    );
    console.error(error);
    if (
      window.__reactRouterContext &&
      window.__reactRouterContext.isSpaMode && // @ts-expect-error
      void 0
    );
    window.location.reload();
    return new Promise(() => {});
  }
}
function isHtmlLinkDescriptor(object) {
  if (object == null) {
    return false;
  }
  if (object.href == null) {
    return (
      object.rel === "preload" &&
      typeof object.imageSrcSet === "string" &&
      typeof object.imageSizes === "string"
    );
  }
  return typeof object.rel === "string" && typeof object.href === "string";
}
async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
  let links = await Promise.all(
    matches.map(async (match) => {
      let route = manifest.routes[match.route.id];
      if (route) {
        let mod = await loadRouteModule(route, routeModules);
        return mod.links ? mod.links() : [];
      }
      return [];
    }),
  );
  return dedupeLinkDescriptors(
    links
      .flat(1)
      .filter(isHtmlLinkDescriptor)
      .filter((link) => link.rel === "stylesheet" || link.rel === "preload")
      .map((link) =>
        link.rel === "stylesheet"
          ? { ...link, rel: "prefetch", as: "style" }
          : { ...link, rel: "prefetch" },
      ),
  );
}
function getNewMatchesForLinks(
  page,
  nextMatches,
  currentMatches,
  manifest,
  location,
  mode,
) {
  let isNew = (match, index) => {
    if (!currentMatches[index]) return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    var _a2;
    return (
      // param change, /users/123 -> /users/456
      currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      (((_a2 = currentMatches[index].route.path) == null
        ? void 0
        : _a2.endsWith("*")) &&
        currentMatches[index].params["*"] !== match.params["*"])
    );
  };
  if (mode === "assets") {
    return nextMatches.filter(
      (match, index) => isNew(match, index) || matchPathChanged(match, index),
    );
  }
  if (mode === "data") {
    return nextMatches.filter((match, index) => {
      var _a2;
      let manifestRoute = manifest.routes[match.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return false;
      }
      if (isNew(match, index) || matchPathChanged(match, index)) {
        return true;
      }
      if (match.route.shouldRevalidate) {
        let routeChoice = match.route.shouldRevalidate({
          currentUrl: new URL(
            location.pathname + location.search + location.hash,
            window.origin,
          ),
          currentParams:
            ((_a2 = currentMatches[0]) == null ? void 0 : _a2.params) || {},
          nextUrl: new URL(page, window.origin),
          nextParams: match.params,
          defaultShouldRevalidate: true,
        });
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return true;
    });
  }
  return [];
}
function getModuleLinkHrefs(
  matches,
  manifest,
  { includeHydrateFallback } = {},
) {
  return dedupeHrefs(
    matches
      .map((match) => {
        let route = manifest.routes[match.route.id];
        if (!route) return [];
        let hrefs = [route.module];
        if (route.clientActionModule) {
          hrefs = hrefs.concat(route.clientActionModule);
        }
        if (route.clientLoaderModule) {
          hrefs = hrefs.concat(route.clientLoaderModule);
        }
        if (includeHydrateFallback && route.hydrateFallbackModule) {
          hrefs = hrefs.concat(route.hydrateFallbackModule);
        }
        if (route.imports) {
          hrefs = hrefs.concat(route.imports);
        }
        return hrefs;
      })
      .flat(1),
  );
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function sortKeys(obj) {
  let sorted = {};
  let keys = Object.keys(obj).sort();
  for (let key of keys) {
    sorted[key] = obj[key];
  }
  return sorted;
}
function dedupeLinkDescriptors(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set();
  new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let key = JSON.stringify(sortKeys(descriptor));
    if (!set.has(key)) {
      set.add(key);
      deduped.push({ key, link: descriptor });
    }
    return deduped;
  }, []);
}
function singleFetchUrl(reqUrl, basename) {
  let url =
    typeof reqUrl === "string"
      ? new URL(
          reqUrl,
          // This can be called during the SSR flow via PrefetchPageLinksImpl so
          // don't assume window is available
          typeof window === "undefined"
            ? "server://singlefetch/"
            : window.location.origin,
        )
      : reqUrl;
  if (url.pathname === "/") {
    url.pathname = "_root.data";
  } else if (basename && stripBasename(url.pathname, basename) === "/") {
    url.pathname = `${basename.replace(/\/$/, "")}/_root.data`;
  } else {
    url.pathname = `${url.pathname.replace(/\/$/, "")}.data`;
  }
  return url;
}
function useDataRouterContext2() {
  let context = x$1(DataRouterContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterContext.Provider> element",
  );
  return context;
}
function useDataRouterStateContext() {
  let context = x$1(DataRouterStateContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterStateContext.Provider> element",
  );
  return context;
}
var FrameworkContext = J$1(void 0);
FrameworkContext.displayName = "FrameworkContext";
function useFrameworkContext() {
  let context = x$1(FrameworkContext);
  invariant2(
    context,
    "You must render this element inside a <HydratedRouter> element",
  );
  return context;
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let frameworkContext = x$1(FrameworkContext);
  let [maybePrefetch, setMaybePrefetch] = h$2(false);
  let [shouldPrefetch, setShouldPrefetch] = h$2(false);
  let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } =
    theirElementProps;
  let ref = A$1(null);
  y(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
    if (prefetch === "viewport") {
      let callback = (entries) => {
        entries.forEach((entry) => {
          setShouldPrefetch(entry.isIntersecting);
        });
      };
      let observer = new IntersectionObserver(callback, { threshold: 0.5 });
      if (ref.current) observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [prefetch]);
  y(() => {
    if (maybePrefetch) {
      let id2 = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id2);
      };
    }
  }, [maybePrefetch]);
  let setIntent = () => {
    setMaybePrefetch(true);
  };
  let cancelIntent = () => {
    setMaybePrefetch(false);
    setShouldPrefetch(false);
  };
  if (!frameworkContext) {
    return [false, ref, {}];
  }
  if (prefetch !== "intent") {
    return [shouldPrefetch, ref, {}];
  }
  return [
    shouldPrefetch,
    ref,
    {
      onFocus: composeEventHandlers(onFocus, setIntent),
      onBlur: composeEventHandlers(onBlur, cancelIntent),
      onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
      onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
      onTouchStart: composeEventHandlers(onTouchStart, setIntent),
    },
  ];
}
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function PrefetchPageLinks({ page, ...dataLinkProps }) {
  let { router } = useDataRouterContext2();
  let matches = T$1(
    () => matchRoutes(router.routes, page, router.basename),
    [router.routes, page, router.basename],
  );
  if (!matches) {
    return null;
  }
  return /* @__PURE__ */ g$3(PrefetchPageLinksImpl, {
    page,
    matches,
    ...dataLinkProps,
  });
}
function useKeyedPrefetchLinks(matches) {
  let { manifest, routeModules } = useFrameworkContext();
  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = h$2([]);
  y(() => {
    let interrupted = false;
    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
      (links) => {
        if (!interrupted) {
          setKeyedPrefetchLinks(links);
        }
      },
    );
    return () => {
      interrupted = true;
    };
  }, [matches, manifest, routeModules]);
  return keyedPrefetchLinks;
}
function PrefetchPageLinksImpl({ page, matches: nextMatches, ...linkProps }) {
  let location = useLocation();
  let { manifest, routeModules } = useFrameworkContext();
  let { basename } = useDataRouterContext2();
  let { loaderData, matches } = useDataRouterStateContext();
  let newMatchesForData = T$1(
    () =>
      getNewMatchesForLinks(
        page,
        nextMatches,
        matches,
        manifest,
        location,
        "data",
      ),
    [page, nextMatches, matches, manifest, location],
  );
  let newMatchesForAssets = T$1(
    () =>
      getNewMatchesForLinks(
        page,
        nextMatches,
        matches,
        manifest,
        location,
        "assets",
      ),
    [page, nextMatches, matches, manifest, location],
  );
  let dataHrefs = T$1(() => {
    if (page === location.pathname + location.search + location.hash) {
      return [];
    }
    let routesParams = /* @__PURE__ */ new Set();
    let foundOptOutRoute = false;
    nextMatches.forEach((m2) => {
      var _a2;
      let manifestRoute = manifest.routes[m2.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return;
      }
      if (
        !newMatchesForData.some((m22) => m22.route.id === m2.route.id) &&
        m2.route.id in loaderData &&
        ((_a2 = routeModules[m2.route.id]) == null
          ? void 0
          : _a2.shouldRevalidate)
      ) {
        foundOptOutRoute = true;
      } else if (manifestRoute.hasClientLoader) {
        foundOptOutRoute = true;
      } else {
        routesParams.add(m2.route.id);
      }
    });
    if (routesParams.size === 0) {
      return [];
    }
    let url = singleFetchUrl(page, basename);
    if (foundOptOutRoute && routesParams.size > 0) {
      url.searchParams.set(
        "_routes",
        nextMatches
          .filter((m2) => routesParams.has(m2.route.id))
          .map((m2) => m2.route.id)
          .join(","),
      );
    }
    return [url.pathname + url.search];
  }, [
    basename,
    loaderData,
    location,
    manifest,
    newMatchesForData,
    nextMatches,
    page,
    routeModules,
  ]);
  let moduleHrefs = T$1(
    () => getModuleLinkHrefs(newMatchesForAssets, manifest),
    [newMatchesForAssets, manifest],
  );
  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
  return /* @__PURE__ */ g$3(
    k$3,
    null,
    dataHrefs.map((href2) =>
      /* @__PURE__ */ g$3("link", {
        key: href2,
        rel: "prefetch",
        as: "fetch",
        href: href2,
        ...linkProps,
      }),
    ),
    moduleHrefs.map((href2) =>
      /* @__PURE__ */ g$3("link", {
        key: href2,
        rel: "modulepreload",
        href: href2,
        ...linkProps,
      }),
    ),
    keyedPrefetchLinks.map(({ key, link }) =>
      // these don't spread `linkProps` because they are full link descriptors
      // already with their own props
      /* @__PURE__ */ g$3("link", { key, ...link }),
    ),
  );
}
function mergeRefs(...refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var isBrowser =
  typeof window !== "undefined" &&
  typeof window.document !== "undefined" &&
  typeof window.document.createElement !== "undefined";
try {
  if (isBrowser) {
    window.__reactRouterVersion = "7.5.0";
  }
} catch (e3) {}
function BrowserRouter({ basename, children, window: window2 }) {
  let historyRef = A$1();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true,
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = h$2({
    action: history.action,
    location: history.location,
  });
  let setState = q$1(
    (newState) => {
      R2(() => setStateImpl(newState));
    },
    [setStateImpl],
  );
  _(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ g$3(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
  });
}
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link = D(function LinkWithRef(
  {
    onClick,
    discover = "render",
    prefetch = "none",
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset,
    viewTransition,
    ...rest
  },
  forwardedRef,
) {
  let { basename } = x$1(NavigationContext);
  let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && isAbsolute) {
    absoluteHref = to;
    if (isBrowser) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//")
          ? new URL(currentUrl.protocol + to)
          : new URL(to);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e3) {
        warning(
          false,
          `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`,
        );
      }
    }
  }
  let href2 = useHref(to, { relative });
  let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
    prefetch,
    rest,
  );
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative,
    viewTransition,
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  let link =
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ g$3("a", {
      ...rest,
      ...prefetchHandlers,
      href: absoluteHref || href2,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref: mergeRefs(forwardedRef, prefetchRef),
      target,
      "data-discover": !isAbsolute && discover === "render" ? "true" : void 0,
    });
  return shouldPrefetch && !isAbsolute
    ? /* @__PURE__ */ g$3(
        k$3,
        null,
        link,
        /* @__PURE__ */ g$3(PrefetchPageLinks, { page: href2 }),
      )
    : link;
});
Link.displayName = "Link";
var NavLink = D(function NavLinkWithRef(
  {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    viewTransition,
    children,
    ...rest
  },
  ref,
) {
  let path = useResolvedPath(to, { relative: rest.relative });
  let location = useLocation();
  let routerState = x$1(DataRouterStateContext);
  let { navigator: navigator2, basename } = x$1(NavigationContext);
  let isTransitioning =
    routerState != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useViewTransitionState(path) &&
    viewTransition === true;
  let toPathname = navigator2.encodeLocation
    ? navigator2.encodeLocation(path).pathname
    : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname =
    routerState && routerState.navigation && routerState.navigation.location
      ? routerState.navigation.location.pathname
      : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname
      ? nextLocationPathname.toLowerCase()
      : null;
    toPathname = toPathname.toLowerCase();
  }
  if (nextLocationPathname && basename) {
    nextLocationPathname =
      stripBasename(nextLocationPathname, basename) || nextLocationPathname;
  }
  const endSlashPosition =
    toPathname !== "/" && toPathname.endsWith("/")
      ? toPathname.length - 1
      : toPathname.length;
  let isActive =
    locationPathname === toPathname ||
    (!end &&
      locationPathname.startsWith(toPathname) &&
      locationPathname.charAt(endSlashPosition) === "/");
  let isPending =
    nextLocationPathname != null &&
    (nextLocationPathname === toPathname ||
      (!end &&
        nextLocationPathname.startsWith(toPathname) &&
        nextLocationPathname.charAt(toPathname.length) === "/"));
  let renderProps = {
    isActive,
    isPending,
    isTransitioning,
  };
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp(renderProps);
  } else {
    className = [
      classNameProp,
      isActive ? "active" : null,
      isPending ? "pending" : null,
      isTransitioning ? "transitioning" : null,
    ]
      .filter(Boolean)
      .join(" ");
  }
  let style2 =
    typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
  return /* @__PURE__ */ g$3(
    Link,
    {
      ...rest,
      "aria-current": ariaCurrent,
      className,
      ref,
      style: style2,
      to,
      viewTransition,
    },
    typeof children === "function" ? children(renderProps) : children,
  );
});
NavLink.displayName = "NavLink";
var Form = D(
  (
    {
      discover = "render",
      fetcherKey,
      navigate,
      reloadDocument,
      replace: replace2,
      state,
      method = defaultMethod,
      action,
      onSubmit,
      relative,
      preventScrollReset,
      viewTransition,
      ...props
    },
    forwardedRef,
  ) => {
    let submit = useSubmit();
    let formAction = useFormAction(action, { relative });
    let formMethod = method.toLowerCase() === "get" ? "get" : "post";
    let isAbsolute =
      typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
    let submitHandler = (event) => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      let submitMethod =
        (submitter == null ? void 0 : submitter.getAttribute("formmethod")) ||
        method;
      submit(submitter || event.currentTarget, {
        fetcherKey,
        method: submitMethod,
        navigate,
        replace: replace2,
        state,
        relative,
        preventScrollReset,
        viewTransition,
      });
    };
    return /* @__PURE__ */ g$3("form", {
      ref: forwardedRef,
      method: formMethod,
      action: formAction,
      onSubmit: reloadDocument ? onSubmit : submitHandler,
      ...props,
      "data-discover": !isAbsolute && discover === "render" ? "true" : void 0,
    });
  },
);
Form.displayName = "Form";
function getDataRouterConsoleError2(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext3(hookName) {
  let ctx = x$1(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError2(hookName));
  return ctx;
}
function useLinkClickHandler(
  to,
  {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    viewTransition,
  } = {},
) {
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, { relative });
  return q$1(
    (event) => {
      if (shouldProcessLinkClick(event, target)) {
        event.preventDefault();
        let replace2 =
          replaceProp !== void 0
            ? replaceProp
            : createPath(location) === createPath(path);
        navigate(to, {
          replace: replace2,
          state,
          preventScrollReset,
          relative,
          viewTransition,
        });
      }
    },
    [
      location,
      navigate,
      path,
      replaceProp,
      state,
      target,
      to,
      preventScrollReset,
      relative,
      viewTransition,
    ],
  );
}
var fetcherId = 0;
var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
function useSubmit() {
  let { router } = useDataRouterContext3(
    "useSubmit",
    /* UseSubmit */
  );
  let { basename } = x$1(NavigationContext);
  let currentRouteId = useRouteId();
  return q$1(
    async (target, options = {}) => {
      let { action, method, encType, formData, body } = getFormSubmissionInfo(
        target,
        basename,
      );
      if (options.navigate === false) {
        let key = options.fetcherKey || getUniqueFetcherId();
        await router.fetch(key, currentRouteId, options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          flushSync: options.flushSync,
        });
      } else {
        await router.navigate(options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          replace: options.replace,
          state: options.state,
          fromRouteId: currentRouteId,
          flushSync: options.flushSync,
          viewTransition: options.viewTransition,
        });
      }
    },
    [router, basename, currentRouteId],
  );
}
function useFormAction(action, { relative } = {}) {
  let { basename } = x$1(NavigationContext);
  let routeContext = x$1(RouteContext);
  invariant(routeContext, "useFormAction must be used inside a RouteContext");
  let [match] = routeContext.matches.slice(-1);
  let path = { ...useResolvedPath(action ? action : ".", { relative }) };
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search);
    let indexValues = params.getAll("index");
    let hasNakedIndexParam = indexValues.some((v2) => v2 === "");
    if (hasNakedIndexParam) {
      params.delete("index");
      indexValues
        .filter((v2) => v2)
        .forEach((v2) => params.append("index", v2));
      let qs = params.toString();
      path.search = qs ? `?${qs}` : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search
      ? path.search.replace(/^\?/, "?index&")
      : "?index";
  }
  if (basename !== "/") {
    path.pathname =
      path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function useViewTransitionState(to, opts = {}) {
  let vtContext = x$1(ViewTransitionContext);
  invariant(
    vtContext != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?",
  );
  let { basename } = useDataRouterContext3(
    "useViewTransitionState",
    /* useViewTransitionState */
  );
  let path = useResolvedPath(to, { relative: opts.relative });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath =
    stripBasename(vtContext.currentLocation.pathname, basename) ||
    vtContext.currentLocation.pathname;
  let nextPath =
    stripBasename(vtContext.nextLocation.pathname, basename) ||
    vtContext.nextLocation.pathname;
  return (
    matchPath(path.pathname, nextPath) != null ||
    matchPath(path.pathname, currentPath) != null
  );
}
new TextEncoder();
const AUTH_ERROR = "AUTH_ERROR";
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1e3 * 60 * 60 * 24,
      // 24 hours
    },
  },
});
function getErrorMessage(responseData) {
  const ERROR_MSGS = {
    parse_error: "[ERROR] Parse failed!",
    bad_fetch_error: "Fetch failed! Server seems to be down...",
    resource_error: "[ERROR] Invalid resource: ",
    username_error: "Invalid username or password!",
    password_error: "Invalid username or password!",
    internal_server_error: "[ERROR] Robert or Bre screwed up: ",
  };
  let message = "Unknown error";
  switch (responseData.type) {
    case "bad_fetch_error": {
      message = ERROR_MSGS[responseData.type] + responseData.message;
      break;
    }
    case "auth_token_error": {
      message = AUTH_ERROR;
      break;
    }
    case "parse_error": {
      message = ERROR_MSGS[responseData.type];
      break;
    }
    case "resource_error": {
      message = ERROR_MSGS[responseData.type] + responseData.message;
      break;
    }
    case "username_error": {
      message = ERROR_MSGS[responseData.type];
      break;
    }
    case "password_error": {
      message = ERROR_MSGS[responseData.type];
      break;
    }
    case "internal_server_error": {
      message = ERROR_MSGS[responseData.type] + responseData.message;
      break;
    }
  }
  return message;
}
async function makeRequest(jsonBody) {
  try {
    const data = await fetch("/api", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(jsonBody),
    });
    return data;
  } catch (e3) {
    return new Response(
      JSON.stringify({
        type: "bad_fetch_error",
        message: e3.message,
      }),
      {
        status: 400,
      },
    );
  }
}
function assertRecipe(x2) {
  const ERROR_MSG = "[ERROR] Invalid recipe assertion!";
  if (typeof x2 !== "object" || x2 === null) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
  if (!("name" in x2 && typeof x2["name"] === "string")) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
  if (!("reference" in x2 && typeof x2["reference"] === "string")) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
  if (
    !(
      "authors" in x2 &&
      Array.isArray(x2["authors"]) &&
      x2["authors"].every((y2) => typeof y2 === "string")
    )
  ) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
  if (
    !(
      "allergens" in x2 &&
      Array.isArray(x2["allergens"]) &&
      x2["allergens"].every((y2) => typeof y2 === "string")
    )
  ) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
  if (
    !(
      "ingredients" in x2 &&
      Array.isArray(x2["ingredients"]) &&
      x2["ingredients"].every((y2) => typeof y2 === "string")
    )
  ) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
}
function assertFilterResponse(x2) {
  const ERROR_MSG = "[ERROR] Invalid filter assertion!";
  if (typeof x2 !== "object" || x2 === null) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
  if (!("type" in x2 && typeof x2["type"] === "string")) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
  if (!("table_size" in x2 && typeof x2["table_size"] === "number")) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
  if (!("recipes" in x2 && Array.isArray(x2["recipes"]))) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
  x2["recipes"].forEach((r3) => assertRecipe(r3));
}
function assertErrorResponse(x2) {
  const ERROR_MSG = "[ERROR] Invalid error assertion!";
  if (typeof x2 !== "object" || x2 === null) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
  if (!("type" in x2 && typeof x2["type"] === "string")) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
}
function assertAuthResponse(x2) {
  const ERROR_MSG = "[ERROR] Invalid auth assertion!";
  if (typeof x2 !== "object" || x2 === null) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
  if (!("type" in x2 && typeof x2["type"] === "string")) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
  if (!("auth" in x2 && typeof x2["auth"] === "string")) {
    console.error(ERROR_MSG);
    throw new Error(ERROR_MSG);
  }
}
let session_auth = {
  auth: "",
  user: "",
};
function initSessionAuth() {
  session_auth = {
    auth: sessionStorage.getItem("session.auth") || "",
    user: sessionStorage.getItem("session.user") || "",
  };
}
async function login(username, password) {
  const response = await makeRequest({
    type: "login",
    username,
    password,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
  assertAuthResponse(data);
  session_auth = {
    auth: data.auth,
    user: username,
  };
  sessionStorage.setItem("session.auth", data.auth);
  sessionStorage.setItem("session.user", username);
}
async function logout() {
  const response = await makeRequest({
    type: "logout",
    auth: session_auth.auth,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
  session_auth = {
    auth: "",
    user: "",
  };
  sessionStorage.removeItem("session.auth");
  sessionStorage.removeItem("session.lifetime");
  sessionStorage.removeItem("session.user");
}
async function loggedIn() {
  if (!session_auth) {
    return false;
  }
  const response = await makeRequest({
    type: "is_logged_in",
    auth: session_auth.auth,
  });
  return response.status === 200;
}
function useLoggedIn() {
  return useQuery({
    queryKey: ["loggedIn"],
    queryFn: () => loggedIn(),
  });
}
async function changeUsername(password, new_username) {
  const response = await makeRequest({
    type: "change_username",
    auth: session_auth.auth,
    password,
    new_username,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
  session_auth.user = new_username;
  sessionStorage.setItem("session.user", new_username);
}
async function changePassword(password, new_password) {
  const response = await makeRequest({
    type: "change_password",
    auth: session_auth.auth,
    password,
    new_password,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
}
async function addRecipe(
  collection_id,
  recipe_name,
  reference,
  authors,
  ingredients,
  allergens,
) {
  const response = await makeRequest({
    type: "add_recipe",
    auth: session_auth.auth,
    collection_id,
    recipe_name,
    reference,
    authors,
    ingredients,
    allergens,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
}
async function removeRecipe(recipe_name) {
  const response = await makeRequest({
    type: "remove_recipe",
    auth: session_auth.auth,
    recipe_name,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
}
async function createAllergen(allergen_name, collection_id) {
  const response = await makeRequest({
    type: "create_allergen",
    allergen_name,
    collection_id,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
}
async function createIngredient(ingredient_name, collection_id) {
  const response = await makeRequest({
    type: "create_ingredient",
    ingredient_name,
    collection_id,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
}
const styles$c = {
  root: {
    alignItems: "center",
    display: "flex",
    height: "2em",
    justifyContent: "start",
    position: "relative",
  },
  menu: {
    height: "8em",
  },
  addNew: {
    position: "absolute",
    right: 0,
    top: 0,
    bottom: 0,
    margin: "auto",
  },
};
var TagType = /* @__PURE__ */ ((TagType2) => {
  TagType2["Allergen"] = "Allergy";
  TagType2["Ingredient"] = "Ingredient";
  return TagType2;
})(TagType || {});
function TagPicker({
  variant,
  selected,
  available = [],
  setSelected = void 0,
  viewMode = false,
  tagType = void 0,
}) {
  const [newTag, setNewTag] = h$2("");
  const queryClient2 = useQueryClient();
  const params = useParams();
  const collectionId = parseInt(params["id"] || "-1");
  function onRemoveTag(i3) {
    if (setSelected !== void 0) {
      setSelected(selected.slice(0, i3).concat(selected.slice(i3 + 1)));
    }
  }
  function onAddTag(name) {
    if (setSelected !== void 0) {
      setSelected(selected.concat([name]));
    }
  }
  async function onCreateTag() {
    if (newTag === "") return;
    try {
      if (tagType === "Allergy") {
        await createAllergen(newTag, collectionId);
        await queryClient2.invalidateQueries({
          queryKey: ["collectionAllergens"],
        });
        if (!selected.includes(newTag)) {
          onAddTag(newTag);
        }
      } else if (tagType === "Ingredient") {
        await createIngredient(newTag, collectionId);
        await queryClient2.invalidateQueries({
          queryKey: ["collectionIngredients"],
        });
        if (!selected.includes(newTag)) {
          onAddTag(newTag);
        }
      }
    } catch (e3) {
      if (e3 instanceof Error) {
        console.error(e3.message);
      }
    }
  }
  return /* @__PURE__ */ u$5("div", {
    style: styles$c.root,
    children: [
      selected.map((tag, index) =>
        /* @__PURE__ */ u$5(
          tag_default,
          {
            variant,
            removable: !viewMode,
            size: "small",
            onSlRemove: () => onRemoveTag(index),
            children: tag,
          },
          index,
        ),
      ),
      !viewMode &&
        available.length > selected.length &&
        /* @__PURE__ */ u$5(dropdown_default, {
          children: [
            /* @__PURE__ */ u$5(icon_button_default, {
              slot: "trigger",
              name: "plus",
            }),
            /* @__PURE__ */ u$5(menu_default, {
              style: styles$c.menu,
              onSlSelect: (e3) => onAddTag(e3.detail.item.value),
              children: available
                .filter((tag) => !selected.includes(tag))
                .map((tag) => {
                  return /* @__PURE__ */ u$5(menu_item_default, {
                    value: tag,
                    children: tag,
                  });
                }),
            }),
          ],
        }),
      !viewMode &&
        tagType !== void 0 &&
        /* @__PURE__ */ u$5(input_default, {
          style: styles$c.addNew,
          placeholder: "New " + tagType,
          value: newTag,
          onSlChange: (e3) => setNewTag(e3.target.value),
          children: /* @__PURE__ */ u$5(icon_button_default, {
            slot: "suffix",
            name: "plus",
            label: "Create Tag",
            onClick: () => {
              void onCreateTag();
            },
          }),
        }),
    ],
  });
}
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (
        replace != null
          ? replace
          : typeof nextState !== "object" || nextState === null
      )
        ? nextState
        : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = (state = createState(setState, getState, api));
  return api;
};
const createStore = (createState) =>
  createState ? createStoreImpl(createState) : createStoreImpl;
const identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice = Rn.useSyncExternalStore(
    api.subscribe,
    () => selector(api.getState()),
    () => selector(api.getInitialState()),
  );
  Rn.useDebugValue(slice);
  return slice;
}
const createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = (createState) => createImpl;
var dist = {};
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  (function (exports) {
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function shallow$1(objA, objB) {
      if (Object.is(objA, objB)) {
        return true;
      }
      if (
        typeof objA !== "object" ||
        objA === null ||
        typeof objB !== "object" ||
        objB === null
      ) {
        return false;
      }
      if (objA instanceof Map && objB instanceof Map) {
        if (objA.size !== objB.size) return false;
        for (const [key, value] of objA) {
          if (!Object.is(value, objB.get(key))) {
            return false;
          }
        }
        return true;
      }
      if (objA instanceof Set && objB instanceof Set) {
        if (objA.size !== objB.size) return false;
        for (const value of objA) {
          if (!objB.has(value)) {
            return false;
          }
        }
        return true;
      }
      const keysA = Object.keys(objA);
      if (keysA.length !== Object.keys(objB).length) {
        return false;
      }
      for (const keyA of keysA) {
        if (
          !Object.prototype.hasOwnProperty.call(objB, keyA) ||
          !Object.is(objA[keyA], objB[keyA])
        ) {
          return false;
        }
      }
      return true;
    }
    const computedImpl = (compute, opts) => (f2) => {
      const trackedSelectors = /* @__PURE__ */ new Set();
      return (set, get, api) => {
        const equalityFn =
          (opts == null ? void 0 : opts.equalityFn) ?? shallow$1;
        if (opts == null ? void 0 : opts.keys) {
          const selectorKeys = opts.keys;
          for (const key of selectorKeys) {
            trackedSelectors.add(key);
          }
        }
        const useSelectors =
          (opts == null ? void 0 : opts.disableProxy) !== true ||
          !!(opts == null ? void 0 : opts.keys);
        const useProxy =
          (opts == null ? void 0 : opts.disableProxy) !== true &&
          !(opts == null ? void 0 : opts.keys);
        const computeAndMerge = (state) => {
          const stateProxy = new Proxy(
            { ...state },
            {
              get: (_2, prop) => {
                trackedSelectors.add(prop);
                return state[prop];
              },
            },
          );
          const computedState = compute(useProxy ? stateProxy : { ...state });
          for (const k3 of Object.keys(computedState)) {
            if (equalityFn(computedState[k3], state[k3])) {
              computedState[k3] = state[k3];
            }
          }
          return { ...state, ...computedState };
        };
        const setWithComputed = (update2, replace, ...args) => {
          set(
            (state) => {
              const updated =
                typeof update2 === "object" ? update2 : update2(state);
              if (
                useSelectors &&
                trackedSelectors.size !== 0 &&
                !Object.keys(updated).some((k3) => trackedSelectors.has(k3))
              ) {
                return { ...state, ...updated };
              }
              return computeAndMerge({ ...state, ...updated });
            },
            replace,
            ...args,
          );
        };
        const _api = api;
        _api.setState = setWithComputed;
        const st = f2(setWithComputed, get, _api);
        return Object.assign({}, st, compute(st));
      };
    };
    const createComputed = computedImpl;
    exports.createComputed = createComputed;
  })(dist);
  return dist;
}
var distExports = requireDist();
var VIEW = /* @__PURE__ */ ((VIEW2) => {
  VIEW2[(VIEW2["SEARCH_SETTINGS"] = 0)] = "SEARCH_SETTINGS";
  VIEW2[(VIEW2["MAIN"] = 1)] = "MAIN";
  VIEW2[(VIEW2["COLLECTIONS_LIST"] = 2)] = "COLLECTIONS_LIST";
  VIEW2[(VIEW2["CHANGE_USERNAME"] = 3)] = "CHANGE_USERNAME";
  VIEW2[(VIEW2["CHANGE_PASSWORD"] = 4)] = "CHANGE_PASSWORD";
  VIEW2[(VIEW2["LOGIN_PROMPT"] = 5)] = "LOGIN_PROMPT";
  VIEW2[(VIEW2["NEW_RECIPE_FORM"] = 6)] = "NEW_RECIPE_FORM";
  VIEW2[(VIEW2["UPDATE_RECIPE_FORM"] = 7)] = "UPDATE_RECIPE_FORM";
  VIEW2[(VIEW2["RECIPE_SUMMARY"] = 8)] = "RECIPE_SUMMARY";
  return VIEW2;
})(VIEW || {});
var COLUMN_MASK = /* @__PURE__ */ ((COLUMN_MASK2) => {
  COLUMN_MASK2[(COLUMN_MASK2["NAME"] = 1)] = "NAME";
  COLUMN_MASK2[(COLUMN_MASK2["AUTHOR"] = 2)] = "AUTHOR";
  COLUMN_MASK2[(COLUMN_MASK2["ALLERGENS"] = 4)] = "ALLERGENS";
  COLUMN_MASK2[(COLUMN_MASK2["REFERENCE"] = 8)] = "REFERENCE";
  COLUMN_MASK2[(COLUMN_MASK2["INGREDIENTS"] = 16)] = "INGREDIENTS";
  return COLUMN_MASK2;
})(COLUMN_MASK || {});
const initStoreState = {
  clientUsername: "",
  view: 1,
  page: 0,
  numRowsPerPage: 10,
  visibleColumns: 1 | 2 | 8,
  recipeSearchFilter: "",
  includeAllergensFilter: [],
  excludeAllergensFilter: [],
  includeIngredientsFilter: [],
  excludeIngredientsFilter: [],
  includeAuthorsFilter: [],
  selectedRecipeName: "",
  selectedRecipeReference: "",
  selectedRecipeAuthors: [],
  selectedRecipeIngredients: [],
  selectedRecipeAllergens: [],
};
const computed = distExports.createComputed((state) => ({
  filterProps: {
    collection_id: -1,
    recipe_name: state.recipeSearchFilter,
    include_allergens: state.includeAllergensFilter,
    exclude_allergens: state.excludeAllergensFilter,
    include_ingredients: state.includeIngredientsFilter,
    exclude_ingredients: state.excludeIngredientsFilter,
    authors: state.includeAuthorsFilter,
    view_min: -1,
    view_max: -1,
    random: false,
  },
  selectedRecipe: {
    name: state.selectedRecipeName,
    reference: state.selectedRecipeReference,
    authors: state.selectedRecipeAuthors,
    allergens: state.selectedRecipeAllergens,
    ingredients: state.selectedRecipeIngredients,
  },
}));
const useAppStore = create()(
  computed((set, get) => ({
    ...initStoreState,
    setMainView: () =>
      set({
        view: 1,
        /* MAIN */
      }),
    setSettingsView: () =>
      set({
        view: 0,
        /* SEARCH_SETTINGS */
      }),
    setLoginView: () =>
      set({
        view: 5,
        /* LOGIN_PROMPT */
      }),
    setChangeUserView: () =>
      set({
        view: 3,
        /* CHANGE_USERNAME */
      }),
    setChangePassView: () =>
      set({
        view: 4,
        /* CHANGE_PASSWORD */
      }),
    setCollectionsView: () =>
      set({
        view: 2,
        /* COLLECTIONS_LIST */
      }),
    setNewRecipeView: () =>
      set({
        view: 6,
        /* NEW_RECIPE_FORM */
      }),
    setUpdateRecipeView: () =>
      set({
        view: 7,
        /* UPDATE_RECIPE_FORM */
      }),
    setRecipeSummaryView: () =>
      set({
        view: 8,
        /* RECIPE_SUMMARY */
      }),
    gotoFirstPage: () => set({ page: 0 }),
    gotoPrevPage: () => set((state) => ({ page: Math.max(0, state.page - 1) })),
    gotoNextPage: (numPages) =>
      set((state) => ({ page: Math.min(numPages - 1, state.page + 1) })),
    gotoLastPage: (numPages) => set(() => ({ page: numPages - 1 })),
    setRowsPerPage: (numRowsPerPage) => set({ numRowsPerPage }),
    getColumnVisible: (mask) => (get().visibleColumns & mask) > 0,
    toggleColumn: (mask) =>
      set((state) => ({ visibleColumns: state.visibleColumns ^ mask })),
    setClientUsername: (clientUsername) => set({ clientUsername }),
    setSelectedRecipe: (recipeData) =>
      set({
        selectedRecipeName: recipeData.name,
        selectedRecipeReference: recipeData.reference,
        selectedRecipeAllergens: recipeData.allergens,
        selectedRecipeIngredients: recipeData.ingredients,
        selectedRecipeAuthors: recipeData.authors,
      }),
    setRecipeSearchFilter: (recipeSearchFilter) => set({ recipeSearchFilter }),
    setIncludeAllergensFilter: (includeAllergensFilter) =>
      set({ includeAllergensFilter }),
    setExcludeAllergensFilter: (excludeAllergensFilter) =>
      set({ excludeAllergensFilter }),
    setIncludeIngredientsFilter: (includeIngredientsFilter) =>
      set({ includeIngredientsFilter }),
    setExcludeIngredientsFilter: (excludeIngredientsFilter) =>
      set({ excludeIngredientsFilter }),
    setIncludeAuthorsFilter: (includeAuthorsFilter) =>
      set({ includeAuthorsFilter }),
  })),
);
async function filterRecipeCollection({
  collection_id,
  recipe_name,
  include_allergens,
  exclude_allergens,
  include_ingredients,
  exclude_ingredients,
  authors,
  view_min,
  view_max,
  random,
}) {
  const response = await makeRequest({
    type: "filter_recipe_collection",
    collection_id,
    recipe_name,
    include_allergens,
    exclude_allergens,
    include_ingredients,
    exclude_ingredients,
    authors,
    view_min,
    view_max,
    random,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
  assertFilterResponse(data);
  return data.recipes.map((recipe) => ({
    ...recipe,
    allergens: recipe.allergens.filter((allergen) => allergen !== null),
    ingredients: recipe.ingredients.filter((ingredient) => ingredient !== null),
  }));
}
function useFilterCollection(props) {
  return useQuery({
    queryKey: ["filterCollection", props.collection_id],
    queryFn: () => filterRecipeCollection(props),
  });
}
async function countRecipesInFilter({
  collection_id,
  recipe_name,
  include_allergens,
  exclude_allergens,
  include_ingredients,
  exclude_ingredients,
  authors,
  view_min,
  view_max,
  random,
}) {
  const response = await makeRequest({
    type: "filter_recipe_collection",
    collection_id,
    recipe_name,
    include_allergens,
    exclude_allergens,
    include_ingredients,
    exclude_ingredients,
    authors,
    view_min,
    view_max,
    random,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
  assertFilterResponse(data);
  return data.table_size;
}
function useCountRecipesInFilter(props) {
  return useQuery({
    queryKey: ["filterCollectionCount", props.collection_id],
    queryFn: () => countRecipesInFilter(props),
  });
}
async function renameRecipeCollection(id2, new_name) {
  const response = await makeRequest({
    type: "rename_recipe_collection",
    auth: session_auth.auth,
    id: id2,
    new_name,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
}
async function addRecipeCollection(name) {
  const response = await makeRequest({
    type: "add_recipe_collection",
    auth: session_auth.auth,
    name,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
  if (
    !(
      typeof data === "object" &&
      data !== null &&
      "id" in data &&
      typeof data.id === "number"
    )
  ) {
    throw new Error();
  }
  return data.id;
}
async function getOwnedRecipeCollections() {
  const response = await makeRequest({
    type: "get_owned_recipe_collections",
    auth: session_auth.auth,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
  if (
    !(
      typeof data === "object" &&
      data !== null &&
      "ids" in data &&
      Array.isArray(data.ids) &&
      data.ids.every((id2) => typeof id2 === "number")
    )
  ) {
    throw new Error();
  }
  return data.ids;
}
function useOwnedCollections() {
  return useQuery({
    queryKey: ["ownedCollections"],
    queryFn:
      session_auth.auth !== "" ? () => getOwnedRecipeCollections() : skipToken,
  });
}
async function getAllergensFromCollection(id2) {
  const response = await makeRequest({
    type: "get_allergens_in_collection",
    auth: session_auth.auth,
    id: id2,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
  if (
    !(
      typeof data === "object" &&
      data !== null &&
      "allergens" in data &&
      Array.isArray(data.allergens) &&
      data.allergens.every((allergen) => typeof allergen === "string")
    )
  ) {
    throw new Error();
  }
  return data.allergens;
}
function useCollectionAllergens(collection_id) {
  return useQuery({
    queryKey: ["collectionAllergens", collection_id],
    queryFn: () => getAllergensFromCollection(collection_id),
  });
}
async function getIngredientsFromCollection(id2) {
  const response = await makeRequest({
    type: "get_ingredients_in_collection",
    auth: session_auth.auth,
    id: id2,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
  if (
    !(
      typeof data === "object" &&
      data !== null &&
      "ingredients" in data &&
      Array.isArray(data.ingredients) &&
      data.ingredients.every((ingredient) => typeof ingredient === "string")
    )
  ) {
    throw new Error();
  }
  return data.ingredients;
}
function useCollectionIngredients(collection_id) {
  return useQuery({
    queryKey: ["collectionIngredients", collection_id],
    queryFn: () => getIngredientsFromCollection(collection_id),
  });
}
async function getAuthorsFromCollection(id2) {
  const response = await makeRequest({
    type: "get_authors_in_collection",
    auth: session_auth.auth,
    id: id2,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
  if (
    !(
      typeof data === "object" &&
      data !== null &&
      "authors" in data &&
      Array.isArray(data.authors) &&
      data.authors.every((author) => typeof author === "string")
    )
  ) {
    throw new Error();
  }
  return data.authors;
}
function useCollectionAuthors(collection_id) {
  return useQuery({
    queryKey: ["collectionAuthors", collection_id],
    queryFn: () => getAuthorsFromCollection(collection_id),
  });
}
async function getRecipeCount(id2) {
  const response = await makeRequest({
    type: "count_recipes_in_collection",
    auth: session_auth.auth,
    id: id2,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
  if (
    !(
      typeof data === "object" &&
      data !== null &&
      "count" in data &&
      typeof data.count === "number"
    )
  ) {
    throw new Error();
  }
  return data.count;
}
function useRecipeCount(collection_id) {
  return useQuery({
    queryKey: ["recipeCount", collection_id],
    queryFn:
      collection_id !== -1 ? () => getRecipeCount(collection_id) : skipToken,
  });
}
async function getRecipeCollectionName(id2) {
  const response = await makeRequest({
    type: "get_collection_name",
    auth: session_auth.auth,
    id: id2,
  });
  const data = await response.json();
  if (response.status !== 200) {
    assertErrorResponse(data);
    throw new Error(getErrorMessage(data));
  }
  if (
    !(
      typeof data === "object" &&
      data !== null &&
      "collection_name" in data &&
      typeof data.collection_name === "string"
    )
  ) {
    throw new Error();
  }
  return data.collection_name;
}
function useCollectionName(collection_id) {
  return useQuery({
    queryKey: ["collectionName", collection_id],
    queryFn:
      collection_id !== -1
        ? () => getRecipeCollectionName(collection_id)
        : skipToken,
  });
}
async function getCollectionExists(id2) {
  const response = await makeRequest({
    type: "get_collection_exists",
    auth: session_auth.auth,
    id: id2,
  });
  return response.status === 200;
}
function useCollectionExists(collection_id) {
  return useQuery({
    queryKey: ["collectionExists", collection_id],
    queryFn: () => getCollectionExists(collection_id),
    staleTime: Infinity,
  });
}
const styles$b = {
  settingContainer: {
    display: "flex",
    flexDirection: "row",
    marginBottom: "1em",
  },
  filterContainer: {
    display: "flex",
    flex: 1,
    flexDirection: "column",
  },
};
function FilterPicker({
  columnName,
  included,
  excluded,
  setIncluded,
  setExcluded,
  columnOptions = [],
}) {
  return /* @__PURE__ */ u$5("div", {
    style: styles$b.settingContainer,
    children: [
      /* @__PURE__ */ u$5("div", {
        style: styles$b.filterContainer,
        children: [
          "Include ",
          columnName,
          /* @__PURE__ */ u$5(TagPicker, {
            variant: "success",
            available: columnOptions.filter(
              (tag) => excluded !== void 0 && !excluded.includes(tag),
            ),
            selected: included,
            setSelected: setIncluded,
          }),
        ],
      }),
      excluded !== void 0 &&
        /* @__PURE__ */ u$5("div", {
          style: styles$b.filterContainer,
          children: [
            "Exclude ",
            columnName,
            /* @__PURE__ */ u$5(TagPicker, {
              variant: "danger",
              available: columnOptions.filter((tag) => !included.includes(tag)),
              selected: excluded,
              setSelected: setExcluded,
            }),
          ],
        }),
    ],
  });
}
function SettingsDrawer() {
  const {
    view,
    numRowsPerPage,
    includeAllergensFilter,
    excludeAllergensFilter,
    includeAuthorsFilter,
    includeIngredientsFilter,
    excludeIngredientsFilter,
    getColumnVisible,
    toggleColumn,
    setMainView,
    setRowsPerPage,
    gotoFirstPage,
    setIncludeAllergensFilter,
    setExcludeAllergensFilter,
    setIncludeAuthorsFilter,
    setIncludeIngredientsFilter,
    setExcludeIngredientsFilter,
  } = useAppStore();
  const queryClient2 = useQueryClient();
  const params = useParams();
  const collectionId = parseInt(params["id"] || "-1");
  const { data: allAuthors } = useCollectionAuthors(collectionId);
  const { data: allAllergens } = useCollectionAllergens(collectionId);
  const { data: allIngredients } = useCollectionIngredients(collectionId);
  const minRowsPerPage = 1;
  const maxRowsPerPage = 20;
  async function onSetRowsPerPage(value) {
    if (isNaN(value)) {
      return;
    }
    setRowsPerPage(Math.min(maxRowsPerPage, Math.max(minRowsPerPage, value)));
    gotoFirstPage();
    await queryClient2.invalidateQueries({ queryKey: ["filterCollection"] });
  }
  function onHide(e3) {
    if (e3.eventPhase !== Event.AT_TARGET) {
      e3.preventDefault();
      return;
    }
    setMainView();
  }
  async function onApplySearch() {
    await queryClient2.invalidateQueries({ queryKey: ["filterCollection"] });
  }
  return /* @__PURE__ */ u$5(drawer_default, {
    class: "drawer-placement-top",
    open: view === VIEW.SEARCH_SETTINGS,
    onSlHide: (e3) => onHide(e3),
    placement: "top",
    label: "Search Settings",
    children: [
      /* @__PURE__ */ u$5("div", {
        style: styles$b.settingContainer,
        children: /* @__PURE__ */ u$5("div", {
          style: styles$b.filterContainer,
          children: [
            "Recipes Per Page",
            /* @__PURE__ */ u$5(input_default, {
              type: "number",
              value: numRowsPerPage.toString(),
              min: minRowsPerPage,
              max: maxRowsPerPage,
              onSlBlur: (e3) => {
                void onSetRowsPerPage(parseInt(e3.target.value));
              },
            }),
          ],
        }),
      }),
      /* @__PURE__ */ u$5("div", {
        style: styles$b.settingContainer,
        children: /* @__PURE__ */ u$5("div", {
          style: styles$b.filterContainer,
          children: [
            "Visible Columns",
            /* @__PURE__ */ u$5(checkbox_default, {
              size: "small",
              checked: getColumnVisible(COLUMN_MASK.NAME),
              onSlChange: () => toggleColumn(COLUMN_MASK.NAME),
              children: "Recipe Name",
            }),
            /* @__PURE__ */ u$5(checkbox_default, {
              size: "small",
              checked: getColumnVisible(COLUMN_MASK.AUTHOR),
              onSlChange: () => toggleColumn(COLUMN_MASK.AUTHOR),
              children: "Author",
            }),
            /* @__PURE__ */ u$5(checkbox_default, {
              size: "small",
              checked: getColumnVisible(COLUMN_MASK.ALLERGENS),
              onSlChange: () => toggleColumn(COLUMN_MASK.ALLERGENS),
              children: "Allergens",
            }),
            /* @__PURE__ */ u$5(checkbox_default, {
              size: "small",
              checked: getColumnVisible(COLUMN_MASK.REFERENCE),
              onSlChange: () => toggleColumn(COLUMN_MASK.REFERENCE),
              children: "Reference",
            }),
            /* @__PURE__ */ u$5(checkbox_default, {
              size: "small",
              checked: getColumnVisible(COLUMN_MASK.INGREDIENTS),
              onSlChange: () => toggleColumn(COLUMN_MASK.INGREDIENTS),
              children: "Ingredients",
            }),
          ],
        }),
      }),
      /* @__PURE__ */ u$5(FilterPicker, {
        columnName: "Author",
        included: includeAuthorsFilter,
        setIncluded: setIncludeAuthorsFilter,
        columnOptions: allAuthors,
      }),
      /* @__PURE__ */ u$5(FilterPicker, {
        columnName: "Allergens",
        included: includeAllergensFilter,
        excluded: excludeAllergensFilter,
        setIncluded: setIncludeAllergensFilter,
        setExcluded: setExcludeAllergensFilter,
        columnOptions: allAllergens,
      }),
      /* @__PURE__ */ u$5(FilterPicker, {
        columnName: "Ingredients",
        included: includeIngredientsFilter,
        excluded: excludeIngredientsFilter,
        setIncluded: setIncludeIngredientsFilter,
        setExcluded: setExcludeIngredientsFilter,
        columnOptions: allIngredients,
      }),
      /* @__PURE__ */ u$5(button_default, {
        onClick: () => {
          void onApplySearch();
        },
        children: "Apply",
      }),
    ],
  });
}
function SlNotification({ message, variant = "primary", duration = 3e3 }) {
  const icons2 = {
    primary: "info-circle",
    success: "check2-circle",
    neutral: "gear",
    warning: "exclamation-triangle",
    danger: "exclamation-octagon",
  };
  return /* @__PURE__ */ u$5(alert_default, {
    variant,
    closable: true,
    duration,
    children: [
      /* @__PURE__ */ u$5(icon_default, {
        name: icons2[variant],
        slot: "icon",
      }),
      message,
    ],
  });
}
const styles$a = {
  root: {
    display: "flex",
    flexDirection: "row-reverse",
    alignItems: "center",
    flex: "1",
  },
  avatar: {
    "--size": "1.75em",
    cursor: "pointer",
    marginLeft: "8px",
  },
};
function Toolbar({ collectionDef }) {
  const {
    clientUsername,
    recipeSearchFilter,
    filterProps,
    setSettingsView,
    setLoginView,
    setChangePassView,
    setChangeUserView,
    setCollectionsView,
    setRecipeSummaryView,
    setClientUsername,
    setSelectedRecipe,
    setRecipeSearchFilter,
  } = useAppStore();
  const queryClient2 = useQueryClient();
  const params = useParams();
  const collectionId = parseInt(params["id"] || "-1");
  const { data: collectionName } = useCollectionName(collectionId);
  const {
    status,
    data: loggedIn2,
    error,
    isFetching: loggedInFetching,
  } = useLoggedIn();
  const logOutAlert = A$1(null);
  if (status === "error") {
    console.error(error.message);
  }
  let ACTION;
  ((ACTION2) => {
    ACTION2["VIEW_COLLECTIONS"] = "0";
    ACTION2["CHANGE_USERNAME"] = "1";
    ACTION2["CHANGE_PASSWORD"] = "2";
    ACTION2["LOGOUT"] = "3";
  })(ACTION || (ACTION = {}));
  async function onRandomRecipe() {
    const randRecipe = await filterRecipeCollection({
      ...filterProps,
      collection_id: collectionId,
      view_min: 0,
      view_max: 1,
      random: true,
    });
    setSelectedRecipe(randRecipe[0]);
    setRecipeSummaryView();
  }
  async function onLogOut() {
    await logout();
    setClientUsername("");
    await queryClient2.invalidateQueries({ queryKey: ["loggedIn"] });
    if (logOutAlert.current !== null) {
      logOutAlert.current.base.toast();
    }
  }
  async function onApplySearch() {
    await queryClient2.invalidateQueries({ queryKey: ["filterCollection"] });
  }
  async function onMenuAction(item) {
    switch (item) {
      case "0":
        setCollectionsView();
        break;
      case "1":
        setChangeUserView();
        break;
      case "2":
        setChangePassView();
        break;
      case "3":
        await onLogOut();
        break;
    }
  }
  return /* @__PURE__ */ u$5("div", {
    style: styles$a.root,
    children: [
      /* @__PURE__ */ u$5(SlNotification, {
        variant: "success",
        message: "Logged out successfully",
        ref: logOutAlert,
      }),
      /* @__PURE__ */ u$5("div", {}),
      loggedInFetching || !loggedIn2
        ? /* @__PURE__ */ u$5(avatar_default, {
            style: styles$a.avatar,
            label: "Empty avatar",
            onClick: () => setLoginView(),
          })
        : /* @__PURE__ */ u$5(dropdown_default, {
            children: [
              /* @__PURE__ */ u$5(avatar_default, {
                style: styles$a.avatar,
                slot: "trigger",
                initials: clientUsername[0],
                label: "Avatar with username initial",
              }),
              /* @__PURE__ */ u$5(menu_default, {
                onSlSelect: (e3) => {
                  void onMenuAction(e3.detail.item.value);
                },
                children: [
                  /* @__PURE__ */ u$5(menu_label_default, {
                    className: "userMenuLabel",
                    children: clientUsername,
                  }),
                  /* @__PURE__ */ u$5(menu_item_default, {
                    value: "0",
                    children: "View Collections",
                  }),
                  /* @__PURE__ */ u$5(menu_item_default, {
                    value: "1",
                    children: "Change Username",
                  }),
                  /* @__PURE__ */ u$5(menu_item_default, {
                    value: "2",
                    children: "Change Password",
                  }),
                  /* @__PURE__ */ u$5(menu_item_default, {
                    value: "3",
                    children: [
                      "Log Out",
                      /* @__PURE__ */ u$5(icon_default, {
                        name: "box-arrow-right",
                        slot: "suffix",
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
      /* @__PURE__ */ u$5(icon_button_default, {
        disabled: !collectionDef,
        name: "shuffle",
        label: "Generate Random Recipe",
        onClick: () => {
          void onRandomRecipe();
        },
      }),
      /* @__PURE__ */ u$5(icon_button_default, {
        disabled: !collectionDef,
        name: "sliders",
        label: "Search Settings",
        onClick: () => setSettingsView(),
      }),
      /* @__PURE__ */ u$5(input_default, {
        disabled: !collectionDef,
        clearable: true,
        type: "search",
        placeholder: `Search ${collectionName || ""}...`,
        style: { flex: "1" },
        value: recipeSearchFilter,
        onSlChange: (e3) => setRecipeSearchFilter(e3.target.value),
        children: /* @__PURE__ */ u$5(icon_button_default, {
          disabled: !collectionDef,
          name: "search",
          label: "Run Search",
          slot: "suffix",
          onClick: () => {
            void onApplySearch();
          },
        }),
      }),
    ],
  });
}
const styles$9 = {
  root: {
    display: "flex",
    flexDirection: "column",
    flex: "10",
    overflowX: "hidden",
  },
  header: {
    fontSize: "large",
    fontWeight: "bold",
    position: "sticky",
    top: "0",
    zIndex: "1",
  },
  row: {
    display: "flex",
    alignItems: "center",
    height: "30px",
    position: "relative",
  },
  cell: {
    alignItems: "center",
    display: "flex",
    flex: "3",
    justifyContent: "start",
    overflow: "auto hidden",
  },
  end: {
    alignItems: "center",
    display: "flex",
    flex: "1",
    justifyContent: "end",
  },
};
function TableRow({ editMode, rowData }) {
  const {
    getColumnVisible,
    setUpdateRecipeView,
    setRecipeSummaryView,
    setSelectedRecipe,
  } = useAppStore();
  const queryClient2 = useQueryClient();
  function onViewRecipe() {
    setSelectedRecipe(rowData);
    setRecipeSummaryView();
  }
  function onEditRecipe() {
    setSelectedRecipe(rowData);
    setUpdateRecipeView();
  }
  async function onDeleteRecipe() {
    await removeRecipe(rowData.name);
    await queryClient2.invalidateQueries({ queryKey: ["filterCollection"] });
  }
  return /* @__PURE__ */ u$5(card_default, {
    style: { "--border-radius": "0" },
    children: /* @__PURE__ */ u$5("div", {
      style: styles$9.row,
      children: [
        getColumnVisible(COLUMN_MASK.NAME) &&
          /* @__PURE__ */ u$5("div", {
            style: styles$9.cell,
            children: rowData.name,
          }),
        getColumnVisible(COLUMN_MASK.AUTHOR) &&
          /* @__PURE__ */ u$5("div", {
            style: styles$9.cell,
            children: rowData.authors.join(","),
          }),
        getColumnVisible(COLUMN_MASK.ALLERGENS) &&
          /* @__PURE__ */ u$5("div", {
            style: styles$9.cell,
            children: /* @__PURE__ */ u$5(TagPicker, {
              variant: "warning",
              selected: rowData.allergens,
              viewMode: true,
            }),
          }),
        getColumnVisible(COLUMN_MASK.REFERENCE) &&
          /* @__PURE__ */ u$5("div", {
            style: styles$9.cell,
            children: rowData.reference,
          }),
        getColumnVisible(COLUMN_MASK.INGREDIENTS) &&
          /* @__PURE__ */ u$5("div", {
            style: styles$9.cell,
            children: /* @__PURE__ */ u$5(TagPicker, {
              variant: "primary",
              selected: rowData.ingredients,
              viewMode: true,
            }),
          }),
        /* @__PURE__ */ u$5("div", {
          style: styles$9.end,
          children: [
            /* @__PURE__ */ u$5(tooltip_default, {
              content: "View Recipe",
              children: /* @__PURE__ */ u$5(icon_button_default, {
                name: "eye",
                label: "View Recipe",
                onClick: () => onViewRecipe(),
              }),
            }),
            editMode &&
              /* @__PURE__ */ u$5(k$3, {
                children: [
                  /* @__PURE__ */ u$5(tooltip_default, {
                    content: "Edit Recipe",
                    children: /* @__PURE__ */ u$5(icon_button_default, {
                      name: "pencil",
                      label: "Edit Recipe",
                      onClick: () => onEditRecipe(),
                    }),
                  }),
                  /* @__PURE__ */ u$5(tooltip_default, {
                    content: "Delete Recipe",
                    children: /* @__PURE__ */ u$5(icon_button_default, {
                      name: "trash",
                      label: "Delete Recipe",
                      onClick: () => {
                        void onDeleteRecipe();
                      },
                    }),
                  }),
                ],
              }),
          ],
        }),
      ],
    }),
  });
}
function Table({ editMode }) {
  const {
    page,
    numRowsPerPage,
    filterProps,
    getColumnVisible,
    setNewRecipeView,
    setSelectedRecipe,
  } = useAppStore();
  const params = useParams();
  const collectionId = parseInt(params["id"] || "-1");
  const { data: pageData } = useFilterCollection({
    ...filterProps,
    collection_id: collectionId,
    view_min: page * numRowsPerPage,
    view_max: (page + 1) * numRowsPerPage,
  });
  function onCreateRecipe() {
    setSelectedRecipe({
      name: "",
      reference: "",
      authors: [],
      allergens: [],
      ingredients: [],
    });
    setNewRecipeView();
  }
  return /* @__PURE__ */ u$5("div", {
    style: styles$9.root,
    children: [
      /* @__PURE__ */ u$5(card_default, {
        style: { ...styles$9.header, "--border-radius": "0" },
        children: /* @__PURE__ */ u$5("div", {
          style: styles$9.row,
          children: [
            getColumnVisible(COLUMN_MASK.NAME) &&
              /* @__PURE__ */ u$5("div", {
                style: styles$9.cell,
                children: "Recipe Name",
              }),
            getColumnVisible(COLUMN_MASK.AUTHOR) &&
              /* @__PURE__ */ u$5("div", {
                style: styles$9.cell,
                children: "Author",
              }),
            getColumnVisible(COLUMN_MASK.ALLERGENS) &&
              /* @__PURE__ */ u$5("div", {
                style: styles$9.cell,
                children: "Allergens",
              }),
            getColumnVisible(COLUMN_MASK.REFERENCE) &&
              /* @__PURE__ */ u$5("div", {
                style: styles$9.cell,
                children: "Reference",
              }),
            getColumnVisible(COLUMN_MASK.INGREDIENTS) &&
              /* @__PURE__ */ u$5("div", {
                style: styles$9.cell,
                children: "Ingredients",
              }),
            /* @__PURE__ */ u$5("div", {
              style: { ...styles$9.end, fontSize: "2em" },
              children:
                editMode &&
                /* @__PURE__ */ u$5(tooltip_default, {
                  content: "Create Recipe",
                  placement: "left",
                  children: /* @__PURE__ */ u$5(icon_button_default, {
                    name: "plus",
                    label: "Create Recipe",
                    onClick: () => onCreateRecipe(),
                  }),
                }),
            }),
          ],
        }),
      }),
      pageData !== void 0 &&
        pageData.map((row) => {
          return /* @__PURE__ */ u$5(TableRow, { editMode, rowData: row });
        }),
    ],
  });
}
const styles$8 = {
  root: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    flex: "1",
  },
};
function PageNav() {
  const {
    page,
    numRowsPerPage,
    filterProps,
    gotoFirstPage,
    gotoPrevPage,
    gotoNextPage,
    gotoLastPage,
  } = useAppStore();
  const queryClient2 = useQueryClient();
  const params = useParams();
  const collectionId = parseInt(params["id"] || "-1");
  const { data: numRecipesInCollection } = useCountRecipesInFilter({
    ...filterProps,
    collection_id: collectionId,
  });
  const numPages = Math.ceil((numRecipesInCollection || 0) / numRowsPerPage);
  const onNavigateFirstPage = async () => {
    gotoFirstPage();
    await queryClient2.invalidateQueries({ queryKey: ["filterCollection"] });
  };
  const onNavigatePrevPage = async () => {
    gotoPrevPage();
    await queryClient2.invalidateQueries({ queryKey: ["filterCollection"] });
  };
  const onNavigateNextPage = async () => {
    gotoNextPage(numPages);
    await queryClient2.invalidateQueries({ queryKey: ["filterCollection"] });
  };
  const onNavigateLastPage = async () => {
    gotoLastPage(numPages);
    await queryClient2.invalidateQueries({ queryKey: ["filterCollection"] });
  };
  return numPages == 0
    ? /* @__PURE__ */ u$5("div", { style: styles$8.root })
    : /* @__PURE__ */ u$5("div", {
        style: styles$8.root,
        children: [
          /* @__PURE__ */ u$5(tooltip_default, {
            content: "First Page",
            children: /* @__PURE__ */ u$5(icon_button_default, {
              disabled: page === 0,
              name: "chevron-double-left",
              onClick: () => {
                void onNavigateFirstPage();
              },
              label: "First Page",
            }),
          }),
          /* @__PURE__ */ u$5(tooltip_default, {
            content: "Previous Page",
            children: /* @__PURE__ */ u$5(icon_button_default, {
              disabled: page === 0,
              name: "chevron-left",
              onClick: () => {
                void onNavigatePrevPage();
              },
              label: "Previous Page",
            }),
          }),
          page + 1,
          /* @__PURE__ */ u$5(tooltip_default, {
            content: "Next Page",
            children: /* @__PURE__ */ u$5(icon_button_default, {
              disabled: page === numPages - 1,
              name: "chevron-right",
              onClick: () => {
                void onNavigateNextPage();
              },
              label: "Next Page",
            }),
          }),
          /* @__PURE__ */ u$5(tooltip_default, {
            content: "Last Page",
            children: /* @__PURE__ */ u$5(icon_button_default, {
              disabled: page === numPages - 1,
              name: "chevron-double-right",
              onClick: () => {
                void onNavigateLastPage();
              },
              label: "Last Page",
            }),
          }),
        ],
      });
}
const styles$7 = {
  inputField: {
    marginBottom: "1em",
  },
};
function LoginDialog() {
  const { view, setMainView, setClientUsername } = useAppStore();
  const queryClient2 = useQueryClient();
  const [username, setUsername] = h$2("");
  const [password, setPassword] = h$2("");
  const [helpText, setHelpText] = h$2("");
  const logInAlert = A$1(null);
  function onCloseDialog() {
    setMainView();
    setUsername("");
    setPassword("");
    setHelpText("");
  }
  async function onLogIn() {
    try {
      await login(username, password);
      await queryClient2.invalidateQueries({ queryKey: ["loggedIn"] });
      setClientUsername(username);
      onCloseDialog();
      if (logInAlert.current !== null) {
        logInAlert.current.base.toast();
      }
    } catch (e3) {
      if (e3 instanceof Error) {
        setHelpText(e3.message);
      }
    }
  }
  return /* @__PURE__ */ u$5(dialog_default, {
    class: "dialog-overview",
    open: view === VIEW.LOGIN_PROMPT,
    onSlAfterHide: () => onCloseDialog(),
    label: "Log In",
    children: [
      /* @__PURE__ */ u$5(SlNotification, {
        message: "Logged in successfully",
        variant: "success",
        ref: logInAlert,
      }),
      /* @__PURE__ */ u$5(input_default, {
        style: styles$7.inputField,
        type: "text",
        value: username,
        onSlChange: (e3) => setUsername(e3.target.value),
        placeholder: "Username",
      }),
      /* @__PURE__ */ u$5(input_default, {
        className: "errorHelp",
        style: styles$7.inputField,
        helpText,
        type: "password",
        value: password,
        onSlChange: (e3) => setPassword(e3.target.value),
        placeholder: "Password",
        passwordToggle: true,
      }),
      /* @__PURE__ */ u$5(button_default, {
        onClick: () => {
          void onLogIn();
        },
        children: "Log In",
      }),
    ],
  });
}
const styles$6 = {
  inputField: {
    marginBottom: "1em",
  },
};
function ChangePassDialog() {
  const { view, setMainView } = useAppStore();
  const [oldPassword, setOldPassword] = h$2("");
  const [newPassword, setNewPassword] = h$2("");
  const [rePassword, setRePassword] = h$2("");
  const [helpText, setHelpText] = h$2("");
  const changePassAlert = A$1(null);
  function onCloseDialog() {
    setMainView();
    setOldPassword("");
    setNewPassword("");
    setRePassword("");
  }
  async function onSetPassword() {
    setHelpText("");
    if (rePassword !== newPassword) {
      setHelpText("New passwords do not match");
      return;
    }
    try {
      await changePassword(oldPassword, newPassword);
    } catch (e3) {
      if (e3 instanceof Error) {
        setHelpText(e3.message);
      }
    }
    onCloseDialog();
    if (changePassAlert.current !== null) {
      changePassAlert.current.base.toast();
    }
  }
  return /* @__PURE__ */ u$5(dialog_default, {
    class: "dialog-overview",
    open: view === VIEW.CHANGE_PASSWORD,
    onSlAfterHide: () => onCloseDialog(),
    label: "Change Password",
    children: [
      /* @__PURE__ */ u$5(SlNotification, {
        message: "Password changed successfully",
        variant: "success",
        ref: changePassAlert,
      }),
      /* @__PURE__ */ u$5(input_default, {
        style: styles$6.inputField,
        type: "password",
        helpText: "Must be 8 - 20 characters",
        value: oldPassword,
        onSlChange: (e3) => setOldPassword(e3.target.value),
        placeholder: "Old Password",
        passwordToggle: true,
        minlength: 8,
        maxlength: 20,
      }),
      /* @__PURE__ */ u$5(input_default, {
        style: styles$6.inputField,
        type: "password",
        value: newPassword,
        onSlChange: (e3) => setNewPassword(e3.target.value),
        placeholder: "New Password",
        passwordToggle: true,
        minlength: 8,
        maxlength: 20,
      }),
      /* @__PURE__ */ u$5(input_default, {
        className: "errorHelp",
        style: styles$6.inputField,
        helpText,
        type: "password",
        value: rePassword,
        onSlChange: (e3) => setRePassword(e3.target.value),
        placeholder: "Retype New Password",
        passwordToggle: true,
        minlength: 8,
        maxlength: 20,
      }),
      /* @__PURE__ */ u$5(button_default, {
        onClick: () => {
          void onSetPassword();
        },
        children: "Confirm",
      }),
    ],
  });
}
const styles$5 = {
  inputField: {
    marginBottom: "1em",
  },
};
function ChangeNameDialog() {
  const { view, setMainView, setClientUsername } = useAppStore();
  const [newUsername, setNewUsername] = h$2("");
  const [password, setPassword] = h$2("");
  const [helpText, setHelpText] = h$2("");
  const changeNameAlert = A$1(null);
  function onCloseDialog() {
    setMainView();
    setNewUsername("");
    setPassword("");
    setHelpText("");
  }
  async function onChangeUsername() {
    try {
      await changeUsername(password, newUsername);
      setClientUsername(newUsername);
    } catch (e3) {
      if (e3 instanceof Error) {
        setHelpText(e3.message);
      }
      return;
    }
    onCloseDialog();
    if (changeNameAlert.current !== null) {
      changeNameAlert.current.base.toast();
    }
  }
  return /* @__PURE__ */ u$5(dialog_default, {
    className: "dialog-overview",
    open: view === VIEW.CHANGE_USERNAME,
    onSlAfterHide: () => onCloseDialog(),
    label: "Change Username",
    children: [
      /* @__PURE__ */ u$5(SlNotification, {
        message: "Changed username successfully",
        variant: "success",
        ref: changeNameAlert,
      }),
      /* @__PURE__ */ u$5(input_default, {
        style: styles$5.inputField,
        helpText: "Must be 8 - 20 characters",
        type: "text",
        value: newUsername,
        onSlChange: (e3) => setNewUsername(e3.target.value),
        placeholder: "New Username",
        minlength: 8,
        maxlength: 20,
      }),
      /* @__PURE__ */ u$5(input_default, {
        className: "errorHelp",
        style: styles$5.inputField,
        helpText,
        type: "password",
        value: password,
        onSlChange: (e3) => setPassword(e3.target.value),
        placeholder: "Password",
        passwordToggle: true,
        minlength: 8,
        maxlength: 20,
      }),
      /* @__PURE__ */ u$5(button_default, {
        onClick: () => {
          void onChangeUsername();
        },
        children: "Confirm",
      }),
    ],
  });
}
const styles$4 = {
  collectionTitle: {
    alignItems: "center",
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-between",
  },
  collectionCard: {
    marginBottom: "1em",
    flex: 1,
    width: "100%",
  },
};
function CollectionCard({ collectionId, searchTerm }) {
  const queryClient2 = useQueryClient();
  const { data: collectionName } = useCollectionName(collectionId);
  const { data: recipeCount } = useRecipeCount(collectionId);
  const [deleteProgress, setDeleteProgress] = h$2(0);
  const [deletePressed, setDeletePressed] = h$2(false);
  const collectionUrl = window.location.origin + "/collection/" + collectionId;
  y(() => {}, [deletePressed]);
  async function onRenameCollection(id2, newName) {
    try {
      await renameRecipeCollection(id2, newName);
      await queryClient2.invalidateQueries({ queryKey: ["collectionName"] });
    } catch (e3) {
      if (e3 instanceof Error) {
        console.error(e3.message);
      }
    }
  }
  return collectionName === void 0 ||
    !collectionName.toLocaleLowerCase().includes(searchTerm.toLocaleLowerCase())
    ? null
    : /* @__PURE__ */ u$5(card_default, {
        style: styles$4.collectionCard,
        children: [
          /* @__PURE__ */ u$5("div", {
            slot: "header",
            style: styles$4.collectionTitle,
            children: [
              /* @__PURE__ */ u$5(input_default, {
                className: "collectionsName",
                filled: true,
                value: collectionName,
                onSlBlur: (e3) => {
                  void onRenameCollection(collectionId, e3.target.value);
                },
              }),
              /* @__PURE__ */ u$5(tooltip_default, {
                content: "Open Collection",
                children: /* @__PURE__ */ u$5(icon_button_default, {
                  name: "box-arrow-up-right",
                  label: "Go to Recipe",
                  onClick: () => {
                    window.location.assign(collectionUrl);
                  },
                }),
              }),
              /* @__PURE__ */ u$5(copy_button_default, {
                value: collectionUrl,
                copyLabel: "Share Collection",
                successLabel: "Copied",
                errorLabel: "Failed to copy",
                children: /* @__PURE__ */ u$5(icon_default, {
                  name: "share",
                  slot: "copy-icon",
                }),
              }),
              /* @__PURE__ */ u$5(tooltip_default, {
                content: "Delete Collection",
                children: /* @__PURE__ */ u$5(icon_button_default, {
                  name: "trash",
                  label: "Delete Collection",
                  onMouseDown: () => setDeletePressed(true),
                  onMouseUp: () => setDeletePressed(false),
                  onMouseLeave: () => setDeletePressed(false),
                }),
              }),
            ],
          }),
          "Included recipes: ",
          recipeCount,
        ],
      });
}
const styles$3 = {
  root: {
    alignItems: "center",
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
  },
  collectionCard: {
    marginBottom: "1em",
    flex: 1,
    width: "100%",
  },
};
function CollectionsDrawer() {
  const queryClient2 = useQueryClient();
  const { view, setMainView } = useAppStore();
  const { data: collectionIds } = useOwnedCollections();
  const [searchTerm, setSearchTerm] = h$2("");
  console.log(searchTerm);
  function onHide(e3) {
    if (e3.eventPhase === Event.AT_TARGET) {
      setMainView();
    } else {
      e3.preventDefault();
    }
  }
  async function onCreateCollection() {
    try {
      await addRecipeCollection("New Collection");
      await queryClient2.invalidateQueries({ queryKey: ["ownedCollections"] });
    } catch (e3) {
      if (e3 instanceof Error) {
        console.error(e3.message);
      }
    }
  }
  return /* @__PURE__ */ u$5(drawer_default, {
    class: "drawer-placement-start",
    open: view === VIEW.COLLECTIONS_LIST,
    onSlHide: (e3) => onHide(e3),
    placement: "start",
    label: "Collections",
    children:
      collectionIds !== void 0 &&
      /* @__PURE__ */ u$5("div", {
        style: styles$3.root,
        children: [
          /* @__PURE__ */ u$5(input_default, {
            style: styles$3.collectionCard,
            clearable: true,
            type: "search",
            placeholder: "Find a collection...",
            value: searchTerm,
            onSlChange: (e3) => setSearchTerm(e3.target.value),
            minlength: 3,
            maxlength: 150,
          }),
          collectionIds.map((collectionId) =>
            /* @__PURE__ */ u$5(CollectionCard, {
              collectionId,
              searchTerm,
            }),
          ),
          /* @__PURE__ */ u$5(tooltip_default, {
            content: "Add Collection",
            children: /* @__PURE__ */ u$5(icon_button_default, {
              name: "plus",
              label: "Add Collection",
              style: { fontSize: "2em" },
              onClick: () => {
                void onCreateCollection();
              },
            }),
          }),
        ],
      }),
  });
}
const styles$2 = {
  inputField: {
    marginBottom: "1em",
  },
};
function RecipeForm({ formTitle, submitLabel, submitMessage, viewState }) {
  const {
    view,
    selectedRecipe,
    selectedRecipeName,
    setMainView,
    setSelectedRecipe,
  } = useAppStore();
  const queryClient2 = useQueryClient();
  const submitAlert = A$1(null);
  const params = useParams();
  const collectionId = parseInt(params["id"] || "-1");
  const [newName, setNewName] = h$2("");
  y(() => {
    setNewName(selectedRecipeName);
  }, [selectedRecipeName]);
  const { data: allAllergens } = useCollectionAllergens(collectionId);
  const { data: allIngredients } = useCollectionIngredients(collectionId);
  function onCloseDialog(e3) {
    if (e3.eventPhase !== Event.AT_TARGET) {
      e3.preventDefault();
      return;
    }
    setMainView();
  }
  async function onAddRecipe() {
    if (newName === "") return;
    try {
      if (viewState === VIEW.UPDATE_RECIPE_FORM) {
        await removeRecipe(selectedRecipe.name);
      }
      await addRecipe(
        collectionId,
        newName,
        selectedRecipe.reference,
        selectedRecipe.authors,
        selectedRecipe.ingredients,
        selectedRecipe.allergens,
      );
      await queryClient2.invalidateQueries({ queryKey: ["filterCollection"] });
      setMainView();
      if (submitAlert.current !== null) {
        submitAlert.current.base.toast();
      }
    } catch (e3) {
      console.error(e3);
    }
  }
  return /* @__PURE__ */ u$5(dialog_default, {
    class: "dialog-overview",
    open: view === viewState,
    onSlHide: (e3) => onCloseDialog(e3),
    label: formTitle,
    children: [
      /* @__PURE__ */ u$5(SlNotification, {
        message: submitMessage,
        variant: "success",
        ref: submitAlert,
      }),
      /* @__PURE__ */ u$5(input_default, {
        style: styles$2.inputField,
        type: "text",
        value: newName,
        onSlChange: (e3) => setNewName(e3.target.value),
        placeholder: "Recipe Name",
      }),
      /* @__PURE__ */ u$5(input_default, {
        style: styles$2.inputField,
        type: "text",
        value: selectedRecipe.authors.join(","),
        onSlChange: (e3) =>
          setSelectedRecipe({
            ...selectedRecipe,
            authors: e3.target.value.split(","),
          }),
        placeholder: "Authors",
      }),
      /* @__PURE__ */ u$5(input_default, {
        style: styles$2.inputField,
        type: "text",
        value: selectedRecipe.reference,
        onSlChange: (e3) =>
          setSelectedRecipe({
            ...selectedRecipe,
            reference: e3.target.value,
          }),
        placeholder: "Reference",
      }),
      /* @__PURE__ */ u$5(TagPicker, {
        variant: "primary",
        available: allAllergens,
        selected: selectedRecipe.allergens,
        setSelected: (allergens) =>
          setSelectedRecipe({ ...selectedRecipe, allergens }),
        tagType: TagType.Allergen,
      }),
      /* @__PURE__ */ u$5(TagPicker, {
        variant: "primary",
        available: allIngredients,
        selected: selectedRecipe.ingredients,
        setSelected: (ingredients) =>
          setSelectedRecipe({ ...selectedRecipe, ingredients }),
        tagType: TagType.Ingredient,
      }),
      /* @__PURE__ */ u$5(button_default, {
        onClick: () => {
          void onAddRecipe();
        },
        children: [" ", submitLabel],
      }),
    ],
  });
}
const styles$1 = {
  summaryField: {
    marginBottom: "1em",
  },
};
function RecipeSummary() {
  const { view, setMainView, selectedRecipe } = useAppStore();
  function onCloseDialog() {
    setMainView();
  }
  return /* @__PURE__ */ u$5(dialog_default, {
    class: "dialog-overview",
    open: view === VIEW.RECIPE_SUMMARY,
    onSlHide: () => onCloseDialog(),
    label: selectedRecipe.name,
    children: [
      /* @__PURE__ */ u$5("strong", { children: "Author(s)" }),
      /* @__PURE__ */ u$5("div", {
        style: styles$1.summaryField,
        children: selectedRecipe.authors.join(","),
      }),
      /* @__PURE__ */ u$5("strong", { children: "Reference" }),
      /* @__PURE__ */ u$5("div", {
        style: styles$1.summaryField,
        children: selectedRecipe.reference,
      }),
      /* @__PURE__ */ u$5("strong", { children: "Allergens" }),
      /* @__PURE__ */ u$5(TagPicker, {
        variant: "primary",
        selected: selectedRecipe.allergens,
        viewMode: true,
      }),
      /* @__PURE__ */ u$5("strong", { children: "Ingredients" }),
      /* @__PURE__ */ u$5(TagPicker, {
        variant: "primary",
        selected: selectedRecipe.ingredients,
        viewMode: true,
      }),
    ],
  });
}
setBasePath(
  "https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.20.0/cdn/",
);
const styles = {
  root: {
    display: "flex",
    flexDirection: "column",
    height: "95vh",
  },
  noCollectionText: {
    alignItems: "center",
    color: "gray",
    display: "flex",
    flexDirection: "column",
    flex: "11",
    fontSize: "72px",
    justifyContent: "center",
    userSelect: "none",
  },
};
function App() {
  const { setClientUsername } = useAppStore();
  const params = useParams();
  const collectionId = parseInt(params["id"] || "-1");
  const collectionDef = collectionId !== -1;
  const { data: loggedIn2 } = useLoggedIn();
  const { data: ownedCollections } = useOwnedCollections();
  const editMode = !!(
    collectionDef &&
    loggedIn2 &&
    ownedCollections &&
    ownedCollections.includes(collectionId)
  );
  y(() => {
    setClientUsername(session_auth.user);
  }, []);
  return /* @__PURE__ */ u$5("div", {
    style: styles.root,
    children: [
      collectionDef && /* @__PURE__ */ u$5(SettingsDrawer, {}),
      /* @__PURE__ */ u$5(CollectionsDrawer, {}),
      /* @__PURE__ */ u$5(LoginDialog, {}),
      /* @__PURE__ */ u$5(ChangeNameDialog, {}),
      /* @__PURE__ */ u$5(ChangePassDialog, {}),
      /* @__PURE__ */ u$5(Toolbar, { collectionDef }),
      collectionDef
        ? /* @__PURE__ */ u$5(k$3, {
            children: [
              /* @__PURE__ */ u$5(Table, { editMode }),
              /* @__PURE__ */ u$5(PageNav, {}),
              /* @__PURE__ */ u$5(RecipeForm, {
                formTitle: "New Recipe",
                submitLabel: "Add Recipe",
                submitMessage: "Added recipe successfully",
                viewState: VIEW.NEW_RECIPE_FORM,
              }),
              /* @__PURE__ */ u$5(RecipeForm, {
                formTitle: "Update Recipe",
                submitLabel: "Update",
                submitMessage: "Updated recipe successfully",
                viewState: VIEW.UPDATE_RECIPE_FORM,
              }),
              /* @__PURE__ */ u$5(RecipeSummary, {}),
            ],
          })
        : /* @__PURE__ */ u$5("div", {
            style: styles.noCollectionText,
            children: "No collection selected!",
          }),
    ],
  });
}
const style = {
  alignItems: "center",
  color: "gray",
  display: "flex",
  flexDirection: "column",
  flex: "11",
  fontSize: "25px",
  justifyContent: "center",
  userSelect: "none",
  fontFamily: "monospace",
  whiteSpace: "pre-wrap",
};
function FourOFourPage() {
  return /* @__PURE__ */ u$5("div", {
    style,
    children: [
      "             _._  _-=.",
      /* @__PURE__ */ u$5("br", {}),
      "      -=-_ _-    Y    \\  _.",
      /* @__PURE__ */ u$5("br", {}),
      '     O    \\      |     &"  =-',
      /* @__PURE__ */ u$5("br", {}),
      "     |     |          /      )",
      /* @__PURE__ */ u$5("br", {}),
      "  ==-*                       '",
      /* @__PURE__ */ u$5("br", {}),
      " -    \\                     |",
      /* @__PURE__ */ u$5("br", {}),
      "(      -                    *",
      /* @__PURE__ */ u$5("br", {}),
      " \\_         _        -     /     404?????",
      /* @__PURE__ */ u$5("br", {}),
      "   -._       \\        |    |",
      /* @__PURE__ */ u$5("br", {}),
      '      "\\       \\      |    |',
      /* @__PURE__ */ u$5("br", {}),
      "        -       |     \\    L     _",
      /* @__PURE__ */ u$5("br", {}),
      `         '.      \\     | ..#=--"" |`,
      /* @__PURE__ */ u$5("br", {}),
      "           \\      \\   _|-          \\",
      /* @__PURE__ */ u$5("br", {}),
      '            &    _"-^             _-x',
      /* @__PURE__ */ u$5("br", {}),
      '            _#--             _.-""',
      /* @__PURE__ */ u$5("br", {}),
      '         <--            _.--"',
      /* @__PURE__ */ u$5("br", {}),
      '          -        __-""',
      /* @__PURE__ */ u$5("br", {}),
      '           \\   ..-"              O',
      /* @__PURE__ */ u$5("br", {}),
      "            x-'",
      /* @__PURE__ */ u$5("br", {}),
      "                        O",
      /* @__PURE__ */ u$5("br", {}),
      "                                _.--.",
      /* @__PURE__ */ u$5("br", {}),
      "                              -'",
      /* @__PURE__ */ u$5("br", {}),
      "                             '",
    ],
  });
}
function CollectionIdGuard() {
  const params = useParams();
  const collectionId = parseInt(params["id"] || "-1");
  const { data: collectionExists, isFetching } =
    useCollectionExists(collectionId);
  const absCenter = {
    alignItems: "center",
    bottom: 0,
    display: "flex",
    justifyContent: "center",
    left: 0,
    margin: "auto",
    position: "absolute",
    right: 0,
    top: 0,
  };
  return isFetching
    ? /* @__PURE__ */ u$5("div", {
        style: absCenter,
        children: /* @__PURE__ */ u$5(spinner_default, {
          style: "font-size: 350px; --track-width: 30px;",
        }),
      })
    : collectionExists
      ? /* @__PURE__ */ u$5(App, {})
      : /* @__PURE__ */ u$5(FourOFourPage, {});
}
initSessionAuth();
D$2(
  /* @__PURE__ */ u$5(QueryClientProvider, {
    client: queryClient,
    children: /* @__PURE__ */ u$5(BrowserRouter, {
      children: /* @__PURE__ */ u$5(Routes, {
        children: [
          /* @__PURE__ */ u$5(Route, {
            path: "/",
            element: /* @__PURE__ */ u$5(App, {}),
          }),
          /* @__PURE__ */ u$5(Route, {
            path: "/collection/:id",
            element: /* @__PURE__ */ u$5(CollectionIdGuard, {}),
          }),
          /* @__PURE__ */ u$5(Route, {
            path: "*",
            element: /* @__PURE__ */ u$5(FourOFourPage, {}),
          }),
        ],
      }),
    }),
  }),
  document.getElementById("app"),
);
